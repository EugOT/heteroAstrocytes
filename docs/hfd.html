<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.262">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>hfd</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="hfd_files/libs/clipboard/clipboard.min.js"></script>
<script src="hfd_files/libs/quarto-html/quarto.js"></script>
<script src="hfd_files/libs/quarto-html/popper.min.js"></script>
<script src="hfd_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="hfd_files/libs/quarto-html/anchor.min.js"></script>
<link href="hfd_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="hfd_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="hfd_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="hfd_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="hfd_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="section" class="level1">
<h1></h1>
</section>
<section id="section-1" class="level1">
<h1></h1>
</section>
<section id="section-2" class="level1">
<h1></h1>
</section>
<section id="section-3" class="level1">
<h1></h1>
</section>
<section id="section-4" class="level1">
<h1></h1>
</section>
<section id="section-5" class="level1">
<h1></h1>
</section>
<section id="section-6" class="level1">
<h1></h1>
</section>
<section id="section-7" class="level1">
<h1></h1>
</section>
<section id="section-8" class="level1">
<h1></h1>
</section>
<section id="section-9" class="level1">
<h1></h1>
</section>
<section id="section-10" class="level1">
<h1></h1>
</section>
<section id="section-11" class="level1">
<h1></h1>
</section>
<section id="section-12" class="level1">
<h1></h1>
</section>
<section id="section-13" class="level1">
<h1></h1>
</section>
<section id="section-14" class="level1">
<h1></h1>
</section>
<section id="section-15" class="level1">
<h1></h1>
</section>
<section id="section-16" class="level1">
<h1></h1>
</section>
<section id="section-17" class="level1">
<h1></h1>
</section>
<section id="section-18" class="level1">
<h1></h1>
</section>
<section id="section-19" class="level1">
<h1></h1>
</section>
<section id="section-20" class="level1">
<h1></h1>
</section>
<section id="section-21" class="level1">
<h1></h1>
</section>
<section id="section-22" class="level1">
<h1></h1>
</section>
<section id="section-23" class="level1">
<h1></h1>
</section>
<section id="section-24" class="level1">
<h1></h1>
</section>
<section id="section-25" class="level1">
<h1></h1>
</section>
<section id="section-26" class="level1">
<h1></h1>
</section>
<section id="section-27" class="level1">
<h1></h1>
</section>
<section id="section-28" class="level1">
<h1></h1>
</section>
<section id="section-29" class="level1">
<h1></h1>
</section>
<section id="section-30" class="level1">
<h1></h1>
</section>
<section id="section-31" class="level1">
<h1></h1>
</section>
<section id="section-32" class="level1">
<h1></h1>
</section>
<section id="section-33" class="level1">
<h1></h1>
</section>
<section id="section-34" class="level1">
<h1></h1>
</section>
<section id="section-35" class="level1">
<h1></h1>
</section>
<section id="section-36" class="level1">
<h1></h1>
</section>
<section id="section-37" class="level1">
<h1></h1>
<p>DOCNAME &lt;- “deng-2021-arcuate-nucleus-hfd-chow” NOW &lt;- Sys.time()</p>
</section>
<section id="time-chunks-during-knitting" class="level1">
<h1>Time chunks during knitting</h1>
<p>knitr::knit_hooks$set(timeit = function(before) { if (before) { print(paste(“Start:”, Sys.time())) NOW &lt;&lt;- Sys.time() } else { print(paste(“Stop:”, Sys.time())) print(Sys.time() - NOW) } })</p>
<p>knitr::knit_hooks$set(debug = function(before, options, envir) { if (!before) { message( paste(names(envir), as.list(envir), sep = ” = “, collapse =”” ) ) } })</p>
<p>knitr::opts_chunk$set( cache = FALSE, dev = c(“pdf”, “png”), timeit = TRUE ) # Load tidyverse infrastructure packages suppressPackageStartupMessages({ library(RColorBrewer) library(here) library(tidyverse) library(magrittr) library(stringr) library(skimr) library(future) library(zeallot) library(kableExtra) })</p>
</section>
<section id="load-packages-for-scrna-seq-analysis-and-visualisation" class="level1">
<h1>Load packages for scRNA-seq analysis and visualisation</h1>
<p>suppressPackageStartupMessages({ library(SingleCellExperiment) library(scuttle) library(scater) library(flexmix) library(splines) library(miQC) library(Seurat) library(SeuratWrappers) library(SeuratDisk) library(sctransform) library(glmGamPoi) library(MAST) library(UpSetR) library(patchwork) library(mrtree) library(swne) library(Nebulosa) })</p>
</section>
<section id="set-paths" class="level1">
<h1>Set paths</h1>
<p>src_dir &lt;- here(“code”) data_dir &lt;- here(“data”) output_dir &lt;- here(“output”) plots_dir &lt;- here(output_dir, “figures”) tables_dir &lt;- here(output_dir, “tables”) source(here(src_dir, “genes.R”)) source(here(src_dir, “functions.R”))</p>
</section>
<section id="parallelisation" class="level1">
<h1>parallelisation</h1>
<p>n_cores &lt;- 20 plan(“multisession”, workers = n_cores) options(future.globals.maxSize = 90000 * 1024^2) # 90Gb # plan(“sequential”) plan()</p>
</section>
<section id="set-seed" class="level1">
<h1>set seed</h1>
<p>reseed &lt;- 42 set.seed(seed = reseed)</p>
</section>
<section id="ggplot2-theme" class="level1">
<h1>ggplot2 theme</h1>
<p>theme_set(ggmin::theme_powerpoint()) # # # # # runs &lt;- c( “536-1_chow-diet”, “536-3_chow-diet”, “536-5_chow-diet”, “536-2_537-4_high-fat-diet”, “537-1_537-3_high-fat-diet”, “537-5_538-2_high-fat-diet” )</p>
<p>prepRun &lt;- function(prj) { mtx &lt;- Read10X(data.dir = paste0( “/data/HFD/”, sprintf(“%s/filtered_feature_bc_matrix/”, prj) )) srt &lt;- CreateSeuratObject( counts = mtx, project = prj, min.cells = 0, min.features = 200 ) srt<span class="math inline">\(age &lt;- "adult"  srt\)</span>sex &lt;- “male” srt<span class="math inline">\(study_id &lt;- "deng_2020"  srt\)</span>tech &lt;- “10xv3” srt$hfd &lt;- str_detect( string = prj, pattern = “high-fat-diet” ) return(srt) }</p>
<p>srt_list &lt;- runs |&gt; purrr::map(prepRun) names(srt_list) &lt;- runs</p>
<p>genes.embed &lt;- c( “Ndrg2”, “Slc1a3”, “Gfap”, “Gh”, “Agt”, “Slc6a11”, “Mfn2”, “Lxn”, “Pomc”, “Lep”, “Lepr”, “Ghsr” )</p>
</section>
<section id="section-38" class="level1">
<h1></h1>
</section>
<section id="section-39" class="level1">
<h1></h1>
</section>
<section id="section-40" class="level1">
<h1></h1>
</section>
<section id="section-41" class="level1">
<h1></h1>
</section>
<section id="section-42" class="level1">
<h1></h1>
</section>
<section id="section-43" class="level1">
<h1></h1>
</section>
<section id="section-44" class="level1">
<h1></h1>
</section>
<section id="section-45" class="level1">
<h1></h1>
</section>
<section id="section-46" class="level1">
<h1></h1>
<p>sce &lt;- as.SingleCellExperiment(srt_list[[“536-1_chow-diet”]]) mt_genes &lt;- grepl(“^mt-”, rownames(sce)) feature_ctrls &lt;- list(mito = rownames(sce)[mt_genes])</p>
<p>feature_ctrls # # # sce &lt;- addPerCellQC(sce, subsets = feature_ctrls)</p>
<p>qcstats &lt;- perCellQCMetrics(sce, subsets = feature_ctrls ) qcfilter &lt;- quickPerCellQC(qcstats, sub.fields = “subsets_mito_percent” ) colData(sce) &lt;- cbind(colData(sce), qcfilter)</p>
<p>plotMetrics(sce) head(colData(sce)) skim(sce<span class="math inline">\(sum) skim(sce\)</span>detected) skim(sce$subsets_mito_percent) plotColData(sce, x = “sum”, y = “detected”, colour_by = “discard”) plotColData(sce, x = “sum”, y = “detected”, other_fields = “discard”) + facet_wrap(~discard) plotColData(sce, x = “sum”, y = “subsets_mito_percent”, colour_by = “discard”) plotHighestExprs(sce, exprs_values = “counts”) # # # model &lt;- mixtureModel(sce) plotModel(sce, model) plotFiltering(sce, model)</p>
</section>
<section id="section-47" class="level1">
<h1></h1>
</section>
<section id="section-48" class="level1">
<h1></h1>
</section>
<section id="section-49" class="level1">
<h1></h1>
<p>model2 &lt;- mixtureModel(sce, model_type = “spline”) plotModel(sce, model2) plotFiltering(sce, model2) # # # plotFiltering(sce, model, posterior_cutoff = 0.95) # # # sce &lt;- filterCells(sce, model, posterior_cutoff = 0.95) srt_list[[“536-1_chow-diet”]] &lt;- as.Seurat(sce)</p>
<p>rm(sce, model, model2, feature_ctrls, mt_genes) gc() # # # # # sce &lt;- as.SingleCellExperiment(srt_list[[“536-3_chow-diet”]]) mt_genes &lt;- grepl(“^mt-”, rownames(sce)) feature_ctrls &lt;- list(mito = rownames(sce)[mt_genes])</p>
<p>feature_ctrls # # # sce &lt;- addPerCellQC(sce, subsets = feature_ctrls, BPPARAM = BiocParallel::MulticoreParam() ) qcstats &lt;- perCellQCMetrics(sce, subsets = feature_ctrls ) qcfilter &lt;- quickPerCellQC(qcstats, sub.fields = “subsets_mito_percent” ) colData(sce) &lt;- cbind(colData(sce), qcfilter)</p>
<p>plotMetrics(sce) head(colData(sce)) skim(sce<span class="math inline">\(sum) skim(sce\)</span>detected) skim(sce$subsets_mito_percent) plotColData(sce, x = “sum”, y = “detected”, colour_by = “discard”) plotColData(sce, x = “sum”, y = “detected”, other_fields = “discard”) + facet_wrap(~discard) plotColData(sce, x = “sum”, y = “subsets_mito_percent”, colour_by = “discard”) plotHighestExprs(sce, exprs_values = “counts”) # # # model &lt;- mixtureModel(sce) plotModel(sce, model) plotFiltering(sce, model)</p>
</section>
<section id="section-50" class="level1">
<h1></h1>
</section>
<section id="section-51" class="level1">
<h1></h1>
</section>
<section id="section-52" class="level1">
<h1></h1>
<p>model2 &lt;- mixtureModel(sce, model_type = “spline”) plotModel(sce, model2) plotFiltering(sce, model2) # # # plotFiltering(sce, model, posterior_cutoff = 0.95) # # # sce &lt;- filterCells(sce, model, posterior_cutoff = 0.95) srt_list[[“536-3_chow-diet”]] &lt;- as.Seurat(sce)</p>
<p>rm(sce, model, model2, feature_ctrls, mt_genes) gc() # # # # # sce &lt;- as.SingleCellExperiment(srt_list[[“536-5_chow-diet”]]) mt_genes &lt;- grepl(“^mt-”, rownames(sce)) feature_ctrls &lt;- list(mito = rownames(sce)[mt_genes])</p>
<p>feature_ctrls # # # sce &lt;- addPerCellQC(sce, subsets = feature_ctrls, BPPARAM = BiocParallel::MulticoreParam() ) qcstats &lt;- perCellQCMetrics(sce, subsets = feature_ctrls ) qcfilter &lt;- quickPerCellQC(qcstats, sub.fields = “subsets_mito_percent” ) colData(sce) &lt;- cbind(colData(sce), qcfilter)</p>
<p>plotMetrics(sce) head(colData(sce)) skim(sce<span class="math inline">\(sum) skim(sce\)</span>detected) skim(sce$subsets_mito_percent) plotColData(sce, x = “sum”, y = “detected”, colour_by = “discard”) plotColData(sce, x = “sum”, y = “detected”, other_fields = “discard”) + facet_wrap(~discard) plotColData(sce, x = “sum”, y = “subsets_mito_percent”, colour_by = “discard”) plotHighestExprs(sce, exprs_values = “counts”) # # # model &lt;- mixtureModel(sce) plotModel(sce, model) # plotFiltering(sce, model)</p>
</section>
<section id="section-53" class="level1">
<h1></h1>
</section>
<section id="section-54" class="level1">
<h1></h1>
</section>
<section id="section-55" class="level1">
<h1></h1>
</section>
<section id="section-56" class="level1">
<h1></h1>
</section>
<section id="section-57" class="level1">
<h1></h1>
<p>model2 &lt;- mixtureModel(sce, model_type = “spline”) plotModel(sce, model2) plotFiltering(sce, model2) # # # plotFiltering(sce, model2, posterior_cutoff = 0.7) # # # # # sce &lt;- filterCells(sce, model2, posterior_cutoff = 0.7) srt_list[[“536-5_chow-diet”]] &lt;- as.Seurat(sce)</p>
<p>rm(sce, model, model2, feature_ctrls, mt_genes) gc() # # # # # # # sce &lt;- as.SingleCellExperiment(srt_list[[“536-2_537-4_high-fat-diet”]]) mt_genes &lt;- grepl(“^mt-”, rownames(sce)) feature_ctrls &lt;- list(mito = rownames(sce)[mt_genes])</p>
<p>feature_ctrls # # # sce &lt;- addPerCellQC(sce, subsets = feature_ctrls, BPPARAM = BiocParallel::MulticoreParam() ) qcstats &lt;- perCellQCMetrics(sce, subsets = feature_ctrls ) qcfilter &lt;- quickPerCellQC(qcstats, sub.fields = “subsets_mito_percent” ) colData(sce) &lt;- cbind(colData(sce), qcfilter)</p>
<p>plotMetrics(sce) head(colData(sce)) skim(sce<span class="math inline">\(sum) skim(sce\)</span>detected) skim(sce$subsets_mito_percent) plotColData(sce, x = “sum”, y = “detected”, colour_by = “discard”) plotColData(sce, x = “sum”, y = “detected”, other_fields = “discard”) + facet_wrap(~discard) plotColData(sce, x = “sum”, y = “subsets_mito_percent”, colour_by = “discard”) plotHighestExprs(sce, exprs_values = “counts”) # # # model &lt;- mixtureModel(sce) plotModel(sce, model) # plotFiltering(sce, model)</p>
</section>
<section id="section-58" class="level1">
<h1></h1>
</section>
<section id="section-59" class="level1">
<h1></h1>
</section>
<section id="section-60" class="level1">
<h1></h1>
</section>
<section id="section-61" class="level1">
<h1></h1>
</section>
<section id="section-62" class="level1">
<h1></h1>
<p>model2 &lt;- mixtureModel(sce, model_type = “spline”) plotModel(sce, model2) plotFiltering(sce, model2) # # # plotFiltering(sce, model2, posterior_cutoff = 0.999999) # # # sce &lt;- filterCells(sce, model2, posterior_cutoff = 0.999999) srt_list[[“536-2_537-4_high-fat-diet”]] &lt;- as.Seurat(sce)</p>
<p>rm(sce, model, model2, feature_ctrls, mt_genes) gc() # # # # # sce &lt;- as.SingleCellExperiment(srt_list[[“537-1_537-3_high-fat-diet”]]) mt_genes &lt;- grepl(“^mt-”, rownames(sce)) feature_ctrls &lt;- list(mito = rownames(sce)[mt_genes])</p>
<p>feature_ctrls # # # sce &lt;- addPerCellQC(sce, subsets = feature_ctrls, BPPARAM = BiocParallel::MulticoreParam() ) qcstats &lt;- perCellQCMetrics(sce, subsets = feature_ctrls ) qcfilter &lt;- quickPerCellQC(qcstats, sub.fields = “subsets_mito_percent” ) colData(sce) &lt;- cbind(colData(sce), qcfilter)</p>
<p>plotMetrics(sce) head(colData(sce)) skim(sce<span class="math inline">\(sum) skim(sce\)</span>detected) skim(sce$subsets_mito_percent) plotColData(sce, x = “sum”, y = “detected”, colour_by = “discard”) plotColData(sce, x = “sum”, y = “detected”, other_fields = “discard”) + facet_wrap(~discard) plotColData(sce, x = “sum”, y = “subsets_mito_percent”, colour_by = “discard”) plotHighestExprs(sce, exprs_values = “counts”) # # # model &lt;- mixtureModel(sce) plotModel(sce, model) plotFiltering(sce, model)</p>
</section>
<section id="section-63" class="level1">
<h1></h1>
</section>
<section id="section-64" class="level1">
<h1></h1>
</section>
<section id="section-65" class="level1">
<h1></h1>
<p>model2 &lt;- mixtureModel(sce, model_type = “spline”) plotModel(sce, model2) plotFiltering(sce, model2) # # # plotFiltering(sce, model2, posterior_cutoff = 0.95) # # # sce &lt;- filterCells(sce, model2, posterior_cutoff = 0.95) srt_list[[“537-1_537-3_high-fat-diet”]] &lt;- as.Seurat(sce)</p>
<p>rm(sce, model, model2, feature_ctrls, mt_genes) gc() # # # # # sce &lt;- as.SingleCellExperiment(srt_list[[“537-5_538-2_high-fat-diet”]]) mt_genes &lt;- grepl(“^mt-”, rownames(sce)) feature_ctrls &lt;- list(mito = rownames(sce)[mt_genes])</p>
<p>feature_ctrls # # # sce &lt;- addPerCellQC(sce, subsets = feature_ctrls, BPPARAM = BiocParallel::MulticoreParam() ) qcstats &lt;- perCellQCMetrics(sce, subsets = feature_ctrls ) qcfilter &lt;- quickPerCellQC(qcstats, sub.fields = “subsets_mito_percent” ) colData(sce) &lt;- cbind(colData(sce), qcfilter)</p>
<p>plotMetrics(sce) head(colData(sce)) skim(sce<span class="math inline">\(sum) skim(sce\)</span>detected) skim(sce$subsets_mito_percent) plotColData(sce, x = “sum”, y = “detected”, colour_by = “discard”) plotColData(sce, x = “sum”, y = “detected”, other_fields = “discard”) + facet_wrap(~discard) plotColData(sce, x = “sum”, y = “subsets_mito_percent”, colour_by = “discard”) plotHighestExprs(sce, exprs_values = “counts”) # # # model &lt;- mixtureModel(sce) plotModel(sce, model) plotFiltering(sce, model)</p>
</section>
<section id="section-66" class="level1">
<h1></h1>
</section>
<section id="section-67" class="level1">
<h1></h1>
</section>
<section id="section-68" class="level1">
<h1></h1>
<p>model2 &lt;- mixtureModel(sce, model_type = “spline”) plotModel(sce, model2) plotFiltering(sce, model2) # # # plotFiltering(sce, model, posterior_cutoff = 0.95) # # # sce &lt;- filterCells(sce, model, posterior_cutoff = 0.95) srt_list[[“537-5_538-2_high-fat-diet”]] &lt;- as.Seurat(sce)</p>
<p>rm(sce, model, model2, feature_ctrls, mt_genes) gc() # # # # # deng_2020_combined_arc_chow &lt;- merge(srt_list[[“536-1_chow-diet”]], y = c( srt_list[[“536-3_chow-diet”]], srt_list[[“536-5_chow-diet”]] ), add.cell.ids = c( “P60_ARC_ND1”, “P60_ARC_ND3”, “P60_ARC_ND5” ), project = “Deng_chow_10xv3” ) glimpse(deng_2020_combined_arc_chow@meta.data) table(deng_2020_combined_arc_chow<span class="math inline">\(orig.ident) SaveH5Seurat(deng_2020_combined_arc_chow,  filename = here(  data_dir,  "deng_2020_arc_chow.h5Seurat"  ),  overwrite = TRUE ) Convert(  here(  data_dir,  "deng_2020_arc_chow.h5Seurat"  ),  dest = "h5ad",  overwrite = TRUE ) # # # deng_2020_combined_arc_hfd &lt;-  merge(srt_list[["536-2_537-4_high-fat-diet"]],  y = c(  srt_list[["537-1_537-3_high-fat-diet"]],  srt_list[["537-5_538-2_high-fat-diet"]]  ),  add.cell.ids = c(  "P60_ARC_HFD74",  "P60_ARC_HFD73",  "P60_ARC_HFD82"  ),  project = "Deng_hfd_10xv3"  ) glimpse(deng_2020_combined_arc_hfd@meta.data) table(deng_2020_combined_arc_hfd\)</span>orig.ident) SaveH5Seurat(deng_2020_combined_arc_hfd, filename = here( data_dir, “deng_2020_arc_hfd.h5Seurat” ), overwrite = TRUE ) Convert( here( data_dir, “deng_2020_arc_hfd.h5Seurat” ), dest = “h5ad”, overwrite = TRUE ) # # # # # # # # # # normalize and run dimensionality reduction on control dataset chow.list &lt;- SplitObject(deng_2020_combined_arc_chow, split.by = “orig.ident” ) chow.list &lt;- lapply( X = chow.list, vst.flavor = “v2”, FUN = SCTransform, vars.to.regress = “subsets_mito_percent”, method = “glmGamPoi”, variable.features.n = 5000, return.only.var.genes = FALSE, seed.use = reseed, verbose = FALSE ) # # # features &lt;- SelectIntegrationFeatures( object.list = chow.list, nfeatures = 3500, verbose = FALSE ) all_sct_features &lt;- chow.list |&gt; map(pluck, “assays”, “SCT”, “var.features”) |&gt; purrr::reduce(c) |&gt; unique() chow.list &lt;- PrepSCTIntegration(object.list = chow.list, anchor.features = features) # # # npcs &lt;- 30 chow.anchors &lt;- FindIntegrationAnchors( object.list = chow.list, normalization.method = “SCT”, anchor.features = features, reduction = “cca”, dims = 1:npcs, k.anchor = 20, k.score = 50, k.filter = 100, max.features = 500, n.trees = 100, verbose = FALSE ) head(chow.anchors@anchor.features, n = 1000) # # # chow.combined.sct &lt;- IntegrateData( anchorset = chow.anchors, normalization.method = “SCT”, features.to.integrate = features, dims = 1:npcs, k.weight = 200, verbose = FALSE ) # # # chow.combined.sct &lt;- chow.combined.sct |&gt; RunPCA(seed.use = reseed, verbose = FALSE) |&gt; FindNeighbors( dims = 1:10, k.param = 15, annoy.metric = “euclidean”, n.trees = 100, verbose = FALSE ) |&gt; RunUMAP( dims = 1:10, reduction.name = “umap”, reduction.key = “UMAP_”, return.model = TRUE, umap.method = “umap-learn”, densmap = TRUE, dens.lambda = 1L, dens.frac = 0.3, n.epochs = 1000L, n.neighbors = 15L, min.dist = 0.01, spread = 2L, metric = “correlation”, init = “pca”, seed.use = reseed, verbose = FALSE ) |&gt; FindNeighbors( reduction = “umap”, dims = 1:2, force.recalc = TRUE, k.param = 15, annoy.metric = “euclidean”, n.trees = 100, verbose = FALSE ) # # # # # plEmbCombBatch &lt;- DimPlot(chow.combined.sct, reduction = “umap”, group.by = “orig.ident”, pt.size = 3, label = TRUE, repel = TRUE ) + NoLegend() plEmbCombBatch # # # metadata &lt;- chow.combined.sct@meta.data rownames(metadata) &lt;- colnames(chow.combined.sct) ref.labels &lt;- metadata$orig.ident</p>
<p>resolutions &lt;- modularity_event_sampling( A = chow.combined.sct@graphs$integrated_snn, n.res = 70, gamma.min = 0.05, gamma.max = 4.000001 ) # sample based on the similarity matrix</p>
</section>
<section id="clustering-using-suerat" class="level1">
<h1>clustering using Suerat</h1>
<p>chow.combined.sct &lt;- chow.combined.sct |&gt; FindClusters( algorithm = 4, method = “igraph”, resolution = resolutions, random.seed = reseed, verbose = FALSE )</p>
</section>
<section id="initial-cluster-tree-from-seurat-flat-clustering" class="level1">
<h1>initial cluster tree from Seurat flat clustering</h1>
<p>plot_clustree( labelmat = chow.combined.sct@meta.data, prefix = “integrated_snn_res.”, ref.labels = ref.labels, plot.ref = FALSE ) # # # out &lt;- mrtree( chow.combined.sct, prefix = “integrated_snn_res.”, n.cores = n_cores, consensus = FALSE, augment.path = FALSE ) # if there are few partitions per k, within resolution consensus step can speed up the algorithm # weight per sample is encoraged if the classes are imbalanced</p>
<p>plot_tree( labelmat = out<span class="math inline">\(labelmat.mrtree,  ref.labels = ref.labels,  plot.piechart = TRUE,  node.size = 0.2,  tip.label.dist = 10,  bottom.margin = 30 ) # # # # Adjusted Multiresolution Rand Index (AMRI) ks.flat &lt;- apply(  out\)</span>labelmat.flat, 2, FUN = function(x) { length(unique(x)) } ) ks.mrtree &lt;- apply( out<span class="math inline">\(labelmat.mrtree,  2,  FUN = function(x) {  length(unique(x))  } ) amri.flat &lt;- sapply(1:ncol(out\)</span>labelmat.flat), function(i) { AMRI(out<span class="math inline">\(labelmat.flat[, i], ref.labels)\)</span>amri }) amri.flat &lt;- aggregate(amri.flat, by = list(k = ks.flat), FUN = mean) amri.recon &lt;- sapply(1:ncol(out<span class="math inline">\(labelmat.mrtree), function(i) {  AMRI(out\)</span>labelmat.mrtree[, i], ref.labels)$amri })</p>
<p>df &lt;- rbind( data.frame( k = amri.flat<span class="math inline">\(k,  amri = amri.flat\)</span>x, method = “Seurat flat” ), data.frame(k = ks.mrtree, amri = amri.recon, method = “MRtree”) ) ggplot2::ggplot(data = df, aes(x = k, y = amri, color = method)) + geom_line() + theme_bw() # # # stab.out &lt;- stability_plot(out) stab.out<span class="math inline">\(plot # # # kable_material(  kable(  stab.out\)</span>df, “html” ), bootstrap_options = “striped”, position = “left”, font_size = 14 )</p>
<p>resK &lt;- SelectResolution(stab.out$df) resK</p>
<p>kable_material( kable( table( out<span class="math inline">\(labelmat.mrtree[, which.min(  abs(as.integer(  str_remove(dimnames(  out\)</span>labelmat.mrtree )[[2]], “K”) ) - resK) )] ), “html” ), bootstrap_options = “striped”, position = “left”, font_size = 14 ) # # # chow.combined.sct<span class="math inline">\(k_tree &lt;- out\)</span>labelmat.mrtree[, which.min( abs(as.integer( str_remove(dimnames( out$labelmat.mrtree )[[2]], “K”) ) - resK) )] p1 &lt;- DimPlot(chow.combined.sct, label = T, repel = T, pt.size = 2) + ggtitle(“Unsupervised clustering”) + NoLegend() p2 &lt;- DimPlot(chow.combined.sct, label = T, repel = T, group.by = “k_tree”, pt.size = 2) + ggtitle(“MRTree”) + NoLegend()</p>
<p>p1 | p2 # # # Idents(chow.combined.sct) &lt;- “k_tree” chow.combined.sct &lt;- PrepSCTFindMarkers(chow.combined.sct, assay = “SCT”)</p>
<p>chow.markers.roc &lt;- FindAllMarkers( chow.combined.sct, assay = “SCT”, verbose = FALSE, random.seed = reseed, only.pos = FALSE, min.pct = 0.25, base = 10, logfc.threshold = 0.1, densify = TRUE, test.use = “roc” ) write_csv( chow.markers.roc, here( tables_dir, “deng2021-chow-all-mrk_roc-sct.csv” ) )</p>
<p>chow.markers.roc %&gt;% group_by(cluster) %&gt;% slice_max(n = 3, order_by = avg_log10FC) %&gt;% kable(“html”) %&gt;% kable_material( bootstrap_options = “striped”, position = “left”, font_size = 14 )</p>
<p>chow.markers.wilcox &lt;- FindAllMarkers( chow.combined.sct, assay = “SCT”, verbose = FALSE, random.seed = reseed, only.pos = FALSE, min.pct = 0.25, base = 10, logfc.threshold = 0.05, densify = TRUE, test.use = “wilcox” ) write_csv( chow.markers.wilcox, here( tables_dir, “deng2021-chow-all-mrk_wilcox-sct.csv” ) ) chow.markers.wilcox %&gt;% group_by(cluster) %&gt;% slice_max(n = 3, order_by = avg_log10FC) %&gt;% kable(“html”) %&gt;% kable_material( bootstrap_options = “striped”, position = “left”, font_size = 14 )</p>
</section>
<section id="section-69" class="level1">
<h1></h1>
</section>
<section id="section-70" class="level1">
<h1></h1>
</section>
<section id="section-71" class="level1">
<h1></h1>
<p>chow.markers.wilcox %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log10FC) -&gt; top10 DoHeatmap(chow.combined.sct, features = top10<span class="math inline">\(gene) + NoLegend() # # # FeaturePlot(  chow.combined.sct,  features = c(  "Fos", "Glul", "Gja1", "Ndrg2",  "Hepacam", "Slc1a3",  "S100b", "Tafa1", "Aldh1a1", "Plcb1",  "Sgcd", "Slit2", "Apoe", "Gfap",  "Slc38a1", "Cst3", "Lxn", "Mfn2"  ),  min.cutoff = "q05", max.cutoff = "q95",  ncol = 4, order = TRUE ) +  patchwork::plot_annotation(  title = "Astro-Marker order integrated (Arc Deng 2021)",  theme = theme(plot.title = element_text(size = 22))  ) # # # FeaturePlot(  chow.combined.sct,  features = c(  "Apoe", "Gfap", "Slit2", "Aldh1a1",  "Tafa1", "Plcb1", "Sgcd", "Slc38a1",  "Fos", "Gja1", "Snap25", "Olig1",  "Per2", "Lars2", "Lxn", "Mfn2",  "Rarres2", "Ccdc153", "Rax", "Col23a1",  "Col25a1", "6330403K07Rik", "Frzb"  ),  min.cutoff = "q01", max.cutoff = "q99",  ncol = 4, order = TRUE ) +  patchwork::plot_annotation(  title = "Astro-Marker test integrated (Arc Deng 2021)",  theme = theme(plot.title = element_text(size = 22))  ) # # # FeaturePlot(chow.combined.sct,  features = c(  "Agrp", "Npy", "Pomc",  "Slc17a6", "Tbx3", "Foxo4",  "Gad1", "Gad2", "Slc32a1",  "Sst", "Th", "Ddc", "S100a6",  "Ntrk2", "Crym", "Snap25"  ),  order = TRUE, min.cutoff = "q9",  ncol = 3 ) # # # DefaultAssay(object = chow.combined.sct) &lt;- "RNA" DoHeatmap(chow.combined.sct, features = top10\)</span>gene, slot = “data”) + NoLegend() # # # FeaturePlot( chow.combined.sct, features = c( “Fos”, “Glul”, “Gja1”, “Ndrg2”, “Hepacam”, “Slc1a3”, “S100b”, “Tafa1”, “Aldh1a1”, “Plcb1”, “Sgcd”, “Slit2”, “Apoe”, “Gfap”, “Slc38a1”, “Cst3”, “Lxn”, “Mfn2” ), min.cutoff = “q05”, max.cutoff = “q95”, ncol = 4, order = TRUE, slot = “data” ) + patchwork::plot_annotation( title = “Astro-Marker order RNA (Arc Deng 2021)”, theme = theme(plot.title = element_text(size = 22)) ) # # # FeaturePlot( chow.combined.sct, features = c( “Apoe”, “Gfap”, “Slit2”, “Aldh1a1”, “Tafa1”, “Plcb1”, “Sgcd”, “Slc38a1”, “Fos”, “Gja1”, “Snap25”, “Olig1”, “Per2”, “Lars2”, “Lxn”, “Mfn2”, “Rarres2”, “Ccdc153”, “Rax”, “Col23a1”, “Col25a1”, “6330403K07Rik”, “Frzb” ), min.cutoff = “q01”, max.cutoff = “q99”, ncol = 4, order = TRUE, slot = “data” ) + patchwork::plot_annotation( title = “Astro-Marker test RNA (Arc Deng 2021)”, theme = theme(plot.title = element_text(size = 22)) ) # # # FeaturePlot(chow.combined.sct, features = c( “Agrp”, “Npy”, “Pomc”, “Slc17a6”, “Tbx3”, “Foxo4”, “Gad1”, “Gad2”, “Slc32a1”, “Sst”, “Th”, “Ddc”, “S100a6”, “Ntrk2”, “Crym”, “Snap25” ), order = TRUE, min.cutoff = “q9”, ncol = 3, slot = “data” ) # # # Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “4”)) &lt;- “Astrocytes1” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “11”)) &lt;- “Astrocytes2” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “12”)) &lt;- “Tanycytes_Ependyma” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “13”)) &lt;- “OPC1” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “15”)) &lt;- “OPC2” chow.combined.sct$level1 &lt;- Idents(chow.combined.sct)</p>
<p>glimpse(chow.combined.sct@meta.data) table(chow.combined.sct$level1) SaveH5Seurat( chow.combined.sct, filename = here( data_dir, “deng_2020_arc_chow_clusters.h5Seurat” ), overwrite = TRUE ) Convert( here( data_dir, “deng_2020_arc_chow_clusters.h5Seurat” ), dest = “h5ad”, overwrite = TRUE )</p>
</section>
<section id="section-72" class="level1">
<h1></h1>
</section>
<section id="section-73" class="level1">
<h1></h1>
</section>
<section id="section-74" class="level1">
<h1></h1>
</section>
<section id="section-75" class="level1">
<h1></h1>
</section>
<section id="section-76" class="level1">
<h1></h1>
<p>chow.combined.sct &lt;- subset( chow.combined.sct, idents = c( “Astrocytes1”, “Astrocytes2”, “Tanycytes_Ependyma”, “OPC1”, “OPC2” ) ) DefaultAssay(chow.combined.sct) &lt;- “RNA” chow.combined.sct &lt;- DietSeurat(chow.combined.sct, assays = “RNA”)</p>
</section>
<section id="normalize-and-run-dimensionality-reduction-on-control-dataset" class="level1">
<h1>normalize and run dimensionality reduction on control dataset</h1>
<p>npcs &lt;- 30 metadata &lt;- chow.combined.sct@meta.data %&gt;% select(orig.ident, nCount_RNA, nFeature_RNA, age, sex, study_id, tech, hfd, subsets_mito_detected, subsets_mito_percent, prob_compromised, level1) rownames(metadata) &lt;- colnames(chow.combined.sct) chow.combined.sct@meta.data &lt;- metadata chow.list &lt;- SplitObject(chow.combined.sct, split.by = “orig.ident” ) chow.list &lt;- lapply( X = chow.list, vst.flavor = “v2”, FUN = SCTransform, vars.to.regress = “subsets_mito_percent”, method = “glmGamPoi”, variable.features.n = 8000, return.only.var.genes = FALSE, seed.use = reseed, verbose = FALSE )</p>
<p>features &lt;- SelectIntegrationFeatures( object.list = chow.list, nfeatures = 5000, verbose = FALSE ) all_sct_features &lt;- chow.list |&gt; map(pluck, “assays”, “SCT”, “var.features”) |&gt; purrr::reduce(c) |&gt; unique() chow.list &lt;- PrepSCTIntegration(object.list = chow.list, anchor.features = features)</p>
<p>npcs &lt;- 20 chow.anchors &lt;- FindIntegrationAnchors( object.list = chow.list, normalization.method = “SCT”, anchor.features = features, reduction = “cca”, dims = 1:npcs, k.anchor = 20, k.score = 50, k.filter = 100, max.features = 500, n.trees = 100, verbose = FALSE ) head(chow.anchors@anchor.features, n = 1000)</p>
<p>chow.combined.sct &lt;- IntegrateData( anchorset = chow.anchors, normalization.method = “SCT”, features.to.integrate = features, dims = 1:npcs, k.weight = 150, verbose = FALSE )</p>
<p>chow.combined.sct &lt;- chow.combined.sct |&gt; RunPCA(seed.use = reseed, verbose = FALSE)</p>
</section>
<section id="section-77" class="level1">
<h1></h1>
</section>
<section id="section-78" class="level1">
<h1></h1>
</section>
<section id="section-79" class="level1">
<h1></h1>
<p>print(chow.combined.sct[[“pca”]], dims = 1:5, nfeatures = 5) # # # VizDimLoadings(chow.combined.sct, dims = 1:20, reduction = “pca”) # # # DimHeatmap(chow.combined.sct, dims = 1:15, cells = 500, balanced = TRUE) # # # ElbowPlot(chow.combined.sct, ndims = npcs) # # # chow.combined.sct &lt;- chow.combined.sct |&gt; FindNeighbors( dims = 1:npcs, k.param = 15, annoy.metric = “euclidean”, n.trees = 100, verbose = FALSE ) |&gt; RunUMAP( dims = 1:npcs, reduction.name = “umap”, reduction.key = “UMAP_”, return.model = TRUE, umap.method = “umap-learn”, densmap = TRUE, dens.lambda = 1L, dens.frac = 0.3, n.epochs = 1000L, n.neighbors = 15L, min.dist = 0.01, spread = 2L, metric = “correlation”, init = “pca”, seed.use = reseed, verbose = FALSE ) |&gt; FindNeighbors( reduction = “umap”, dims = 1:2, force.recalc = TRUE, k.param = 15, annoy.metric = “euclidean”, n.trees = 100, verbose = FALSE ) metadata &lt;- chow.combined.sct@meta.data rownames(metadata) &lt;- colnames(chow.combined.sct) ref.labels &lt;- metadata$level1</p>
<p>resolutions &lt;- modularity_event_sampling( A = chow.combined.sct@graphs$integrated_snn, n.res = 70, gamma.min = 0.05, gamma.max = 4.000001 ) # sample based on the similarity matrix</p>
</section>
<section id="clustering-using-suerat-1" class="level1">
<h1>clustering using Suerat</h1>
<p>chow.combined.sct &lt;- chow.combined.sct |&gt; FindClusters( algorithm = 4, method = “igraph”, resolution = resolutions, random.seed = reseed, verbose = FALSE )</p>
</section>
<section id="initial-cluster-tree-from-seurat-flat-clustering-1" class="level1">
<h1>initial cluster tree from Seurat flat clustering</h1>
<p>plot_clustree( labelmat = chow.combined.sct@meta.data, prefix = “integrated_snn_res.”, ref.labels = ref.labels, plot.ref = FALSE ) # # # out &lt;- mrtree( chow.combined.sct, prefix = “integrated_snn_res.”, n.cores = n_cores, consensus = FALSE, augment.path = FALSE ) # if there are few partitions per k, within resolution consensus step can speed up the algorithm # weight per sample is encoraged if the classes are imbalanced</p>
<p>plot_tree( labelmat = out<span class="math inline">\(labelmat.mrtree,  ref.labels = ref.labels,  plot.piechart = TRUE,  node.size = 0.2,  tip.label.dist = 10,  bottom.margin = 30 ) # # # # Adjusted Multiresolution Rand Index (AMRI) ks.flat &lt;- apply(  out\)</span>labelmat.flat, 2, FUN = function(x) { length(unique(x)) } ) ks.mrtree &lt;- apply( out<span class="math inline">\(labelmat.mrtree,  2,  FUN = function(x) {  length(unique(x))  } ) amri.flat &lt;- sapply(1:ncol(out\)</span>labelmat.flat), function(i) { AMRI(out<span class="math inline">\(labelmat.flat[, i], ref.labels)\)</span>amri }) amri.flat &lt;- aggregate(amri.flat, by = list(k = ks.flat), FUN = mean) amri.recon &lt;- sapply(1:ncol(out<span class="math inline">\(labelmat.mrtree), function(i) {  AMRI(out\)</span>labelmat.mrtree[, i], ref.labels)$amri })</p>
<p>df &lt;- rbind( data.frame( k = amri.flat<span class="math inline">\(k,  amri = amri.flat\)</span>x, method = “Seurat flat” ), data.frame(k = ks.mrtree, amri = amri.recon, method = “MRtree”) ) ggplot2::ggplot(data = df, aes(x = k, y = amri, color = method)) + geom_line() + theme_bw() # # # stab.out &lt;- stability_plot(out) stab.out<span class="math inline">\(plot # # # kable_material(  kable(  stab.out\)</span>df, “html” ), bootstrap_options = “striped”, position = “left”, font_size = 14 )</p>
<p>resK &lt;- SelectResolution(stab.out$df) resK</p>
<p>kable_material( kable( table( out<span class="math inline">\(labelmat.mrtree[, which.min(  abs(as.integer(  str_remove(dimnames(  out\)</span>labelmat.mrtree )[[2]], “K”) ) - resK) )] ), “html” ), bootstrap_options = “striped”, position = “left”, font_size = 14 ) # # # chow.combined.sct<span class="math inline">\(k_tree &lt;- out\)</span>labelmat.mrtree[, which.min( abs(as.integer( str_remove(dimnames( out$labelmat.mrtree )[[2]], “K”) ) - resK) )] p1 &lt;- DimPlot(chow.combined.sct, label = T, repel = T) + ggtitle(“Unsupervised clustering”) + NoLegend() p2 &lt;- DimPlot(chow.combined.sct, label = T, repel = T, group.by = “k_tree”) + ggtitle(“MRTree”) + NoLegend() p3 &lt;- DimPlot(chow.combined.sct, label = T, repel = T, group.by = “level1”) + ggtitle(“First iteration”) + NoLegend()</p>
<p>p1 | p2 | p3 # # # Idents(chow.combined.sct) &lt;- “k_tree” chow.combined.sct &lt;- PrepSCTFindMarkers(chow.combined.sct, assay = “SCT”)</p>
<p>chow.markers.roc &lt;- FindAllMarkers( chow.combined.sct, assay = “SCT”, verbose = FALSE, random.seed = reseed, only.pos = FALSE, min.pct = 0.05, base = 10, logfc.threshold = 0.05, densify = TRUE, test.use = “roc” ) write_csv( chow.markers.roc, here( tables_dir, “deng2021-chow-all-mrk_roc-sct-iter2.csv” ) )</p>
<p>chow.markers.roc %&gt;% group_by(cluster) %&gt;% slice_max(n = 3, order_by = avg_log10FC) %&gt;% kable(“html”) %&gt;% kable_material( bootstrap_options = “striped”, position = “left”, font_size = 14 )</p>
<p>chow.markers.wilcox &lt;- FindAllMarkers( chow.combined.sct, assay = “SCT”, verbose = FALSE, random.seed = reseed, only.pos = FALSE, min.pct = 0.05, base = 10, logfc.threshold = 0.05, densify = TRUE, test.use = “wilcox” ) write_csv( chow.markers.wilcox, here( tables_dir, “deng2021-chow-all-mrk_wilcox-sct-iter2.csv” ) ) chow.markers.wilcox %&gt;% group_by(cluster) %&gt;% slice_max(n = 3, order_by = avg_log10FC) %&gt;% kable(“html”) %&gt;% kable_material( bootstrap_options = “striped”, position = “left”, font_size = 14 ) # # # DefaultAssay(object = chow.combined.sct) &lt;- “integrated” chow.markers.wilcox %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log10FC) -&gt; top10 DoHeatmap(chow.combined.sct, features = top10<span class="math inline">\(gene) + NoLegend() # # # FeaturePlot(  chow.combined.sct,  features = c(  "Fos", "Glul", "Gja1", "Ndrg2", "Otp",  "S100b", "Tafa1", "Aldh1a1", "Plcb1",  "Sgcd", "Slit2", "Apoe", "Gfap",  "Slc38a1", "Cst3", "Lxn", "Mfn2",  "Npy1r", "Npy2r", "Esr1", "Prlr"  ),  min.cutoff = "q05", max.cutoff = "q95",  ncol = 4, order = TRUE ) +  patchwork::plot_annotation(  title = "Astro-Marker order integrated (Arc Deng 2021)",  theme = theme(plot.title = element_text(size = 22))  ) # # # DefaultAssay(object = chow.combined.sct) &lt;- "RNA" DoHeatmap(chow.combined.sct, features = top10\)</span>gene, slot = “counts”) + NoLegend() # # # FeaturePlot( chow.combined.sct, features = c( “Fos”, “Glul”, “Gja1”, “Ndrg2”, “Otp”, “S100b”, “Tafa1”, “Aldh1a1”, “Plcb1”, “Sgcd”, “Slit2”, “Apoe”, “Gfap”, “Slc38a1”, “Cst3”, “Lxn”, “Mfn2”, “Npy1r”, “Npy2r”, “Esr1”, “Prlr” ), min.cutoff = “q05”, max.cutoff = “q95”, ncol = 4, order = TRUE, slot = “data” ) + patchwork::plot_annotation( title = “Astro-Marker order RNA (Arc Deng 2021)”, theme = theme(plot.title = element_text(size = 22)) ) # # # DefaultAssay(object = chow.combined.sct) &lt;- “RNA” plCorrLxnNpy1r &lt;- FeatureScatter(chow.combined.sct, “Lxn”, “Npy1r”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrLxnNpy2r &lt;- FeatureScatter(chow.combined.sct, “Lxn”, “Npy2r”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrLxnGfap &lt;- FeatureScatter(chow.combined.sct, “Lxn”, “Gfap”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrLxnMfn2 &lt;- FeatureScatter(chow.combined.sct, “Lxn”, “Mfn2”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrLxnNpy1r | plCorrLxnNpy2r | plCorrLxnGfap | plCorrLxnMfn2 # # # DefaultAssay(object = chow.combined.sct) &lt;- “RNA” plCorrGja1Npy1r &lt;- FeatureScatter(chow.combined.sct, “Gja1”, “Npy1r”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrGja1Npy2r &lt;- FeatureScatter(chow.combined.sct, “Gja1”, “Npy2r”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrGja1Gfap &lt;- FeatureScatter(chow.combined.sct, “Gja1”, “Gfap”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrGja1Mfn2 &lt;- FeatureScatter(chow.combined.sct, “Gja1”, “Mfn2”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrGja1Npy1r | plCorrGja1Npy2r | plCorrGja1Gfap | plCorrGja1Mfn2 # # # plEmbCombBatch &lt;- DimPlot(chow.combined.sct, reduction = “umap”, group.by = “orig.ident”, pt.size = 2, label = TRUE, repel = TRUE, shuffle = TRUE ) + NoLegend() plEmbCombBatch | p2 # # # # # Idents(chow.combined.sct) &lt;- “k_tree” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “1”)) &lt;- “Astrocytes1” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “2”)) &lt;- “Astrocytes2” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “5”)) &lt;- “Astrocytes3” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “6”)) &lt;- “Astrocytes4” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “9”)) &lt;- “Astrocytes5” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “14”)) &lt;- “Astrocytes6” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “12”)) &lt;- “Astrocytes7” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “3”)) &lt;- “Astrocytes8” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “7”)) &lt;- “Astrocytes9” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “15”)) &lt;- “Astrocytes10” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “11”)) &lt;- “Tanycytes_Ependyma1” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “13”)) &lt;- “Tanycytes_Ependyma2” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “4”)) &lt;- “OPC1” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “10”)) &lt;- “OPC2” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “8”)) &lt;- “OPC3” Idents(chow.combined.sct, cells = WhichCells(chow.combined.sct, idents = “16”)) &lt;- “OPC4” chow.combined.sct$level2 &lt;- Idents(chow.combined.sct) chow.combined.sct &lt;- subset( chow.combined.sct, idents = str_c(“Astrocytes”, 1:10) ) DefaultAssay(chow.combined.sct) &lt;- “RNA” chow.combined.sct &lt;- DietSeurat(chow.combined.sct, assays = “RNA”)</p>
</section>
<section id="normalize-and-run-dimensionality-reduction-on-control-dataset-1" class="level1">
<h1>normalize and run dimensionality reduction on control dataset</h1>
<p>metadata &lt;- chow.combined.sct@meta.data %&gt;% select(orig.ident, nCount_RNA, nFeature_RNA, age, sex, study_id, tech, hfd, subsets_mito_detected, subsets_mito_percent, prob_compromised, level1, level2) rownames(metadata) &lt;- colnames(chow.combined.sct) chow.combined.sct@meta.data &lt;- metadata chow.list &lt;- SplitObject(chow.combined.sct, split.by = “orig.ident” ) chow.list &lt;- lapply( X = chow.list, vst.flavor = “v2”, FUN = SCTransform, vars.to.regress = “subsets_mito_percent”, variable.features.n = 3500, return.only.var.genes = FALSE, seed.use = reseed, verbose = FALSE )</p>
<p>features &lt;- SelectIntegrationFeatures( object.list = chow.list, nfeatures = 2000, verbose = FALSE ) all_sct_features &lt;- chow.list |&gt; map(pluck, “assays”, “SCT”, “var.features”) |&gt; purrr::reduce(c) |&gt; unique() chow.list &lt;- PrepSCTIntegration(object.list = chow.list, anchor.features = features)</p>
<p>npcs &lt;- 15 chow.anchors &lt;- FindIntegrationAnchors( object.list = chow.list, normalization.method = “SCT”, anchor.features = features, reduction = “cca”, dims = 1:npcs, k.anchor = 10, k.score = 25, k.filter = 100, max.features = 200, n.trees = 100, verbose = FALSE ) head(chow.anchors@anchor.features, n = 1000)</p>
<p>chow.combined.sct &lt;- IntegrateData( anchorset = chow.anchors, normalization.method = “SCT”, features.to.integrate = features, dims = 1:npcs, k.weight = 25, verbose = FALSE ) npcs &lt;- 30 chow.combined.sct &lt;- chow.combined.sct |&gt; RunPCA(seed.use = reseed, verbose = FALSE)</p>
</section>
<section id="section-80" class="level1">
<h1></h1>
</section>
<section id="section-81" class="level1">
<h1></h1>
</section>
<section id="section-82" class="level1">
<h1></h1>
<p>print(chow.combined.sct[[“pca”]], dims = 1:5, nfeatures = 5) # # # VizDimLoadings(chow.combined.sct, dims = 1:20, reduction = “pca”) # # # DimHeatmap(chow.combined.sct, dims = 1:15, cells = 500, balanced = TRUE) # # # ElbowPlot(chow.combined.sct, ndims = npcs) # # # chow.combined.sct &lt;- chow.combined.sct |&gt; FindNeighbors( dims = 1:npcs, k.param = 15, annoy.metric = “euclidean”, n.trees = 100, verbose = FALSE ) |&gt; RunUMAP( dims = 1:npcs, reduction.name = “umap”, reduction.key = “UMAP_”, return.model = TRUE, umap.method = “umap-learn”, densmap = TRUE, dens.lambda = 1L, dens.frac = 0.3, n.epochs = 1000L, n.neighbors = 15L, min.dist = 0.01, spread = 2L, metric = “correlation”, init = “pca”, seed.use = reseed, verbose = FALSE ) |&gt; FindNeighbors( reduction = “umap”, dims = 1:2, force.recalc = TRUE, k.param = 15, annoy.metric = “euclidean”, n.trees = 100, verbose = FALSE ) metadata &lt;- chow.combined.sct@meta.data rownames(metadata) &lt;- colnames(chow.combined.sct) ref.labels &lt;- metadata$level2</p>
<p>resolutions &lt;- modularity_event_sampling( A = chow.combined.sct@graphs$integrated_snn, n.res = 70, gamma.min = 0.05, gamma.max = 4.000001 ) # sample based on the similarity matrix</p>
</section>
<section id="clustering-using-suerat-2" class="level1">
<h1>clustering using Suerat</h1>
<p>chow.combined.sct &lt;- chow.combined.sct |&gt; FindClusters( algorithm = 4, method = “igraph”, resolution = resolutions, random.seed = reseed, verbose = FALSE )</p>
</section>
<section id="initial-cluster-tree-from-seurat-flat-clustering-2" class="level1">
<h1>initial cluster tree from Seurat flat clustering</h1>
<p>plot_clustree( labelmat = chow.combined.sct@meta.data, prefix = “integrated_snn_res.”, ref.labels = ref.labels, plot.ref = FALSE ) # # # out &lt;- mrtree( chow.combined.sct, prefix = “integrated_snn_res.”, n.cores = n_cores, consensus = FALSE, augment.path = FALSE ) # if there are few partitions per k, within resolution consensus step can speed up the algorithm # weight per sample is encoraged if the classes are imbalanced</p>
<p>plot_tree( labelmat = out<span class="math inline">\(labelmat.mrtree,  ref.labels = ref.labels,  plot.piechart = TRUE,  node.size = 0.2,  tip.label.dist = 10,  bottom.margin = 30 ) # # # # Adjusted Multiresolution Rand Index (AMRI) ks.flat &lt;- apply(  out\)</span>labelmat.flat, 2, FUN = function(x) { length(unique(x)) } ) ks.mrtree &lt;- apply( out<span class="math inline">\(labelmat.mrtree,  2,  FUN = function(x) {  length(unique(x))  } ) amri.flat &lt;- sapply(1:ncol(out\)</span>labelmat.flat), function(i) { AMRI(out<span class="math inline">\(labelmat.flat[, i], ref.labels)\)</span>amri }) amri.flat &lt;- aggregate(amri.flat, by = list(k = ks.flat), FUN = mean) amri.recon &lt;- sapply(1:ncol(out<span class="math inline">\(labelmat.mrtree), function(i) {  AMRI(out\)</span>labelmat.mrtree[, i], ref.labels)$amri })</p>
<p>df &lt;- rbind( data.frame( k = amri.flat<span class="math inline">\(k,  amri = amri.flat\)</span>x, method = “Seurat flat” ), data.frame(k = ks.mrtree, amri = amri.recon, method = “MRtree”) ) ggplot2::ggplot(data = df, aes(x = k, y = amri, color = method)) + geom_line() + theme_bw() # # # stab.out &lt;- stability_plot(out) stab.out<span class="math inline">\(plot # # # kable_material(  kable(  stab.out\)</span>df, “html” ), bootstrap_options = “striped”, position = “left”, font_size = 14 )</p>
<p>resK &lt;- SelectResolution(stab.out$df) resK</p>
<p>kable_material( kable( table( out<span class="math inline">\(labelmat.mrtree[, which.min(  abs(as.integer(  str_remove(dimnames(  out\)</span>labelmat.mrtree )[[2]], “K”) ) - resK) )] ), “html” ), bootstrap_options = “striped”, position = “left”, font_size = 14 ) # # # chow.combined.sct<span class="math inline">\(k_tree &lt;- out\)</span>labelmat.mrtree[, which.min( abs(as.integer( str_remove(dimnames( out$labelmat.mrtree )[[2]], “K”) ) - resK) )] p1 &lt;- DimPlot(chow.combined.sct, label = T, repel = T) + ggtitle(“Unsupervised clustering”) + NoLegend() p2 &lt;- DimPlot(chow.combined.sct, label = T, repel = T, group.by = “k_tree”) + ggtitle(“MRTree”) + NoLegend() p3 &lt;- DimPlot(chow.combined.sct, label = T, repel = T, group.by = “level2”) + ggtitle(“Second iteration”) + NoLegend()</p>
<p>p1 | p2 | p3 # # # Idents(chow.combined.sct) &lt;- “k_tree” chow.combined.sct &lt;- PrepSCTFindMarkers(chow.combined.sct, assay = “SCT”)</p>
<p>chow.markers.roc &lt;- FindAllMarkers( chow.combined.sct, assay = “SCT”, verbose = FALSE, random.seed = reseed, only.pos = FALSE, min.pct = 0.05, base = 10, logfc.threshold = 0.05, densify = TRUE, test.use = “roc” ) write_csv( chow.markers.roc, here( tables_dir, “deng2021-chow-all-mrk_roc-sct-iter3.csv” ) )</p>
<p>chow.markers.roc %&gt;% group_by(cluster) %&gt;% slice_max(n = 3, order_by = avg_log10FC) %&gt;% kable(“html”) %&gt;% kable_material( bootstrap_options = “striped”, position = “left”, font_size = 14 )</p>
<p>chow.markers.wilcox &lt;- FindAllMarkers( chow.combined.sct, assay = “SCT”, verbose = FALSE, random.seed = reseed, only.pos = FALSE, min.pct = 0.05, base = 10, logfc.threshold = 0.05, densify = TRUE, test.use = “wilcox” ) write_csv( chow.markers.wilcox, here( tables_dir, “deng2021-chow-all-mrk_wilcox-sct-iter3.csv” ) ) chow.markers.wilcox %&gt;% group_by(cluster) %&gt;% slice_max(n = 3, order_by = avg_log10FC) %&gt;% kable(“html”) %&gt;% kable_material( bootstrap_options = “striped”, position = “left”, font_size = 14 ) # # # pvn.markers.lr &lt;- readr::read_csv(here(“../Lopez2021/output/tables/pvn-all-mrk_logreg-sct-iter3.csv”)) glimpse(pvn.markers.lr) pvn.markers.lr %&lt;&gt;% mutate(pct.dif = pct.1 - pct.2) skim(pvn.markers.lr) # # pvn.markers.lr.filt &lt;- pvn.markers.lr |&gt; filter( p_val_adj &lt;= .001, pct.1 &gt;= .15, pct.dif &gt;= quantile(pct.dif, .25) ) |&gt; arrange(p_val_adj) |&gt; distinct(gene, .keep_all = T)</p>
<p>glimpse(pvn.markers.lr.filt) skim(pvn.markers.lr.filt) # # chow.markers.roc.filt &lt;- chow.markers.roc |&gt; filter( p_val_adj &lt;= .001, pct.1 &gt;= .15, pct.dif &gt;= quantile(pct.dif, .25) ) |&gt; arrange(p_val_adj) |&gt; distinct(gene, .keep_all = T)</p>
<p>glimpse(chow.markers.roc.filt) skim(chow.markers.roc.filt) # # # chow.markers.wilcox.filt &lt;- chow.markers.wilcox |&gt; filter( p_val_adj &lt;= .001, pct.1 &gt;= .15, pct.dif &gt;= quantile(pct.dif, .25) ) |&gt; arrange(p_val_adj) |&gt; distinct(gene, .keep_all = T)</p>
<p>glimpse(chow.markers.wilcox.filt) skim(chow.markers.wilcox.filt) # # # pvn.markers.lr |&gt; filter(gene %in% c( “Slc1a3”, “Glul”, “Gja1”, “Ndrg2”, “Ntrk2”, “S100b”, “Tafa1”, “Aldh1a1”, “Aldh1l1”, “Plcb1”, “Slit2”, “Apoe”, “Gfap”, “Ntsr2”, “Slc38a1”, “Cst3”, “Nfia”, “Mfn2”, “Lxn”, “Npy1r”, “Npy2r”, “Esr1”, “Prlr”, “Otp” )) |&gt; arrange(p_val_adj) |&gt; distinct(gene, .keep_all = T) # # # # chow.markers.roc %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log10FC) -&gt; top10 chow.markers.wilcox %&gt;% group_by(cluster) %&gt;% filter(p_val_adj &lt; 0.05, avg_log10FC &gt; 0.05) %&gt;% top_n(n = 15, wt = avg_log10FC) -&gt; top15 DoHeatmap(chow.combined.sct, features = top15<span class="math inline">\(gene) + NoLegend() # # # DefaultAssay(object = chow.combined.sct) &lt;- "integrated" FeaturePlot(  chow.combined.sct,  features = top10\)</span>gene, min.cutoff = “q05”, max.cutoff = “q95”, ncol = 5, order = TRUE ) + patchwork::plot_annotation( title = “Astro-Marker ROC-test (Arc Deng 2021)”, theme = theme(plot.title = element_text(size = 22)) ) # # # DefaultAssay(object = chow.combined.sct) &lt;- “RNA” FeaturePlot( chow.combined.sct, slot = “data”, features = top10<span class="math inline">\(gene,  min.cutoff = "q05", max.cutoff = "q95",  ncol = 5, order = TRUE ) +  patchwork::plot_annotation(  title = "Astro-Marker ROC-test RNA (Arc Deng 2021)",  theme = theme(plot.title = element_text(size = 22))  ) # # # FeaturePlot(  chow.combined.sct,  features = c(  "Slc1a3", "Glul", "Gja1", "Ndrg2", "Ntrk2",  "S100b", "Tafa1", "Aldh1a1", "Aldh1l1",  "Plcb1", "Slit2", "Apoe", "Gfap", "Ntsr2",  "Slc38a1", "Cst3", "Nfia", "Mfn2", "Lxn",  "Npy1r", "Npy2r", "Esr1", "Prlr", "Otp"  ),  min.cutoff = "q05", max.cutoff = "q95",  ncol = 4, order = TRUE, slot = "data" ) +  patchwork::plot_annotation(  title = "Astro-Marker order RNA (Arc Deng 2021)",  theme = theme(plot.title = element_text(size = 22))  ) # # # DoHeatmap(chow.combined.sct, features = top15\)</span>gene, slot = “data”) + NoLegend() # # # FeaturePlot( chow.combined.sct, features = c(gene_int[83:93], “Lmo3”), min.cutoff = “q05”, max.cutoff = “q95”, ncol = 4, order = TRUE, slot = “data” ) + patchwork::plot_annotation( title = “Astro-Marker ins RNA (Arc Deng 2021)”, theme = theme(plot.title = element_text(size = 22)) ) # # # # DefaultAssay(object = chow.combined.sct) &lt;- “RNA” plCorrLxnNpy1r &lt;- FeatureScatter(chow.combined.sct, “Lxn”, “Npy1r”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrLxnNpy2r &lt;- FeatureScatter(chow.combined.sct, “Lxn”, “Npy2r”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrLxnGfap &lt;- FeatureScatter(chow.combined.sct, “Lxn”, “Gfap”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrLxnMfn2 &lt;- FeatureScatter(chow.combined.sct, “Lxn”, “Mfn2”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrLxnNpy1r | plCorrLxnNpy2r | plCorrLxnGfap | plCorrLxnMfn2 # # # # # DefaultAssay(object = chow.combined.sct) &lt;- “RNA” plCorrGja1Npy1r &lt;- FeatureScatter(chow.combined.sct, “Gja1”, “Npy1r”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrGja1Npy2r &lt;- FeatureScatter(chow.combined.sct, “Gja1”, “Npy2r”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrGja1Gfap &lt;- FeatureScatter(chow.combined.sct, “Gja1”, “Gfap”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrGja1Mfn2 &lt;- FeatureScatter(chow.combined.sct, “Gja1”, “Mfn2”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrGja1Npy1r | plCorrGja1Npy2r | plCorrGja1Gfap | plCorrGja1Mfn2 # # # glimpse(chow.combined.sct@meta.data) table(chow.combined.sct<span class="math inline">\(level1) table(chow.combined.sct\)</span>level2) table(Idents(chow.combined.sct)) SaveH5Seurat( chow.combined.sct, filename = here( data_dir, “deng_2020_arc_chow_astrocytes_sct.h5Seurat” ), overwrite = TRUE ) Convert( here( data_dir, “deng_2020_arc_chow_astrocytes_sct.h5Seurat” ), dest = “h5ad”, overwrite = TRUE ) # # # # # # # # normalize and run dimensionality reduction on control dataset hfd.list &lt;- SplitObject(deng_2020_combined_arc_hfd, split.by = “orig.ident” ) hfd.list &lt;- lapply( X = hfd.list, vst.flavor = “v2”, FUN = SCTransform, vars.to.regress = “subsets_mito_percent”, method = “glmGamPoi”, variable.features.n = 5000, return.only.var.genes = FALSE, seed.use = reseed, verbose = FALSE )</p>
<p>features &lt;- SelectIntegrationFeatures( object.list = hfd.list, nfeatures = 3500, verbose = FALSE ) all_sct_features &lt;- hfd.list |&gt; map(pluck, “assays”, “SCT”, “var.features”) |&gt; purrr::reduce(c) |&gt; unique() hfd.list &lt;- PrepSCTIntegration(object.list = hfd.list, anchor.features = features)</p>
<p>npcs &lt;- 30 hfd.anchors &lt;- FindIntegrationAnchors( object.list = hfd.list, normalization.method = “SCT”, anchor.features = features, reduction = “cca”, dims = 1:npcs, k.anchor = 20, k.score = 50, k.filter = 100, max.features = 500, n.trees = 100, verbose = FALSE ) head(hfd.anchors@anchor.features, n = 1000)</p>
<p>hfd.combined.sct &lt;- IntegrateData( anchorset = hfd.anchors, normalization.method = “SCT”, features.to.integrate = features, dims = 1:npcs, k.weight = 200, verbose = FALSE )</p>
<p>hfd.combined.sct &lt;- hfd.combined.sct |&gt; RunPCA(seed.use = reseed, npcs = npcs, verbose = FALSE) |&gt; FindNeighbors( dims = 1:20, k.param = 20, annoy.metric = “euclidean”, n.trees = 100, verbose = FALSE ) |&gt; RunUMAP( dims = 1:20, reduction.name = “umap”, reduction.key = “UMAP_”, return.model = TRUE, umap.method = “umap-learn”, densmap = TRUE, dens.lambda = 1L, dens.frac = 0.3, n.epochs = 1000L, n.neighbors = 20L, min.dist = 0.05, spread = 8L, metric = “correlation”, init = “pca”, seed.use = reseed, verbose = FALSE ) |&gt; FindNeighbors( reduction = “umap”, dims = 1:2, force.recalc = TRUE, k.param = 20, annoy.metric = “euclidean”, n.trees = 100, verbose = FALSE ) # # # # # plEmbCombBatch &lt;- DimPlot( hfd.combined.sct, reduction = “umap”, group.by = “orig.ident”, pt.size = 3, label = TRUE, repel = TRUE, shuffle = TRUE ) + NoLegend() plEmbCombBatch # # # metadata &lt;- hfd.combined.sct@meta.data rownames(metadata) &lt;- colnames(hfd.combined.sct) ref.labels &lt;- metadata$orig.ident</p>
<p>resolutions &lt;- modularity_event_sampling( A = hfd.combined.sct@graphs$integrated_snn, n.res = 70, gamma.min = 0.05, gamma.max = 4.000001 ) # sample based on the similarity matrix</p>
</section>
<section id="clustering-using-suerat-3" class="level1">
<h1>clustering using Suerat</h1>
<p>hfd.combined.sct &lt;- hfd.combined.sct |&gt; FindClusters( algorithm = 4, method = “igraph”, resolution = resolutions, random.seed = reseed, verbose = FALSE )</p>
</section>
<section id="initial-cluster-tree-from-seurat-flat-clustering-3" class="level1">
<h1>initial cluster tree from Seurat flat clustering</h1>
<p>plot_clustree( labelmat = hfd.combined.sct@meta.data, prefix = “integrated_snn_res.”, ref.labels = ref.labels, plot.ref = FALSE ) # # # out &lt;- mrtree( hfd.combined.sct, prefix = “integrated_snn_res.”, n.cores = n_cores, consensus = FALSE, augment.path = FALSE ) # if there are few partitions per k, within resolution consensus step can speed up the algorithm # weight per sample is encoraged if the classes are imbalanced</p>
<p>plot_tree( labelmat = out<span class="math inline">\(labelmat.mrtree,  ref.labels = ref.labels,  plot.piechart = TRUE,  node.size = 0.2,  tip.label.dist = 10,  bottom.margin = 30 ) # # # # Adjusted Multiresolution Rand Index (AMRI) ks.flat &lt;- apply(  out\)</span>labelmat.flat, 2, FUN = function(x) { length(unique(x)) } ) ks.mrtree &lt;- apply( out<span class="math inline">\(labelmat.mrtree,  2,  FUN = function(x) {  length(unique(x))  } ) amri.flat &lt;- sapply(1:ncol(out\)</span>labelmat.flat), function(i) { AMRI(out<span class="math inline">\(labelmat.flat[, i], ref.labels)\)</span>amri }) amri.flat &lt;- aggregate(amri.flat, by = list(k = ks.flat), FUN = mean) amri.recon &lt;- sapply(1:ncol(out<span class="math inline">\(labelmat.mrtree), function(i) {  AMRI(out\)</span>labelmat.mrtree[, i], ref.labels)$amri })</p>
<p>df &lt;- rbind( data.frame( k = amri.flat<span class="math inline">\(k,  amri = amri.flat\)</span>x, method = “Seurat flat” ), data.frame(k = ks.mrtree, amri = amri.recon, method = “MRtree”) ) ggplot2::ggplot(data = df, aes(x = k, y = amri, color = method)) + geom_line() + theme_bw() # # # stab.out &lt;- stability_plot(out) stab.out<span class="math inline">\(plot # # # kable_material(  kable(  stab.out\)</span>df, “html” ), bootstrap_options = “striped”, position = “left”, font_size = 14 )</p>
<p>resK &lt;- SelectResolution(stab.out$df) resK</p>
<p>kable_material( kable( table( out<span class="math inline">\(labelmat.mrtree[, which.min(  abs(as.integer(  str_remove(dimnames(  out\)</span>labelmat.mrtree )[[2]], “K”) ) - resK) )] ), “html” ), bootstrap_options = “striped”, position = “left”, font_size = 14 ) # # # hfd.combined.sct<span class="math inline">\(k_tree &lt;- out\)</span>labelmat.mrtree[, which.min( abs(as.integer( str_remove(dimnames( out$labelmat.mrtree )[[2]], “K”) ) - resK) )] p1 &lt;- DimPlot(hfd.combined.sct, label = T, repel = T, pt.size = 2) + ggtitle(“Unsupervised clustering”) + NoLegend() p2 &lt;- DimPlot(hfd.combined.sct, label = T, repel = T, group.by = “k_tree”, pt.size = 2) + ggtitle(“MRTree”) + NoLegend()</p>
<p>p1 | p2 # # # FeaturePlot( hfd.combined.sct, features = “subsets_mito_percent” ) &amp; theme(plot.title = element_text(size = 10)) &amp; scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = “RdYlGn”)))</p>
<p>FeaturePlot( hfd.combined.sct, features = “nFeature_RNA” ) &amp; theme(plot.title = element_text(size = 10)) &amp; scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = “RdYlGn”))) # # # # Idents(hfd.combined.sct) &lt;- “k_tree” hfd.combined.sct &lt;- PrepSCTFindMarkers(hfd.combined.sct, assay = “SCT”)</p>
<p>hfd.markers.roc &lt;- FindAllMarkers( hfd.combined.sct, assay = “SCT”, verbose = FALSE, random.seed = reseed, only.pos = FALSE, min.pct = 0.25, base = 10, logfc.threshold = 0.1, densify = TRUE, test.use = “roc” ) write_csv( hfd.markers.roc, here( tables_dir, “deng2021-hfd-all-mrk_roc-sct.csv” ) )</p>
<p>hfd.markers.roc %&gt;% group_by(cluster) %&gt;% slice_max(n = 3, order_by = avg_log10FC) %&gt;% kable(“html”) %&gt;% kable_material( bootstrap_options = “striped”, position = “left”, font_size = 14 )</p>
<p>hfd.markers.wilcox &lt;- FindAllMarkers( hfd.combined.sct, assay = “SCT”, verbose = FALSE, random.seed = reseed, only.pos = FALSE, min.pct = 0.25, base = 10, logfc.threshold = 0.05, densify = TRUE, test.use = “wilcox” ) write_csv( hfd.markers.wilcox, here( tables_dir, “deng2021-hfd-all-mrk_wilcox-sct.csv” ) ) hfd.markers.wilcox %&gt;% group_by(cluster) %&gt;% slice_max(n = 3, order_by = avg_log10FC) %&gt;% kable(“html”) %&gt;% kable_material( bootstrap_options = “striped”, position = “left”, font_size = 14 )</p>
</section>
<section id="section-83" class="level1">
<h1></h1>
</section>
<section id="section-84" class="level1">
<h1></h1>
</section>
<section id="section-85" class="level1">
<h1></h1>
<p>DefaultAssay(object = hfd.combined.sct) &lt;- “integrated” hfd.markers.wilcox %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log10FC) -&gt; top10 DoHeatmap(hfd.combined.sct, features = top10<span class="math inline">\(gene) + NoLegend() # # # FeaturePlot(  hfd.combined.sct,  features = c(  "Fos", "Glul", "Gja1", "Ndrg2",  "Hepacam", "Slc1a3",  "S100b", "Tafa1", "Aldh1a1", "Plcb1",  "Sgcd", "Slit2", "Apoe", "Gfap",  "Slc38a1", "Cst3", "Lxn", "Mfn2"  ),  min.cutoff = "q05", max.cutoff = "q95",  ncol = 4, order = TRUE ) +  patchwork::plot_annotation(  title = "Astro-Marker order integrated (Arc Deng 2021)",  theme = theme(plot.title = element_text(size = 22))  ) &amp; scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral"))) # # # FeaturePlot(  hfd.combined.sct,  features = c(  "Apoe", "Gfap", "Slit2", "Aldh1a1",  "Tafa1", "Plcb1", "Sgcd", "Slc38a1",  "Fos", "Gja1", "Snap25", "Olig1",  "Per2", "Lars2", "Lxn", "Mfn2",  "Rarres2", "Ccdc153", "Rax", "Col23a1",  "Col25a1", "6330403K07Rik", "Frzb"  ),  min.cutoff = "q05", max.cutoff = "q95",  ncol = 4, order = TRUE ) +  patchwork::plot_annotation(  title = "Astro-Marker test integrated (Arc Deng 2021)",  theme = theme(plot.title = element_text(size = 22))  ) &amp; scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral"))) # # # FeaturePlot(  hfd.combined.sct,  features = c(  "Agrp", "Npy", "Pomc",  "Slc17a6", "Tbx3", "Foxo4",  "Gad1", "Gad2", "Slc32a1",  "Sst", "Th", "Ddc", "S100a6",  "Ntrk2", "Crym", "Snap25"  ),  min.cutoff = "q05", max.cutoff = "q95",  ncol = 3, order = TRUE ) &amp; scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral"))) # # # DefaultAssay(object = hfd.combined.sct) &lt;- "RNA" DoHeatmap(hfd.combined.sct, features = top10\)</span>gene, slot = “data”) + NoLegend() # # # FeaturePlot( hfd.combined.sct, features = c( “Fos”, “Glul”, “Gja1”, “Ndrg2”, “Hepacam”, “Slc1a3”, “S100b”, “Tafa1”, “Aldh1a1”, “Plcb1”, “Sgcd”, “Slit2”, “Apoe”, “Gfap”, “Slc38a1”, “Cst3”, “Lxn”, “Mfn2” ), min.cutoff = “q05”, max.cutoff = “q95”, ncol = 4, order = TRUE, slot = “data” ) + patchwork::plot_annotation( title = “Astro-Marker order RNA (Arc Deng 2021)”, theme = theme(plot.title = element_text(size = 22)) ) &amp; scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = “PiYG”))) # # # FeaturePlot( hfd.combined.sct, features = c( “Apoe”, “Gfap”, “Slit2”, “Aldh1a1”, “Tafa1”, “Plcb1”, “Sgcd”, “Slc38a1”, “Fos”, “Gja1”, “Snap25”, “Olig1”, “Per2”, “Lars2”, “Lxn”, “Mfn2”, “Rarres2”, “Ccdc153”, “Rax”, “Col23a1”, “Col25a1”, “6330403K07Rik”, “Frzb” ), min.cutoff = “q05”, max.cutoff = “q95”, ncol = 4, order = TRUE, slot = “data” ) + patchwork::plot_annotation( title = “Astro-Marker test RNA (Arc Deng 2021)”, theme = theme(plot.title = element_text(size = 22)) ) &amp; scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = “PiYG”))) # # # FeaturePlot(hfd.combined.sct, features = c( “Agrp”, “Npy”, “Pomc”, “Slc17a6”, “Tbx3”, “Foxo4”, “Gad1”, “Gad2”, “Slc32a1”, “Sst”, “Th”, “Ddc”, “S100a6”, “Ntrk2”, “Crym”, “Snap25” ), min.cutoff = “q05”, max.cutoff = “q95”, order = TRUE, ncol = 3, slot = “data” ) &amp; scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = “PiYG”))) # # # Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “4”)) &lt;- “Astrocytes1” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “11”)) &lt;- “Astrocytes2” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “12”)) &lt;- “Tanycytes_Ependyma” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “13”)) &lt;- “OPC1” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “15”)) &lt;- “OPC2” hfd.combined.sct$level1 &lt;- Idents(hfd.combined.sct)</p>
<p>glimpse(hfd.combined.sct@meta.data) table(hfd.combined.sct$level1) SaveH5Seurat( hfd.combined.sct, filename = here( data_dir, “deng_2020_arc_hfd_clusters.h5Seurat” ), overwrite = TRUE ) Convert( here( data_dir, “deng_2020_arc_hfd_clusters.h5Seurat” ), dest = “h5ad”, overwrite = TRUE )</p>
</section>
<section id="section-86" class="level1">
<h1></h1>
</section>
<section id="section-87" class="level1">
<h1></h1>
</section>
<section id="section-88" class="level1">
<h1></h1>
</section>
<section id="section-89" class="level1">
<h1></h1>
</section>
<section id="section-90" class="level1">
<h1></h1>
<p>hfd.combined.sct &lt;- subset( hfd.combined.sct, idents = c( “Astrocytes1”, “Astrocytes2”, “Tanycytes_Ependyma”, “OPC1”, “OPC2” ) ) DefaultAssay(hfd.combined.sct) &lt;- “RNA” hfd.combined.sct &lt;- DietSeurat(hfd.combined.sct, assays = “RNA”)</p>
</section>
<section id="normalize-and-run-dimensionality-reduction-on-control-dataset-2" class="level1">
<h1>normalize and run dimensionality reduction on control dataset</h1>
<p>npcs &lt;- 30 metadata &lt;- hfd.combined.sct@meta.data %&gt;% select(orig.ident, nCount_RNA, nFeature_RNA, age, sex, study_id, tech, hfd, subsets_mito_detected, subsets_mito_percent, prob_compromised, level1) rownames(metadata) &lt;- colnames(hfd.combined.sct) hfd.combined.sct@meta.data &lt;- metadata hfd.list &lt;- SplitObject(hfd.combined.sct, split.by = “orig.ident” ) hfd.list &lt;- lapply( X = hfd.list, vst.flavor = “v2”, FUN = SCTransform, vars.to.regress = “subsets_mito_percent”, method = “glmGamPoi”, variable.features.n = 8000, return.only.var.genes = FALSE, seed.use = reseed, verbose = FALSE )</p>
<p>features &lt;- SelectIntegrationFeatures( object.list = hfd.list, nfeatures = 5000, verbose = FALSE ) all_sct_features &lt;- hfd.list |&gt; map(pluck, “assays”, “SCT”, “var.features”) |&gt; purrr::reduce(c) |&gt; unique() hfd.list &lt;- PrepSCTIntegration(object.list = hfd.list, anchor.features = features)</p>
<p>npcs &lt;- 20 hfd.anchors &lt;- FindIntegrationAnchors( object.list = hfd.list, normalization.method = “SCT”, anchor.features = features, reduction = “cca”, dims = 1:npcs, k.anchor = 20, k.score = 50, k.filter = 100, max.features = 500, n.trees = 100, verbose = FALSE ) head(hfd.anchors@anchor.features, n = 1000)</p>
<p>hfd.combined.sct &lt;- IntegrateData( anchorset = hfd.anchors, normalization.method = “SCT”, features.to.integrate = features, dims = 1:npcs, k.weight = 150, verbose = FALSE )</p>
<p>hfd.combined.sct &lt;- hfd.combined.sct |&gt; RunPCA(seed.use = reseed, verbose = FALSE)</p>
</section>
<section id="section-91" class="level1">
<h1></h1>
</section>
<section id="section-92" class="level1">
<h1></h1>
</section>
<section id="section-93" class="level1">
<h1></h1>
<p>print(hfd.combined.sct[[“pca”]], dims = 1:5, nfeatures = 5) # # # VizDimLoadings(hfd.combined.sct, dims = 1:20, reduction = “pca”) # # # DimHeatmap(hfd.combined.sct, dims = 1:15, cells = 500, balanced = TRUE) # # # ElbowPlot(hfd.combined.sct, ndims = npcs) # # # hfd.combined.sct &lt;- hfd.combined.sct |&gt; FindNeighbors( dims = 1:npcs, k.param = 15, annoy.metric = “euclidean”, n.trees = 100, verbose = FALSE ) |&gt; RunUMAP( dims = 1:npcs, reduction.name = “umap”, reduction.key = “UMAP_”, return.model = TRUE, umap.method = “umap-learn”, densmap = TRUE, dens.lambda = 1L, dens.frac = 0.3, n.epochs = 1000L, n.neighbors = 15L, min.dist = 0.01, spread = 2L, metric = “correlation”, init = “pca”, seed.use = reseed, verbose = FALSE ) |&gt; FindNeighbors( reduction = “umap”, dims = 1:2, force.recalc = TRUE, k.param = 15, annoy.metric = “euclidean”, n.trees = 100, verbose = FALSE ) metadata &lt;- hfd.combined.sct@meta.data rownames(metadata) &lt;- colnames(hfd.combined.sct) ref.labels &lt;- metadata$level1</p>
<p>resolutions &lt;- modularity_event_sampling( A = hfd.combined.sct@graphs$integrated_snn, n.res = 70, gamma.min = 0.05, gamma.max = 4.000001 ) # sample based on the similarity matrix</p>
</section>
<section id="clustering-using-suerat-4" class="level1">
<h1>clustering using Suerat</h1>
<p>hfd.combined.sct &lt;- hfd.combined.sct |&gt; FindClusters( algorithm = 4, method = “igraph”, resolution = resolutions, random.seed = reseed, verbose = FALSE )</p>
</section>
<section id="initial-cluster-tree-from-seurat-flat-clustering-4" class="level1">
<h1>initial cluster tree from Seurat flat clustering</h1>
<p>plot_clustree( labelmat = hfd.combined.sct@meta.data, prefix = “integrated_snn_res.”, ref.labels = ref.labels, plot.ref = FALSE ) # # # out &lt;- mrtree( hfd.combined.sct, prefix = “integrated_snn_res.”, n.cores = n_cores, consensus = FALSE, augment.path = FALSE ) # if there are few partitions per k, within resolution consensus step can speed up the algorithm # weight per sample is encoraged if the classes are imbalanced</p>
<p>plot_tree( labelmat = out<span class="math inline">\(labelmat.mrtree,  ref.labels = ref.labels,  plot.piechart = TRUE,  node.size = 0.2,  tip.label.dist = 10,  bottom.margin = 30 ) # # # # Adjusted Multiresolution Rand Index (AMRI) ks.flat &lt;- apply(  out\)</span>labelmat.flat, 2, FUN = function(x) { length(unique(x)) } ) ks.mrtree &lt;- apply( out<span class="math inline">\(labelmat.mrtree,  2,  FUN = function(x) {  length(unique(x))  } ) amri.flat &lt;- sapply(1:ncol(out\)</span>labelmat.flat), function(i) { AMRI(out<span class="math inline">\(labelmat.flat[, i], ref.labels)\)</span>amri }) amri.flat &lt;- aggregate(amri.flat, by = list(k = ks.flat), FUN = mean) amri.recon &lt;- sapply(1:ncol(out<span class="math inline">\(labelmat.mrtree), function(i) {  AMRI(out\)</span>labelmat.mrtree[, i], ref.labels)$amri })</p>
<p>df &lt;- rbind( data.frame( k = amri.flat<span class="math inline">\(k,  amri = amri.flat\)</span>x, method = “Seurat flat” ), data.frame(k = ks.mrtree, amri = amri.recon, method = “MRtree”) ) ggplot2::ggplot(data = df, aes(x = k, y = amri, color = method)) + geom_line() + theme_bw() # # # stab.out &lt;- stability_plot(out) stab.out<span class="math inline">\(plot # # # kable_material(  kable(  stab.out\)</span>df, “html” ), bootstrap_options = “striped”, position = “left”, font_size = 14 )</p>
<p>resK &lt;- SelectResolution(stab.out$df) resK</p>
<p>kable_material( kable( table( out<span class="math inline">\(labelmat.mrtree[, which.min(  abs(as.integer(  str_remove(dimnames(  out\)</span>labelmat.mrtree )[[2]], “K”) ) - resK) )] ), “html” ), bootstrap_options = “striped”, position = “left”, font_size = 14 ) # # # hfd.combined.sct<span class="math inline">\(k_tree &lt;- out\)</span>labelmat.mrtree[, which.min( abs(as.integer( str_remove(dimnames( out$labelmat.mrtree )[[2]], “K”) ) - resK) )] p1 &lt;- DimPlot(hfd.combined.sct, label = T, repel = T) + ggtitle(“Unsupervised clustering”) + NoLegend() p2 &lt;- DimPlot(hfd.combined.sct, label = T, repel = T, group.by = “k_tree”) + ggtitle(“MRTree”) + NoLegend() p3 &lt;- DimPlot(hfd.combined.sct, label = T, repel = T, group.by = “level1”) + ggtitle(“First iteration”) + NoLegend()</p>
<p>p1 | p2 | p3 # # # Idents(hfd.combined.sct) &lt;- “k_tree” hfd.combined.sct &lt;- PrepSCTFindMarkers(hfd.combined.sct, assay = “SCT”)</p>
<p>hfd.markers.roc &lt;- FindAllMarkers( hfd.combined.sct, assay = “SCT”, verbose = FALSE, random.seed = reseed, only.pos = FALSE, min.pct = 0.05, base = 10, logfc.threshold = 0.05, densify = TRUE, test.use = “roc” ) write_csv( hfd.markers.roc, here( tables_dir, “deng2021-hfd-all-mrk_roc-sct-iter2.csv” ) )</p>
<p>hfd.markers.roc %&gt;% group_by(cluster) %&gt;% slice_max(n = 3, order_by = avg_log10FC) %&gt;% kable(“html”) %&gt;% kable_material( bootstrap_options = “striped”, position = “left”, font_size = 14 )</p>
<p>hfd.markers.wilcox &lt;- FindAllMarkers( hfd.combined.sct, assay = “SCT”, verbose = FALSE, random.seed = reseed, only.pos = FALSE, min.pct = 0.05, base = 10, logfc.threshold = 0.05, densify = TRUE, test.use = “wilcox” ) write_csv( hfd.markers.wilcox, here( tables_dir, “deng2021-hfd-all-mrk_wilcox-sct-iter2.csv” ) ) hfd.markers.wilcox %&gt;% group_by(cluster) %&gt;% slice_max(n = 3, order_by = avg_log10FC) %&gt;% kable(“html”) %&gt;% kable_material( bootstrap_options = “striped”, position = “left”, font_size = 14 ) # # # DefaultAssay(object = hfd.combined.sct) &lt;- “integrated” hfd.markers.wilcox %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log10FC) -&gt; top10 DoHeatmap(hfd.combined.sct, features = top10<span class="math inline">\(gene) + NoLegend() # # # FeaturePlot(  hfd.combined.sct,  features = c(  "Fos", "Glul", "Gja1", "Ndrg2", "Otp",  "S100b", "Tafa1", "Aldh1a1", "Plcb1",  "Sgcd", "Slit2", "Apoe", "Gfap",  "Slc38a1", "Cst3", "Lxn", "Mfn2",  "Npy1r", "Npy2r", "Esr1", "Prlr"  ),  min.cutoff = "q05", max.cutoff = "q95",  ncol = 4, order = TRUE ) +  patchwork::plot_annotation(  title = "Astro-Marker order integrated (Arc Deng 2021)",  theme = theme(plot.title = element_text(size = 22))  ) # # # DefaultAssay(object = hfd.combined.sct) &lt;- "RNA" DoHeatmap(hfd.combined.sct, features = top10\)</span>gene, slot = “counts”) + NoLegend() # # # FeaturePlot( hfd.combined.sct, features = c( “Fos”, “Glul”, “Gja1”, “Ndrg2”, “Otp”, “S100b”, “Tafa1”, “Aldh1a1”, “Plcb1”, “Sgcd”, “Slit2”, “Apoe”, “Gfap”, “Slc38a1”, “Cst3”, “Lxn”, “Mfn2”, “Npy1r”, “Npy2r”, “Esr1”, “Prlr” ), min.cutoff = “q05”, max.cutoff = “q95”, ncol = 4, order = TRUE, slot = “data” ) + patchwork::plot_annotation( title = “Astro-Marker order RNA (Arc Deng 2021)”, theme = theme(plot.title = element_text(size = 22)) ) # # # DefaultAssay(object = hfd.combined.sct) &lt;- “RNA” plCorrLxnNpy1r &lt;- FeatureScatter(hfd.combined.sct, “Lxn”, “Npy1r”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrLxnNpy2r &lt;- FeatureScatter(hfd.combined.sct, “Lxn”, “Npy2r”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrLxnGfap &lt;- FeatureScatter(hfd.combined.sct, “Lxn”, “Gfap”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrLxnMfn2 &lt;- FeatureScatter(hfd.combined.sct, “Lxn”, “Mfn2”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrLxnNpy1r | plCorrLxnNpy2r | plCorrLxnGfap | plCorrLxnMfn2 # # # DefaultAssay(object = hfd.combined.sct) &lt;- “RNA” plCorrGja1Npy1r &lt;- FeatureScatter(hfd.combined.sct, “Gja1”, “Npy1r”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrGja1Npy2r &lt;- FeatureScatter(hfd.combined.sct, “Gja1”, “Npy2r”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrGja1Gfap &lt;- FeatureScatter(hfd.combined.sct, “Gja1”, “Gfap”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrGja1Mfn2 &lt;- FeatureScatter(hfd.combined.sct, “Gja1”, “Mfn2”, span = 2, smooth = F, jitter = T ) + NoLegend() plCorrGja1Npy1r | plCorrGja1Npy2r | plCorrGja1Gfap | plCorrGja1Mfn2 # # # plEmbCombBatch &lt;- DimPlot(hfd.combined.sct, reduction = “umap”, group.by = “orig.ident”, pt.size = 2, label = TRUE, repel = TRUE, shuffle = TRUE ) + NoLegend() plEmbCombBatch | p2 # # # # # Idents(hfd.combined.sct) &lt;- “k_tree” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “1”)) &lt;- “Astrocytes1” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “2”)) &lt;- “Astrocytes2” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “5”)) &lt;- “Astrocytes3” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “6”)) &lt;- “Astrocytes4” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “9”)) &lt;- “Astrocytes5” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “14”)) &lt;- “Astrocytes6” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “12”)) &lt;- “Astrocytes7” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “3”)) &lt;- “Astrocytes8” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “7”)) &lt;- “Astrocytes9” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “15”)) &lt;- “Astrocytes10” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “11”)) &lt;- “Tanycytes_Ependyma1” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “13”)) &lt;- “Tanycytes_Ependyma2” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “4”)) &lt;- “OPC1” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “10”)) &lt;- “OPC2” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “8”)) &lt;- “OPC3” Idents(hfd.combined.sct, cells = WhichCells(hfd.combined.sct, idents = “16”)) &lt;- “OPC4” hfd.combined.sct$level2 &lt;- Idents(hfd.combined.sct) hfd.combined.sct &lt;- subset( hfd.combined.sct, idents = str_c(“Astrocytes”, 1:10) ) DefaultAssay(hfd.combined.sct) &lt;- “RNA” hfd.combined.sct &lt;- DietSeurat(hfd.combined.sct, assays = “RNA”)</p>
</section>
<section id="normalize-and-run-dimensionality-reduction-on-control-dataset-3" class="level1">
<h1>normalize and run dimensionality reduction on control dataset</h1>
<p>metadata &lt;- hfd.combined.sct@meta.data %&gt;% select(orig.ident, nCount_RNA, nFeature_RNA, age, sex, study_id, tech, hfd, subsets_mito_detected, subsets_mito_percent, prob_compromised, level1, level2) rownames(metadata) &lt;- colnames(hfd.combined.sct) hfd.combined.sct@meta.data &lt;- metadata hfd.list &lt;- SplitObject(hfd.combined.sct, split.by = “orig.ident” ) hfd.list &lt;- lapply( X = hfd.list, vst.flavor = “v2”, FUN = SCTransform, vars.to.regress = “subsets_mito_percent”, variable.features.n = 3500, return.only.var.genes = FALSE, seed.use = reseed, verbose = FALSE )</p>
<p>features &lt;- SelectIntegrationFeatures( object.list = hfd.list, nfeatures = 2000, verbose = FALSE ) all_sct_features &lt;- hfd.list |&gt; map(pluck, “assays”, “SCT”, “var.features”) |&gt; purrr::reduce(c) |&gt; unique() hfd.list &lt;- PrepSCTIntegration(object.list = hfd.list, anchor.features = features)</p>
<p>npcs &lt;- 15 hfd.anchors &lt;- FindIntegrationAnchors( object.list = hfd.list, normalization.method = “SCT”, anchor.features = features, reduction = “cca”, dims = 1:npcs, k.anchor = 10, k.score = 25, k.filter = 100, max.features = 200, n.trees = 100, verbose = FALSE ) head(hfd.anchors@anchor.features, n = 1000)</p>
<p>hfd.combined.sct &lt;- IntegrateData( anchorset = hfd.anchors, normalization.method = “SCT”, features.to.integrate = features, dims = 1:npcs, k.weight = 25, verbose = FALSE ) npcs &lt;- 30 hfd.combined.sct &lt;- hfd.combined.sct |&gt; RunPCA(seed.use = reseed, verbose = FALSE)</p>
</section>
<section id="section-94" class="level1">
<h1></h1>
</section>
<section id="section-95" class="level1">
<h1></h1>
</section>
<section id="section-96" class="level1">
<h1></h1>
<p>print(hfd.combined.sct[[“pca”]], dims = 1:5, nfeatures = 5) # # # VizDimLoadings(hfd.combined.sct, dims = 1:20, reduction = “pca”) # # # DimHeatmap(hfd.combined.sct, dims = 1:15, cells = 500, balanced = TRUE) # # # ElbowPlot(hfd.combined.sct, ndims = npcs) # # # hfd.combined.sct &lt;- hfd.combined.sct |&gt; FindNeighbors( dims = 1:npcs, k.param = 15, annoy.metric = “euclidean”, n.trees = 100, verbose = FALSE ) |&gt; RunUMAP( dims = 1:npcs, reduction.name = “umap”, reduction.key = “UMAP_”, return.model = TRUE, umap.method = “umap-learn”, densmap = TRUE, dens.lambda = 1L, dens.frac = 0.3, n.epochs = 1000L, n.neighbors = 15L, min.dist = 0.01, spread = 2L, metric = “correlation”, init = “pca”, seed.use = reseed, verbose = FALSE ) |&gt; FindNeighbors( reduction = “umap”, dims = 1:2, force.recalc = TRUE, k.param = 15, annoy.metric = “euclidean”, n.trees = 100, verbose = FALSE ) metadata &lt;- hfd.combined.sct@meta.data rownames(metadata) &lt;- colnames(hfd.combined.sct) ref.labels &lt;- metadata$level2</p>
<p>resolutions &lt;- modularity_event_sampling( A = hfd.combined.sct@graphs$integrated_snn, n.res = 70, gamma.min = 0.05, gamma.max = 4.000001 ) # sample based on the similarity matrix</p>
</section>
<section id="clustering-using-suerat-5" class="level1">
<h1>clustering using Suerat</h1>
<p>hfd.combined.sct &lt;- hfd.combined.sct |&gt; FindClusters( algorithm = 4, method = “igraph”, resolution = resolutions, random.seed = reseed, verbose = FALSE )</p>
</section>
<section id="initial-cluster-tree-from-seurat-flat-clustering-5" class="level1">
<h1>initial cluster tree from Seurat flat clustering</h1>
<p>plot_clustree( labelmat = hfd.combined.sct@meta.data, prefix = “integrated_snn_res.”, ref.labels = ref.labels, plot.ref = FALSE ) # # # out &lt;- mrtree( hfd.combined.sct, prefix = “integrated_snn_res.”, n.cores = n_cores, consensus = FALSE, augment.path = FALSE ) # if there are few partitions per k, within resolution consensus step can speed up the algorithm # weight per sample is encoraged if the classes are imbalanced</p>
<p>plot_tree( labelmat = out<span class="math inline">\(labelmat.mrtree,  ref.labels = ref.labels,  plot.piechart = TRUE,  node.size = 0.2,  tip.label.dist = 10,  bottom.margin = 30 ) # # # # Adjusted Multiresolution Rand Index (AMRI) ks.flat &lt;- apply(  out\)</span>labelmat.flat, 2, FUN = function(x) { length(unique(x)) } ) ks.mrtree &lt;- apply( out<span class="math inline">\(labelmat.mrtree,  2,  FUN = function(x) {  length(unique(x))  } ) amri.flat &lt;- sapply(1:ncol(out\)</span>labelmat.flat), function(i) { AMRI(out<span class="math inline">\(labelmat.flat[, i], ref.labels)\)</span>amri }) amri.flat &lt;- aggregate(amri.flat, by = list(k = ks.flat), FUN = mean) amri.recon &lt;- sapply(1:ncol(out<span class="math inline">\(labelmat.mrtree), function(i) {  AMRI(out\)</span>labelmat.mrtree[, i], ref.labels)$amri })</p>
<p>df &lt;- rbind( data.frame( k = amri.flat<span class="math inline">\(k,  amri = amri.flat\)</span>x, method = “Seurat flat” ), data.frame(k = ks.mrtree, amri = amri.recon, method = “MRtree”) ) ggplot2::ggplot(data = df, aes(x = k, y = amri, color = method)) + geom_line() + theme_bw() # # # stab.out &lt;- stability_plot(out) stab.out<span class="math inline">\(plot # # # kable_material(  kable(  stab.out\)</span>df, “html” ), bootstrap_options = “striped”, position = “left”, font_size = 14 )</p>
<p>resK &lt;- SelectResolution(stab.out$df) resK</p>
<p>kable_material( kable( table( out<span class="math inline">\(labelmat.mrtree[, which.min(  abs(as.integer(  str_remove(dimnames(  out\)</span>labelmat.mrtree )[[2]], “K”) ) - resK) )] ), “html” ), bootstrap_options = “striped”, position = “left”, font_size = 14 ) # # # hfd.combined.sct<span class="math inline">\(k_tree &lt;- out\)</span>labelmat.mrtree[, which.min( abs(as.integer( str_remove(dimnames( out$labelmat.mrtree )[[2]], “K”) ) - resK) )] p1 &lt;- DimPlot(hfd.combined.sct, label = T, repel = T) + ggtitle(“Unsupervised clustering”) + NoLegend() p2 &lt;- DimPlot(hfd.combined.sct, label = T, repel = T, group.by = “k_tree”) + ggtitle(“MRTree”) + NoLegend() p3 &lt;- DimPlot(hfd.combined.sct, label = T, repel = T, group.by = “level2”) + ggtitle(“Second iteration”) + NoLegend()</p>
<p>p1 | p2 | p3 # # # Idents(hfd.combined.sct) &lt;- “k_tree” hfd.combined.sct &lt;- PrepSCTFindMarkers(hfd.combined.sct, assay = “SCT”)</p>
<p>hfd.markers.roc &lt;- FindAllMarkers( hfd.combined.sct, assay = “SCT”, verbose = FALSE, random.seed = reseed, only.pos = FALSE, min.pct = 0.05, base = 10, logfc.threshold = 0.05, densify = TRUE, test.use = “roc” ) write_csv( hfd.markers.roc, here( tables_dir, “deng2021-hfd-all-mrk_roc-sct-iter3.csv” ) )</p>
<p>hfd.markers.roc %&gt;% group_by(cluster) %&gt;% slice_max(n = 3, order_by = avg_log10FC) %&gt;% kable(“html”) %&gt;% kable_material( bootstrap_options = “striped”, position = “left”, font_size = 14 )</p>
<p>hfd.markers.wilcox &lt;- FindAllMarkers( hfd.combined.sct, assay = “SCT”, verbose = FALSE, random.seed = reseed, only.pos = FALSE, min.pct = 0.05, base = 10, logfc.threshold = 0.05, densify = TRUE, test.use = “wilcox” ) write_csv( hfd.markers.wilcox, here( tables_dir, “deng2021-hfd-all-mrk_wilcox-sct-iter3.csv” ) ) hfd.markers.wilcox %&gt;% group_by(cluster) %&gt;% slice_max(n = 3, order_by = avg_log10FC) %&gt;% kable(“html”) %&gt;% kable_material( bootstrap_options = “striped”, position = “left”, font_size = 14 ) # # # hfd.markers.roc %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log10FC) -&gt; top10 hfd.markers.wilcox %&gt;% group_by(cluster) %&gt;% filter(p_val_adj &lt; 0.05, avg_log10FC &gt; 0.05) %&gt;% top_n(n = 15, wt = avg_log10FC) -&gt; top15 DoHeatmap(hfd.combined.sct, features = top15<span class="math inline">\(gene) + NoLegend() # # # DefaultAssay(object = hfd.combined.sct) &lt;- "integrated" FeaturePlot(  hfd.combined.sct,  features = top10\)</span>gene, min.cutoff = “q05”, max.cutoff = “q95”, ncol = 5, order = TRUE ) + patchwork::plot_annotation( title = “Astro-Marker ROC-test (Arc Deng 2021)”, theme = theme(plot.title = element_text(size = 22)) ) # # # DefaultAssay(object = hfd.combined.sct) &lt;- “RNA” FeaturePlot( hfd.combined.sct, slot = “data”, features = top10<span class="math inline">\(gene,  min.cutoff = "q05", max.cutoff = "q95",  ncol = 5, order = TRUE ) +  patchwork::plot_annotation(  title = "Astro-Marker ROC-test RNA (Arc Deng 2021)",  theme = theme(plot.title = element_text(size = 22))  ) # # # FeaturePlot(  hfd.combined.sct,  features = c(  "Slc1a3", "Glul", "Gja1", "Ndrg2", "Ntrk2",  "S100b", "Tafa1", "Aldh1a1", "Aldh1l1",  "Plcb1", "Slit2", "Apoe", "Gfap", "Ntsr2",  "Slc38a1", "Cst3", "Nfia", "Mfn2", "Lxn",  "Npy1r", "Npy2r", "Esr1", "Prlr", "Otp"  ),  min.cutoff = "q05", max.cutoff = "q95",  ncol = 4, order = TRUE, slot = "data" ) +  patchwork::plot_annotation(  title = "Astro-Marker order RNA (Arc Deng 2021)",  theme = theme(plot.title = element_text(size = 22))  ) # # # DoHeatmap(hfd.combined.sct, features = top15\)</span>gene, slot = “data”) + NoLegend() # # # glimpse(hfd.combined.sct@meta.data) table(hfd.combined.sct<span class="math inline">\(level1) table(hfd.combined.sct\)</span>level2) table(Idents(hfd.combined.sct)) SaveH5Seurat( hfd.combined.sct, filename = here( data_dir, “deng_2020_arc_hfd_astrocytes_sct.h5Seurat” ), overwrite = TRUE ) Convert( here( data_dir, “deng_2020_arc_hfd_astrocytes_sct.h5Seurat” ), dest = “h5ad”, overwrite = TRUE ) # # # # # # # FeaturePlot(chow.combined.sct, features = genes.embed[genes.embed %in% rownames(chow.combined.sct@assays<span class="math inline">\(SCT@scale.data)],  min.cutoff = "q9", ncol = 3 ) DimPlot(chow.combined.sct, label = T) # # # FeaturePlot(chow.combined.sct,  features = c("Agrp", "Npy", "Pomc", "Agt"),  min.cutoff = "q9", ncol = 3 ) # # # VariableFeatures(chow.combined.sct) &lt;- rownames(chow.combined.sct@assays\)</span>SCT@scale.data) swne.chow.embedding &lt;- RunSWNE(chow.combined.sct, k = 20, genes.embed = genes.embed[genes.embed %in% rownames(chow.combined.sct@assays$SCT@data)], snn.exp = 0.25, snn.k = 20)</p>
<p>PlotSWNE(swne.chow.embedding, alpha.plot = 0.4, sample.groups = Idents(chow.combined.sct), do.label = T, label.size = 3.5, pt.size = 1.25, show.legend = F, seed = 42 ) gc() # # # astro.chow.sct &lt;- subset(chow.combined.sct, idents = c(3)) gc() # # # # # FeaturePlot(hfd.combined.sct, features = genes.embed[ genes.embed %in% rownames(hfd.combined.sct@assays<span class="math inline">\(SCT@scale.data)  ],  min.cutoff = "q9", ncol = 3 ) DimPlot(hfd.combined.sct, label = T) # # # VariableFeatures(hfd.combined.sct) &lt;- rownames(hfd.combined.sct@assays\)</span>SCT@scale.data) swne.hfd.embedding &lt;- RunSWNE(hfd.combined.sct, k = 20, genes.embed = genes.embed[genes.embed %in% rownames(hfd.combined.sct@assays$SCT@data)], snn.exp = 0.25, snn.k = 20)</p>
<p>PlotSWNE(swne.hfd.embedding, alpha.plot = 0.4, sample.groups = Idents(hfd.combined.sct), do.label = T, label.size = 3.5, pt.size = 1.25, show.legend = F, seed = 42 ) gc() # # # astro.hfd.sct &lt;- subset(hfd.combined.sct, idents = c(3)) gc() # # # # # glimpse(chow.combined.sct@meta.data) table(chow.combined.sct$seurat_clusters) SaveH5Seurat(chow.combined.sct, filename = here( data_dir, “deng_2020_arc_chow_clusters.h5Seurat” ) ) Convert( here( data_dir, “deng_2020_arc_chow_clusters.h5Seurat” ), dest = “h5ad” )</p>
<p>SaveH5Seurat(astro.chow.sct, filename = here( data_dir, “deng_2020_arc_chow_astrocytes.h5Seurat” ) ) Convert( here( data_dir, “deng_2020_arc_chow_astrocytes.h5Seurat” ), dest = “h5ad” ) # # # glimpse(hfd.combined.sct@meta.data) table(hfd.combined.sct$seurat_clusters) SaveH5Seurat(hfd.combined.sct, filename = here( data_dir, “deng_2020_arc_hfd_clusters.h5Seurat” ) ) Convert( here( data_dir, “deng_2020_arc_hfd_clusters.h5Seurat” ), dest = “h5ad” )</p>
<p>SaveH5Seurat(astro.hfd.sct, filename = here( data_dir, “deng_2020_arc_hfd_astrocytes.h5Seurat” ) ) Convert( here( data_dir, “deng_2020_arc_hfd_astrocytes.h5Seurat” ), dest = “h5ad” ) # # # # # DefaultAssay(astro.chow.sct) &lt;- “SCT” DefaultAssay(astro.hfd.sct) &lt;- “SCT” # a.list &lt;- list(chow = DietSeurat(astro.chow.sct, # assays = c(“RNA”, “SCT”)), # hfd = DietSeurat(astro.hfd.sct, # assays = c(“RNA”, “SCT”))) a1.list &lt;- SplitObject(astro.chow.sct, split.by = “orig.ident” ) a2.list &lt;- SplitObject(astro.hfd.sct, split.by = “orig.ident” ) a.list &lt;- c(unlist(a1.list), unlist(a2.list)) a.list &lt;- lapply(X = a.list, FUN = function(x) { SCTransform(x, vst.flavor = “v2”, verbose = FALSE) |&gt; RunPCA(npcs = 30, verbose = FALSE) })</p>
<p>features &lt;- SelectIntegrationFeatures(object.list = a.list, nfeatures = 3000) a.list &lt;- PrepSCTIntegration(object.list = a.list, anchor.features = features)</p>
<p>a.anchors &lt;- FindIntegrationAnchors( object.list = a.list, normalization.method = “SCT”, anchor.features = features ) a.combined.sct &lt;- IntegrateData(anchorset = a.anchors, normalization.method = “SCT”)</p>
<p>a.combined.sct &lt;- RunPCA(a.combined.sct, verbose = FALSE) a.combined.sct &lt;- RunUMAP(a.combined.sct, reduction = “pca”, dims = 1:30, verbose = FALSE) a.combined.sct &lt;- FindNeighbors(a.combined.sct, reduction = “pca”, dims = 1:30) a.combined.sct &lt;- FindClusters(a.combined.sct, resolution = 0.5) a.combined.sct$reclust_comb &lt;- Idents(a.combined.sct)</p>
<p>(DimPlot(a.combined.sct, reduction = “umap”, split.by = “hfd”)) / (DimPlot(a.combined.sct, reduction = “umap”, group.by = “orig.ident”, split.by = “hfd”)) # # # a.combined.sct &lt;- PrepSCTFindMarkers(a.combined.sct) a.inmark &lt;- FindAllMarkers(a.combined.sct, assay = “SCT”, verbose = F) a.inmark %&gt;% group_by(cluster) %&gt;% slice_max(n = 2, order_by = avg_log2FC)</p>
<p>a.combined.sct<span class="math inline">\(clust.hfd &lt;- paste(a.combined.sct\)</span>reclust_comb, as.numeric(a.combined.sct$hfd), sep = “_” ) Idents(a.combined.sct) &lt;- “clust.hfd” a.splmark &lt;- FindAllMarkers(a.combined.sct, assay = “SCT”, verbose = F) a.splmark %&gt;% group_by(cluster) %&gt;% slice_max(n = 2, order_by = avg_log2FC)</p>
<p>DefaultAssay(a.combined.sct) &lt;- “SCT” a.splmark %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log2FC) -&gt; top10 DoHeatmap(a.combined.sct, features = top10<span class="math inline">\(gene) + NoLegend() FeaturePlot(a.combined.sct,  features = genes.embed[  genes.embed %in% rownames(a.combined.sct@assays\)</span>SCT@scale.data) ], min.cutoff = “q9”, ncol = 3, order = T )</p>
</section>
<section id="refine-subset-of-astrocytes" class="level1">
<h1>refine subset of astrocytes</h1>
<p>astro.sct &lt;- subset(a.combined.sct, idents = c(“0_1”, “0_0”, “3_0”, “3_1”)) SaveH5Seurat(astro.sct, filename = here( data_dir, “deng_2020_arc_refi_astrocytes.h5Seurat” ) ) Convert( here( data_dir, “deng_2020_arc_refi_astrocytes.h5Seurat” ), dest = “h5ad” )</p>
</section>
<section id="section-97" class="level1">
<h1></h1>
</section>
<section id="section-98" class="level1">
<h1></h1>
</section>
<section id="section-99" class="level1">
<h1></h1>
<p>DefaultAssay(astro.sct) &lt;- “RNA” ast &lt;- DietSeurat(astro.sct, assays = “RNA”) ast &lt;- SCTransform(ast, vst.flavor = “v2”, verbose = FALSE) %&gt;% RunPCA(npcs = 30, verbose = FALSE) %&gt;% RunUMAP(reduction = “pca”, dims = 1:30, densmap = TRUE, verbose = FALSE) %&gt;% FindNeighbors(reduction = “pca”, dims = 1:30, verbose = FALSE) %&gt;% FindClusters(resolution = 0.7, verbose = FALSE)</p>
<p>(DimPlot(ast, reduction = “umap”, split.by = “hfd”)) / (DimPlot(ast, reduction = “umap”, group.by = “orig.ident”, split.by = “hfd”))</p>
<p>Idents(ast) &lt;- “clust.hfd” (DimPlot(ast, reduction = “umap”, split.by = “hfd”)) / (DimPlot(ast, reduction = “umap”, group.by = “orig.ident”, split.by = “hfd”))</p>
<p>DefaultAssay(ast) &lt;- “SCT” ast &lt;- PrepSCTFindMarkers(ast) ast.inmark &lt;- FindAllMarkers(ast, assay = “SCT”, verbose = F) ast.inmark %&gt;% group_by(cluster) %&gt;% slice_max(n = 2, order_by = avg_log2FC) write_csv(x = ast.inmark, file = here(tables_dir, “arc_ast.csv”))</p>
<p>ast.inmark %&gt;% group_by(cluster) %&gt;% top_n(n = 20, wt = avg_log2FC) -&gt; top20 DoHeatmap(ast, features = top20$gene) + NoLegend() # # # DefaultAssay(chow.combined.sct) &lt;- “RNA” astro.chow &lt;- subset(chow.combined.sct, subset = Slc1a3 &gt; 1 &amp; Gfap &gt; 1 &amp; Ndrg2 &gt; 1) DefaultAssay(chow.combined.sct) &lt;- “RNA” DefaultAssay(astro.chow) &lt;- “SCT”</p>
<p>SaveH5Seurat(astro.chow, filename = here( data_dir, “deng_2020_arc_chow_astrocytes_fin.h5Seurat” ) ) Convert( here( data_dir, “deng_2020_arc_chow_astrocytes_fin.h5Seurat” ), dest = “h5ad” ) # # # DefaultAssay(hfd.combined.sct) &lt;- “RNA” astro.hfd &lt;- subset(hfd.combined.sct, subset = Slc1a3 &gt; 1 &amp; Gfap &gt; 1 &amp; Ndrg2 &gt; 1) DefaultAssay(hfd.combined.sct) &lt;- “SCT” DefaultAssay(astro.hfd) &lt;- “SCT” astro.hfd &lt;- subset(astro.hfd, subset = Slc1a3 &gt; 1 &amp; Slc6a11 &gt; 1 &amp; Ndrg2 &gt; 1)</p>
<p>SaveH5Seurat(astro.hfd, filename = here( data_dir, “deng_2020_arc_hfd_astrocytes_fin.h5Seurat” ), overwrite = T ) Convert( here( data_dir, “deng_2020_arc_hfd_astrocytes_fin.h5Seurat” ), dest = “h5ad”, overwrite = T ) # # # FeaturePlot(astro.hfd, features = genes.embed[ genes.embed %in% rownames(astro.hfd@assays$SCT@scale.data) ], min.cutoff = “q9”, ncol = 3 ) DimPlot(astro.hfd, label = T) # # # DefaultAssay(astro.chow) &lt;- “SCT” DefaultAssay(astro.hfd) &lt;- “SCT”</p>
<p>a.combined.sct &lt;- merge(astro.chow, astro.hfd)</p>
<p>a.combined.sct &lt;- SCTransform(a.combined.sct, vst.flavor = “v2”, verbose = FALSE ) %&gt;% RunPCA(npcs = 30, verbose = FALSE) %&gt;% RunUMAP(reduction = “pca”, dims = 1:30, densmap = TRUE, verbose = FALSE) %&gt;% FindNeighbors(reduction = “pca”, dims = 1:30, verbose = FALSE) %&gt;% FindClusters(resolution = 0.3, verbose = FALSE)</p>
<p>(DimPlot(a.combined.sct, reduction = “umap”, split.by = “hfd”)) / (DimPlot(a.combined.sct, reduction = “umap”, group.by = “orig.ident”, split.by = “hfd”)) # # # a.combined.sct &lt;- PrepSCTFindMarkers(a.combined.sct) DefaultAssay(a.combined.sct) &lt;- “SCT” a.inmark &lt;- FindAllMarkers(a.combined.sct, assay = “SCT”, verbose = F) a.inmark %&gt;% group_by(cluster) %&gt;% slice_max(n = 2, order_by = avg_log2FC) a.inmark %&gt;% group_by(cluster) %&gt;% top_n(n = 20, wt = avg_log2FC) -&gt; top20 DoHeatmap(a.combined.sct, features = top20$gene) + NoLegend()</p>
<p>a.combined.sct<span class="math inline">\(clust.hfd &lt;- paste(a.combined.sct\)</span>seurat_clusters, as.numeric(a.combined.sct$hfd), sep = “_” ) Idents(a.combined.sct) &lt;- “clust.hfd” a.splmark &lt;- FindAllMarkers(a.combined.sct, test.use = “roc”, assay = “SCT”, verbose = T) a.splmark %&gt;% group_by(cluster) %&gt;% slice_max(n = 2, order_by = power)</p>
<p>a.splmark %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = power) -&gt; top10 DoHeatmap(a.combined.sct, features = top10<span class="math inline">\(gene, slot = "data") + NoLegend() FeaturePlot(a.combined.sct,  features = genes.embed[  genes.embed %in% rownames(a.combined.sct@assays\)</span>SCT@scale.data) ], min.cutoff = “q75”, ncol = 3, order = T )</p>
<p>VlnPlot(a.combined.sct, features = genes.embed[ genes.embed %in% rownames(a.combined.sct@assays$SCT@scale.data) ] )</p>
</section>
<section id="section-100" class="level1">
<h1></h1>
</section>
<section id="section-101" class="level1">
<h1></h1>
</section>
<section id="section-102" class="level1">
<h1></h1>
</section>
<section id="section-103" class="level1">
<h1></h1>
</section>
<section id="section-104" class="level1">
<h1></h1>
<p>VariableFeatures(a.combined.sct) &lt;- rownames(a.combined.sct@assays<span class="math inline">\(SCT@scale.data) swne.a.embedding &lt;- RunSWNE(a.combined.sct, k = 20, genes.embed = genes.embed[genes.embed %in% rownames(a.combined.sct@assays\)</span>SCT@data)], snn.exp = 0.25, snn.k = 20)</p>
<p>PlotSWNE(swne.a.embedding, alpha.plot = 0.4, sample.groups = Idents(a.combined.sct), do.label = T, label.size = 3.5, pt.size = 1.25, show.legend = F, seed = 42 ) # # # norm.counts &lt;- GetAssayData(a.combined.sct, assay = “SCT”, slot = “data”) gene.use &lt;- “Lxn” gene.expr &lt;- norm.counts[gene.use, ] FeaturePlotSWNE(swne.a.embedding, gene.expr, gene.use, alpha.plot = 0.4, label.size = 3.5, pt.size = 1.25) # # # gene.use &lt;- “Mfn2” gene.expr &lt;- norm.counts[gene.use, ] FeaturePlotSWNE(swne.a.embedding, gene.expr, gene.use, alpha.plot = 0.4, label.size = 3.5, pt.size = 1.25) # # # #</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>