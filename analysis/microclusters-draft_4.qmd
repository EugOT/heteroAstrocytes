---
title: Subregional heterogeneity of hypothalamic astrocytes revealed by single-cell RNA sequencing datas semi-supervised machine learning (microclusters_to_groups_cv_feature_selection_svc.ipynb)
author: Evgenii O. Tretiakov
format:
  html:
    toc: true
    df-print: paged
    code-fold: true
    dpi: 600
    fig-format: pdf
    fig-width: 14
    fig-height: 12
    fig-dpi: 600
  pdf:
    documentclass: scrartcl
    papersize: letter
    dpi: 600
    fig-format: pdf
    fig-width: 14
    fig-height: 12
    fig-dpi: 600
jupyter: python3
---

```{python}
import os
import random
import warnings
import time
import copy
import heapq
import joblib
import numpy as np
import pandas as pd
import igraph as ig
import matplotlib.pyplot as plt
import matplotlib
import scipy

from natsort import natsorted
from collections import Counter
from sklearn.feature_selection import (
    chi2,
    f_classif,
    mutual_info_classif,
    RFECV,
    SelectFromModel,
    SelectKBest,
)
from sklearn.metrics import (
    f1_score,
    make_scorer,
    matthews_corrcoef
)
from sklearn.model_selection import (
    GridSearchCV,
    RepeatedStratifiedKFold,
    StratifiedGroupKFold,
)
from sklearn.preprocessing import MinMaxScaler, RobustScaler
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.utils import check_random_state
from pacmap import PaCMAP
from umap import UMAP
from umap.umap_ import (
    find_ab_params,
    nearest_neighbors,
    fuzzy_simplicial_set,
    simplicial_set_embedding,
    dist,
)
from leidenalg import CPMVertexPartition, Optimiser
from networkx import from_scipy_sparse_array

import scanpy as sc
from scanpy.experimental.pp import highly_variable_genes
from anndata import concat
```

```{python}
#################
##### genes #####
#################

npr = [
    "Adcyap1r1",
    "Avpr1a",
    "Calcr",
    "Calcrl",
    "Cckar",
    "Cckbr",
    "Cntfr",
    "Crhr1",
    "Crhr2",
    "Esr1",
    "Galr1",
    "Galr2",
    "Galr3",
    "Ghr",
    "Ghrhr",
    "Ghsr",
    "Glp1r",
    "Gpr55",
    "Gpr83",
    "Gpr149",
    "Grpr",
    "Hcrtr1",
    "Hcrtr2",
    "Igf1r",
    "Insr",
    "Insrr",
    "Kiss1r",
    "Lepr",
    "Mc1r",
    "Mc3r",
    "Mc4r",
    "Mchr1",
    "Nmbr",
    "Nmur1",
    "Nmur2",
    "Npffr1",
    "Npffr2",
    "Npr1",
    "Npr2",
    "Npr3",
    "Npsr1",
    "Npsr2",
    "Npy1r",
    "Npy2r",
    "Npy5r",
    "Ntrk2",
    "Ntsr1",
    "Ntsr2",
    "Oprd1",
    "Oprk1",
    "Oprl1",
    "Oprm1",
    "Oxtr",
    "Prlhr",
    "Prlr",
    "Prokr2",
    "Qrfpr",
    "Rxfp1",
    "Rxfp2",
    "Sstr1",
    "Sstr2",
    "Sstr3",
    "Tacr1",
    "Tacr3",
    "Trhr",
    "Trhr2",
    "Tshr",
    "Vipr1",
    "Vipr2",
]

npep = [
    "Adcyap1",
    "Agrp",
    "Avp",
    "Bdnf",
    "Cartpt",
    "Cck",
    "Cntf",
    "Crh",
    "Gal",
    "Ghrh",
    "Ghrl",
    "Grp",
    "Hcrt",
    "Kiss1",
    "Lep",
    "Nmb",
    "Nms",
    "Nmu",
    "Npvf",
    "Npw",
    "Npy",
    "Nts",
    "Oxt",
    "Pdyn",
    "Penk",
    "Pmch",
    "Pnoc",
    "Pomc",
    "Qrfp",
    "Reln",
    "Rln1",
    "Rln3",
    "Sst",
    "Tac1",
    "Tac2",
    "Trh",
]

genes_embed = [
    "Abca1",
    "Abcd1",
    "Abcd2",
    "Abcd3",
    "Acaa1",
    "Acaa2",
    "Acox1",
    "Agrn",
    "Agt",
    "Alcam",
    "Aldh1a1",
    "Aldh1l1",
    "Aldoc",
    "Alk",
    "Angpt1",
    "Apoe",
    "App",
    "Aqp4",
    "Arf1",
    "Bmp7",
    "Bsg",
    "Caf4",
    "Ccl25",
    "Ckb",
    "Cnr1",
    "Cnr2",
    "Col4a5",
    "Cst3",
    "Dagla",
    "Daglb",
    "Dcc",
    "Decr2",
    "Dnm1",
    "Drp1",
    "Ech1",
    "Efna5",
    "Egfr",
    "Enho",
    "Eno1",
    "Faah",
    "Fgf1",
    "Fgfr3",
    "Fis1",
    "Fos",
    "Fth1",
    "Ftl1",
    "Gfap",
    "Gja1",
    "Gli1",
    "Glul",
    "Gnai2",
    "Gnas",
    "H2-K1",
    "Hacd2",
    "Hadhb",
    "Hbegf",
    "Hepacam",
    "Hif1",
    "Htra1",
    "Igsf1",
    "Il18",
    "Il1rapl1",
    "Itgav",
    "Jam2",
    "Lama2",
    "Lamb2",
    "Lcat",
    "Lgi1",
    "Lgi4",
    "Lpcat3",
    "Lrp1",
    "Lrpap1",
    "Lrrc4b",
    "Lxn",
    "Mdk",
    "Mdv1",
    "Mfn1",
    "Mfn2",
    "Mgll",
    "Mief1",
    "Napepld",
    "Ncam1",
    "Ncan",
    "Ndrg2",
    "Nfasc",
    "Nfia",
    "Nlgn1",
    "Nlgn3",
    "Nrxn1",
    "Nrxn2",
    "Ntn1",
    "Ntn2",
    "Ntn3",
    "Ntn4",
    "Ntrk3",
    "Opa1",
    "Otp",
    "Pex1",
    "Pex10",
    "Pex12",
    "Pex13",
    "Pex14",
    "Pex16",
    "Pex2",
    "Pex26",
    "Pex3",
    "Pex6",
    "Pkm",
    "Pla2g7",
    "Plcb1",
    "Psap",
    "Ptprz1",
    "Ptn",
    "Pygb",
    "Rgma",
    "Rtn4",
    "S100a1",
    "S100a6",
    "S100b",
    "Scd2",
    "Sdc2",
    "Sema6a",
    "Sema6d",
    "Sgcd",
    "Sirpa",
    "Slc1a2",
    "Slc1a3",
    "Slc4a4",
    "Slc6a11",
    "Slc7a10",
    "Slc38a1",
    "Slit1",
    "Slit2",
    "Slitrk2",
    "Sorbs1",
    "Sox9",
    "Sparc",
    "Spon1",
    "Tafa1",
    "Timp3",
    "Tkt",
    "Trpv1",
    "Vcam1",
    "Vegfa",
]

nmr = [
    "Adra1a",
    "Adra1b",
    "Adra1d",
    "Adra2a",
    "Adra2b",
    "Adra2c",
    "Adrb1",
    "Adrb2",
    "Adrb3",
    "Adrbk1",
    "Adrbk2",
    "Adrm1",  # adrenergic receptors
    "Adora1",
    "Adora2a",
    "Adora2b",
    "Adora3", # adenosine receptors
    "Chrm1",
    "Chrm2",
    "Chrm3",
    "Chrm4",
    "Chrm5",
    "Chrna1",
    "Chrna2",
    "Chrna3",
    "Chrna4",
    "Chrna5",
    "Chrna6",
    "Chrna7",
    "Chrna9",
    "Chrna10",
    "Chrnb1",
    "Chrnb2",
    "Chrnb3",
    "Chrnd",
    "Chrng", # cholinergic receptors
    "Gria1",
    "Gria2",
    "Gria3",
    "Gria4",  # iGlu AMPA receptors
    "Grid1",
    "Grid2",  # iGlu delta receptors
    "Grik1",
    "Grik2",
    "Grik3",
    "Grik4",
    "Grik5",  # iGlu kainate receptors
    "Grin1",
    "Grin2a",
    "Grin2b",
    "Grin2c",
    "Grin2d",
    "Grin3a",
    "Grin3b",  # iGlu NMDA receptors
    "Grm1",
    "Grm5",  # mGluRs 1
    "Grm2",
    "Grm3",  # mGluRs 2
    "Grm4",
    "Grm6",
    "Grm7",
    "Grm8",  # mGluRs 3
    "Gabra1",
    "Gabra2",
    "Gabra3",
    "Gabra4",
    "Gabra5",
    "Gabra6",
    "Gabrb1",
    "Gabrb2",
    "Gabrb3",
    "Gabrg1",
    "Gabrg2",
    "Gabrg3",
    "Gabrd",
    "Gabre",
    "Gabrp",
    "Gabrq",
    "Gabrr1",
    "Gabrr2",
    "Gabrr3",
    "Gabbr1",
    "Gabbr2", # GABA receptors
    "Drd1",
    "Drd2",
    "Drd3",
    "Drd4",
    "Drd5", # dopamine receptors
    "Htr1a",
    "Htr1b",
    "Htr1d",
    "Htr1f",
    "Htr2a",
    "Htr2b",
    "Htr2c",
    "Htr3a",
    "Htr3b",
    "Htr4",
    "Htr5a",
    "Htr5b",
    "Htr6",
    "Htr7", # serotonin receptors
    "Gnas",
    "Gnai1",
    "Gnai2",
    "Gnai3",
    "Gnao1",
    "Gnao2",
    "Gnaq",
    "Gna11",
    "Gna12",
    "Gna13",
    "Gnal",
    "Gnasxl", # G protein alpha subunit
    "Gnb1",
    "Gnb2",
    "Gnb3",
    "Gnb4",
    "Gnb5", # G protein beta subunit
    "Gng2",
    "Gng3",
    "Gng4",
    "Gng5",
    "Gng7",
    "Gng8",
    "Gng10",
    "Gng11",
    "Gng12",
    "Gng13",
    "Gngt1",
    "Gngt2", # G protein gamma subunit
    "P2rx1",
    "P2rx2",
    "P2rx3",
    "P2rx4",
    "P2rx5",
    "P2rx6",
    "P2rx7",
    "P2ry1",
    "P2ry2",
    "P2ry4",
    "P2ry6",
    "P2ry12",
    "P2ry13",
    "P2ry14", # purinergic receptors
    "Ryr1",
    "Ryr2",
    "Ryr3", # ryanodine receptors
]
```

### functions

```{python}
#####################
##### functions #####
#####################

def my_vcenter(values): return np.mean(values)

def fit_and_score(estimator, X_train, X_test, y_train, y_test):
    """Fit the estimator on the train set and score it on both sets"""
    estimator.fit(X_train, y_train, eval_set=[(X_test, y_test)])

    train_score = estimator.score(X_train, y_train)
    test_score = estimator.score(X_test, y_test)

    return estimator, train_score, test_score


def get_importances(classifiers, features):
    """Compute feature importances for a set of classifiers.

    Args:
        classifiers (dict): Dictionary of classifiers with values of their scores on train and test sets.
        features (list): List of features.
    """

    importances = pd.DataFrame(
        index=features, columns=np.arange(len(classifiers.keys()))
    )
    i = 0
    for clf in classifiers.keys():  # iterate over classifiers
        importance = clf.feature_importances_  # get feature importances
        importances.iloc[:, i] = importance  # store in DataFrame
        i += 1

    importances["mean"] = importances.mean(axis=1)  # get mean
    importances["median"] = importances.median(axis=1)  # get median
    importances["std"] = importances.std(axis=1)  # get std
    importances = importances.sort_values(["median"], ascending=True)

    return importances


def plot_importances(
    importances, median_thresh=0.99, std_thresh=0.1, plot_filtered=True
):
    """Plot the median and std feature importances.

    Args:
        importances (pd.DataFrame): Feature importances.
        median_thresh (float, optional): Threshold for percentile of median importance. Defaults to 0.1.
        std_thresh (float, optional): Threshold for std importance. Defaults to 0.1.
        plot_filtered (bool, optional): Whether to plot only the filtered features. Defaults to False.
    """

    filtered = importances[
        (importances["median"] > importances["median"].quantile(median_thresh))
        & (importances["std"] < std_thresh)
    ]  # filter to most important and stable features

    if plot_filtered:
        plt.figure(figsize=(6.4, 30), dpi=240)
        plt.errorbar(
            x=filtered["median"],
            y=filtered.index,
            xerr=filtered["std"],
            fmt="o",
            c="black",
            capsize=2,
        )
        plt.title("Filtered feature importance using XGBoostClassifier Model")
        plt.show()
    else:
        plt.figure(figsize=(8, 160), dpi=120)
        plt.errorbar(
            x=importances["median"],
            y=importances.index,
            xerr=importances["std"],
            fmt="o",
            c="black",
            capsize=2,
        )
        plt.title("Feature importance using XGBoostClassifier Model")
        plt.show()

    return filtered


def min_spanning_tree(knn_indices, knn_dists, n_neighbors, threshold):
    """Calculate min spanning tree"""
    rows = np.zeros(knn_indices.shape[0] * n_neighbors, dtype=np.int32)
    cols = np.zeros(knn_indices.shape[0] * n_neighbors, dtype=np.int32)
    vals = np.zeros(knn_indices.shape[0] * n_neighbors, dtype=np.float32)

    pos = 0
    for i, indices in enumerate(knn_indices):
        for j, index in enumerate(indices[:threshold]):
            if index == -1:
                continue
            rows[pos] = i
            cols[pos] = index
            vals[pos] = knn_dists[i][j]
            pos += 1

    matrix = scipy.sparse.csr_matrix(
        (vals, (rows, cols)), shape=(knn_indices.shape[0], knn_indices.shape[0])
    )
    Tcsr = scipy.sparse.csgraph.minimum_spanning_tree(matrix)

    Tcsr = scipy.sparse.coo_matrix(Tcsr)
    weights_tuples = zip(Tcsr.row, Tcsr.col, Tcsr.data)

    sorted_weights_tuples = sorted(weights_tuples, key=lambda tup: tup[2])

    return sorted_weights_tuples


def create_connected_graph(
    mutual_nn, total_mutual_nn, knn_indices, knn_dists, n_neighbors, connectivity
):
    connected_mnn = copy.deepcopy(mutual_nn)

    if connectivity == "nearest":
        for i in range(len(knn_indices)):
            if len(mutual_nn[i]) == 0:
                first_nn = knn_indices[i][1]
                if first_nn != -1:
                    connected_mnn[i].add(first_nn)
                    connected_mnn[first_nn].add(i)
                    total_mutual_nn += 1
        return connected_mnn

    # Create graph for mutual NN
    rows = np.zeros(total_mutual_nn, dtype=np.int32)
    cols = np.zeros(total_mutual_nn, dtype=np.int32)
    vals = np.zeros(total_mutual_nn, dtype=np.float32)
    pos = 0
    for i in connected_mnn:
        for j in connected_mnn[i]:
            rows[pos] = i
            cols[pos] = j
            vals[pos] = 1
            pos += 1
    graph = scipy.sparse.csr_matrix(
        (vals, (rows, cols)), shape=(knn_indices.shape[0], knn_indices.shape[0])
    )

    # Find number of connected components
    n_components, labels = scipy.sparse.csgraph.connected_components(
        csgraph=graph, directed=True, return_labels=True, connection="strong"
    )
    print(n_components)
    label_mapping = {i: [] for i in range(n_components)}

    for index, component in enumerate(labels):
        label_mapping[component].append(index)

    # Find the min spanning tree with KNN
    sorted_weights_tuples = min_spanning_tree(
        knn_indices, knn_dists, n_neighbors, n_neighbors
    )

    # Add edges until graph is connected
    for pos, (i, j, v) in enumerate(sorted_weights_tuples):
        if connectivity == "full_tree":
            connected_mnn[i].add(j)
            connected_mnn[j].add(i)

        elif connectivity == "min_tree" and labels[i] != labels[j]:
            if len(label_mapping[labels[i]]) < len(label_mapping[labels[j]]):
                i, j = j, i

            connected_mnn[i].add(j)
            connected_mnn[j].add(i)
            j_pos = label_mapping[labels[j]]
            labels[j_pos] = labels[i]
            label_mapping[labels[i]].extend(j_pos)

    return connected_mnn


def find_new_nn(
    knn_indices,
    knn_dists,
    knn_indices_pos,
    connected_mnn,
    n_neighbors_max,
    verbose=False,
):
    """Search to find path neighbors"""
    new_knn_dists = []
    new_knn_indices = []

    for i in range(len(knn_indices)):
        min_distances = []
        min_indices = []

        heap = [(0, i)]
        mapping = {}

        seen = set()
        heapq.heapify(heap)
        while len(min_distances) < n_neighbors_max and len(heap) > 0:
            dist, nn = heapq.heappop(heap)
            if nn == -1:
                continue

            if nn not in seen:
                min_distances.append(dist)
                min_indices.append(nn)
                seen.add(nn)
                neighbor = connected_mnn[nn]

                for nn_nn in neighbor:
                    if nn_nn not in seen:
                        distance = 0
                        if nn_nn in knn_indices_pos[nn]:
                            pos = knn_indices_pos[nn][nn_nn]
                            distance = knn_dists[nn][pos]
                        else:
                            pos = knn_indices_pos[nn_nn][nn]
                            distance = knn_dists[nn_nn][pos]
                        distance += dist
                        if nn_nn not in mapping:
                            mapping[nn_nn] = distance
                            heapq.heappush(heap, (distance, nn_nn))
                        elif mapping[nn_nn] > distance:
                            mapping[nn_nn] = distance
                            heapq.heappush(heap, (distance, nn_nn))

        if len(min_distances) < n_neighbors_max:
            for i in range(n_neighbors_max - len(min_distances)):
                min_indices.append(-1)
                min_distances.append(np.inf)

        new_knn_dists.append(min_distances)
        new_knn_indices.append(min_indices)

        if verbose and i % int(len(knn_dists) / 10) == 0:
            print("\tcompleted ", i, " / ", len(knn_dists), "epochs")
    return new_knn_dists, new_knn_indices


def mutual_nn_nearest(
    knn_indices,
    knn_dists,
    n_neighbors,
    n_neighbors_max,
    connectivity="min_tree",
    verbose=False,
):
    """Calculate the connected mutual nn graph"""
    mutual_nn = {}
    nearest_n = {}

    knn_indices_pos = [None] * len(knn_indices)

    total = 0

    for i, top_vals in enumerate(knn_indices):
        nearest_n[i] = set(top_vals)
        knn_indices_pos[i] = {}
        for pos, nn in enumerate(top_vals):
            knn_indices_pos[i][nn] = pos

    total_mutual_nn = 0
    for i, top_vals in enumerate(knn_indices):
        mutual_nn[i] = set()
        for ind, nn in enumerate(top_vals):
            if nn != -1 and (i in nearest_n[nn] and i != nn):
                mutual_nn[i].add(nn)
                total_mutual_nn += 1

    connected_mnn = create_connected_graph(
        mutual_nn, total_mutual_nn, knn_indices, knn_dists, n_neighbors, connectivity
    )
    new_knn_dists, new_knn_indices = find_new_nn(
        knn_indices, knn_dists, knn_indices_pos, connected_mnn, n_neighbors_max, verbose
    )

    return connected_mnn, mutual_nn, np.array(new_knn_indices), np.array(new_knn_dists)


def get_sparse_matrix_from_indices_distances_umap(
    knn_indices, knn_dists, n_obs, n_neighbors
):
    """get distances matrix for anndata container"""
    rows = np.zeros((n_obs * n_neighbors), dtype=np.int64)
    cols = np.zeros((n_obs * n_neighbors), dtype=np.int64)
    vals = np.zeros((n_obs * n_neighbors), dtype=np.float64)

    for i in range(knn_indices.shape[0]):
        for j in range(n_neighbors):
            if knn_indices[i, j] == -1:
                continue  # We didn't get the full knn for i
            if knn_indices[i, j] == i:
                val = 0.0
            else:
                val = knn_dists[i, j]

            rows[i * n_neighbors + j] = i
            cols[i * n_neighbors + j] = knn_indices[i, j]
            vals[i * n_neighbors + j] = val

    result = scipy.sparse.coo_matrix((vals, (rows, cols)), shape=(n_obs, n_obs))
    result.eliminate_zeros()
    return result.tocsr()


def get_init_pos_from_paga(adata, adjacency=None, random_state=0):
    """get init coordinates for UMAP based on partition-based graph abstraction (PAGA) from anndata container"""
    np.random.seed(random_state)
    if adjacency is None:
        adjacency = adata.obsp["connectivities"]
    if "paga" in adata.uns and "pos" in adata.uns["paga"]:
        groups = adata.obs[adata.uns["paga"]["groups"]]
        pos = adata.uns["paga"]["pos"]
        connectivities_coarse = adata.uns["paga"]["connectivities"]
        init_pos = np.ones((adjacency.shape[0], 2))
        for i, group_pos in enumerate(pos):
            subset = (groups == groups.cat.categories[i]).values
            neighbors = connectivities_coarse[i].nonzero()
            if len(neighbors[1]) > 0:
                connectivities = connectivities_coarse[i][neighbors]
                nearest_neighbor = neighbors[1][np.argmax(connectivities)]
                noise = np.random.random((len(subset[subset]), 2))
                dist = pos[i] - pos[nearest_neighbor]
                noise = noise * dist
                init_pos[subset] = group_pos - 0.5 * dist + noise
            else:
                init_pos[subset] = group_pos
    else:
        raise ValueError("Plot PAGA first, so that adata.uns['paga']" "with key 'pos'.")
    return init_pos


def update_subregion_embedding(adata):
    """update embedding of individual subregion dataset"""
    adata = adata[
        :,
        ~adata.var_names.str.match(
            r"(^Hla-|^Ig[hjkl]|^Rna|^mt-|^Rp[sl]|^Hb[^(p)]|^Gm)"
        ),
    ]
    adata = adata[:, ~adata.var_names.isin(hk_genes1)]

    # derive shared highly variable genes and run PCA on top
    sc.pp.normalize_total(adata, target_sum=1e4)
    sc.pp.log1p(adata)
    highly_variable_genes(adata, n_top_genes=4000, batch_key=["orig.ident"])
    adata.raw = adata
    sc.pp.regress_out(adata, ["nCount_RNA", "percent_mito_ribo"])
    sc.pp.scale(adata, max_value=10)
    sc.tl.pca(adata, svd_solver="arpack")

    embedding = PaCMAP(
        n_components=2, n_neighbors=None, MN_ratio=0.5, FP_ratio=2.0, apply_pca=False
    )
    adata.obsm["X_pacmap"] = embedding.fit_transform(adata.obsm["X_pca"], init="pca")

    reducer = UMAP(densmap=True, n_components=2, random_state=reseed, verbose=False)
    reducer.fit(adata.obsm["X_pca"], adata.obs["clusters"].astype(str))
    adata.obsm["X_umap"] = reducer.transform(adata.obsm["X_pca"])

    return adata
```

### parameters

```{python}
######################
##### parameters #####
######################

# Distance Metric to Use
# metric = snakemake.params["metric"]
metric = "euclidean"
# connectivity_model = snakemake.params["connectivity_model"]
connectivity_model = "min_tree"
PLOTS_DIR = os.path.join("output/figures/resolved_subregions_by_microclusters-replic-3/")
OUT_DIR = os.path.join("data/resolved_subregions_by_microclusters-replic-3/")

SMALL_SIZE = 7
MEDIUM_SIZE = 8
BIGGER_SIZE = 12

plt.rc("font", size=SMALL_SIZE)  # controls default text sizes
plt.rc("axes", titlesize=SMALL_SIZE)  # fontsize of the axes title
plt.rc("axes", labelsize=MEDIUM_SIZE)  # fontsize of the x and y labels
plt.rc("xtick", labelsize=SMALL_SIZE)  # fontsize of the tick labels
plt.rc("ytick", labelsize=SMALL_SIZE)  # fontsize of the tick labels
plt.rc("legend", fontsize=SMALL_SIZE)  # legend fontsize
plt.rc("figure", titlesize=BIGGER_SIZE)  # fontsize of the figure title
matplotlib.rcParams["font.size"] = 11
matplotlib.rcParams["pdf.use14corefonts"] = True
matplotlib.rcParams["pdf.fonttype"] = 42
matplotlib.rcParams["ps.fonttype"] = 42
matplotlib.rcParams["font.family"] = "sans-serif"
matplotlib.rcParams["font.sans-serif"] = ["Helvetica"]
matplotlib.rcParams["figure.max_open_warning"] = 20000


reseed = 42
random.seed(reseed)
np.random.seed(reseed)
random_state = check_random_state(reseed)

verbose = True
sc.settings.verbosity = 2  # verbosity: errors (0), warnings (1), info (2), hints (3)
sc.settings.figdir = PLOTS_DIR
sc.settings.writedir = OUT_DIR
sc.settings.set_figure_params(
    dpi=120,
    dpi_save=600,
    vector_friendly=True,
    format="pdf",
    transparent=True,
    color_map="gnuplot_r",
)
sc.settings.autoshow = False
sc.settings.autosave = True

min_dist = 1.0
a, b = find_ab_params(1.0, min_dist)
n_components = 2
negative_sample_rate = 10
# k = int(snakemake.params["k"])
k = 10
ks = k + 10
# signature = snakemake.params["substr_sign"]
signature = 100
# cb_fpr = snakemake.params["res"]
cb_fpr = 0.001
max_comm_size = int(2 * ks)
max_comm_size_paga = int(k * ks)
paga_threshold = 0.25
spread = 2
threads = 120
svm_fit_strength = 100
```

### Load data

```{python}
######################
##### Load data ######
######################

## IN:
# data_path = snakemake.input["h5ad_pairs"]
# genes_table = snakemake.input["aggregated_shared_genes"]
genes_table = (
    f"data/output/tables/shared_signature/astrocytes_genes-aggregated-{cb_fpr}.tsv"
)
housekeeping = f"data/data/housekeeping_mouse.tsv"
tf_fname = f"/data/data/mm_tfs.csv"

## OUT:
h5ad_out_path = f"data/data/resolved_subregions/hypothalamic-astrocytes-k_{k}-sign_{signature}-amb_{cb_fpr}.h5ad"
picklefile = f"data/data/resolved_subregions/tntest_hypothalamic-astrocytes-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle"
graph = f"data/data/resolved_subregions/graph_hypothalamic-astrocytes-k_{k}-sign_{signature}-amb_{cb_fpr}.graphml"

# h5ad_out_path = snakemake.output["h5ad"]
# picklefile = snakemake.output["picklefile"]
# graph = snakemake.output["graph"]

sign_genes = pd.read_table(genes_table)
sign_genes = sign_genes.sort_values(["Score"], ascending=True).head(signature)

hk_genes1 = []
with open(housekeeping) as file:
    while hk_genes := file.readline():
        hk_genes1.append(hk_genes.rstrip())

tf_genes = []
with open(tf_fname) as file:
    while tf := file.readline():
        tf_genes.append(tf.rstrip())

PRJNA847050 = sc.read_h5ad(
    f"data/data/paired_integrations-wo_signature/paired_mtx-PRJNA779749_and_PRJNA847050-{signature}-astrocytes_datasets_{cb_fpr}.h5ad"
)
PRJNA815819 = sc.read_h5ad(
    f"data/data/paired_integrations-wo_signature/paired_mtx-PRJNA779749_and_PRJNA815819-{signature}-astrocytes_datasets_{cb_fpr}.h5ad"
)
PRJNA798401 = sc.read_h5ad(
    f"data/data/paired_integrations-wo_signature/paired_mtx-PRJNA779749_and_PRJNA798401-{signature}-astrocytes_datasets_{cb_fpr}.h5ad"
)
PRJNA723345 = sc.read_h5ad(
    f"data/data/paired_integrations-wo_signature/paired_mtx-PRJNA779749_and_PRJNA723345-{signature}-astrocytes_datasets_{cb_fpr}.h5ad"
)
PRJNA722418 = sc.read_h5ad(
    f"data/data/paired_integrations-wo_signature/paired_mtx-PRJNA779749_and_PRJNA722418-{signature}-astrocytes_datasets_{cb_fpr}.h5ad"
)
PRJNA705596 = sc.read_h5ad(
    f"data/data/paired_integrations-wo_signature/paired_mtx-PRJNA779749_and_PRJNA705596-{signature}-astrocytes_datasets_{cb_fpr}.h5ad"
)
PRJNA679294 = sc.read_h5ad(
    f"data/data/paired_integrations-wo_signature/paired_mtx-PRJNA779749_and_PRJNA679294-{signature}-astrocytes_datasets_{cb_fpr}.h5ad"
)
PRJNA611624 = sc.read_h5ad(
    f"data/data/paired_integrations-wo_signature/paired_mtx-PRJNA779749_and_PRJNA611624-{signature}-astrocytes_datasets_{cb_fpr}.h5ad"
)
PRJNA604055 = sc.read_h5ad(
    f"data/data/paired_integrations-wo_signature/paired_mtx-PRJNA779749_and_PRJNA604055-{signature}-astrocytes_datasets_{cb_fpr}.h5ad"
)
PRJNA548532 = sc.read_h5ad(
    f"data/data/paired_integrations-wo_signature/paired_mtx-PRJNA779749_and_PRJNA548532-{signature}-astrocytes_datasets_{cb_fpr}.h5ad"
)
PRJNA515063 = sc.read_h5ad(
    f"data/data/paired_integrations-wo_signature/paired_mtx-PRJNA779749_and_PRJNA515063-{signature}-astrocytes_datasets_{cb_fpr}.h5ad"
)
PRJNA453138 = sc.read_h5ad(
    f"data/data/paired_integrations-wo_signature/paired_mtx-PRJNA779749_and_PRJNA453138-{signature}-astrocytes_datasets_{cb_fpr}.h5ad"
)

PRJNA779749_counts = sc.read_h5ad(
    f"data/PRJNA779749/data/class_cello/PRJNA779749-astrocytes_dataset-{cb_fpr}-initial_selection.h5ad"
)
PRJNA847050_counts = sc.read_h5ad(
    f"data/PRJNA847050/data/class_cello/PRJNA847050-astrocytes_dataset-{cb_fpr}-initial_selection.h5ad"
)
PRJNA815819_counts = sc.read_h5ad(
    f"data/PRJNA815819/data/class_cello/PRJNA815819-astrocytes_dataset-{cb_fpr}-initial_selection.h5ad"
)
PRJNA798401_counts = sc.read_h5ad(
    f"data/PRJNA798401/data/class_cello/PRJNA798401-astrocytes_dataset-{cb_fpr}-initial_selection.h5ad"
)
PRJNA723345_counts = sc.read_h5ad(
    f"data/PRJNA723345/data/class_cello/PRJNA723345-astrocytes_dataset-{cb_fpr}-initial_selection.h5ad"
)
PRJNA722418_counts = sc.read_h5ad(
    f"data/PRJNA722418/data/class_cello/PRJNA722418-astrocytes_dataset-{cb_fpr}-initial_selection.h5ad"
)
PRJNA705596_counts = sc.read_h5ad(
    f"data/PRJNA705596/data/class_cello/PRJNA705596-astrocytes_dataset-{cb_fpr}-initial_selection.h5ad"
)
PRJNA679294_counts = sc.read_h5ad(
    f"data/PRJNA679294/data/class_cello/PRJNA679294-astrocytes_dataset-{cb_fpr}-initial_selection.h5ad"
)
PRJNA611624_counts = sc.read_h5ad(
    f"data/PRJNA611624/data/class_cello/PRJNA611624-astrocytes_dataset-{cb_fpr}-initial_selection.h5ad"
)
PRJNA604055_counts = sc.read_h5ad(
    f"data/PRJNA604055/data/class_cello/PRJNA604055-astrocytes_dataset-{cb_fpr}-initial_selection.h5ad"
)
PRJNA548532_counts = sc.read_h5ad(
    f"data/PRJNA548532/data/class_cello/PRJNA548532-astrocytes_dataset-{cb_fpr}-initial_selection.h5ad"
)
PRJNA515063_counts = sc.read_h5ad(
    f"data/PRJNA515063/data/class_cello/PRJNA515063-astrocytes_dataset-{cb_fpr}-initial_selection.h5ad"
)
PRJNA453138_counts = sc.read_h5ad(
    f"data/PRJNA453138/data/class_cello/PRJNA453138-astrocytes_dataset-{cb_fpr}-initial_selection.h5ad"
)

PRJNA779749_counts = PRJNA779749_counts[PRJNA779749_counts.obs["condit"] == 0]
PRJNA847050_counts = PRJNA847050_counts[PRJNA847050_counts.obs["condit"] == 0]
PRJNA815819_counts = PRJNA815819_counts[PRJNA815819_counts.obs["condit"] == 0]
PRJNA798401_counts = PRJNA798401_counts[PRJNA798401_counts.obs["condit"] == 0]
PRJNA723345_counts = PRJNA723345_counts[PRJNA723345_counts.obs["condit"] == 0]
PRJNA722418_counts = PRJNA722418_counts[PRJNA722418_counts.obs["condit"] == 0]
PRJNA705596_counts = PRJNA705596_counts[PRJNA705596_counts.obs["condit"] == 0]
PRJNA679294_counts = PRJNA679294_counts[PRJNA679294_counts.obs["condit"] == 0]
PRJNA611624_counts = PRJNA611624_counts[PRJNA611624_counts.obs["condit"] == 0]
PRJNA604055_counts = PRJNA604055_counts[PRJNA604055_counts.obs["condit"] == 0]
PRJNA548532_counts = PRJNA548532_counts[PRJNA548532_counts.obs["condit"] == 0]
PRJNA515063_counts = PRJNA515063_counts[PRJNA515063_counts.obs["condit"] == 0]
PRJNA453138_counts = PRJNA453138_counts[PRJNA453138_counts.obs["condit"] == 0]
```

```{python}
# split train and test sets first
X1_PRJNA847050, X2_PRJNA847050, X3_PRJNA847050, X4_PRJNA847050 = (
    PRJNA847050.obsm["X_pca_harmony"][
        PRJNA847050.obs["train"] & (PRJNA847050.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA847050.obsm["X_pca_harmony"][
        PRJNA847050.obs["test"] & (PRJNA847050.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA847050.obsm["X_pca_harmony"][
        PRJNA847050.obs["train"] & (PRJNA847050.obs["bioproject"] == "PRJNA847050")
    ],
    PRJNA847050.obsm["X_pca_harmony"][
        PRJNA847050.obs["test"] & (PRJNA847050.obs["bioproject"] == "PRJNA847050")
    ],
)
```

```{python}
# split train and test sets first
X1_PRJNA815819, X2_PRJNA815819, X3_PRJNA815819, X4_PRJNA815819 = (
    PRJNA815819.obsm["X_pca_harmony"][
        PRJNA815819.obs["train"] & (PRJNA815819.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA815819.obsm["X_pca_harmony"][
        PRJNA815819.obs["test"] & (PRJNA815819.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA815819.obsm["X_pca_harmony"][
        PRJNA815819.obs["train"] & (PRJNA815819.obs["bioproject"] == "PRJNA815819")
    ],
    PRJNA815819.obsm["X_pca_harmony"][
        PRJNA815819.obs["test"] & (PRJNA815819.obs["bioproject"] == "PRJNA815819")
    ],
)
```

```{python}
# split train and test sets first
X1_PRJNA798401, X2_PRJNA798401, X3_PRJNA798401, X4_PRJNA798401 = (
    PRJNA798401.obsm["X_pca_harmony"][
        PRJNA798401.obs["train"] & (PRJNA798401.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA798401.obsm["X_pca_harmony"][
        PRJNA798401.obs["test"] & (PRJNA798401.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA798401.obsm["X_pca_harmony"][
        PRJNA798401.obs["train"] & (PRJNA798401.obs["bioproject"] == "PRJNA798401")
    ],
    PRJNA798401.obsm["X_pca_harmony"][
        PRJNA798401.obs["test"] & (PRJNA798401.obs["bioproject"] == "PRJNA798401")
    ],
)
```

```{python}
# split train and test sets first
X1_PRJNA723345, X2_PRJNA723345, X3_PRJNA723345, X4_PRJNA723345 = (
    PRJNA723345.obsm["X_pca_harmony"][
        PRJNA723345.obs["train"] & (PRJNA723345.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA723345.obsm["X_pca_harmony"][
        PRJNA723345.obs["test"] & (PRJNA723345.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA723345.obsm["X_pca_harmony"][
        PRJNA723345.obs["train"] & (PRJNA723345.obs["bioproject"] == "PRJNA723345")
    ],
    PRJNA723345.obsm["X_pca_harmony"][
        PRJNA723345.obs["test"] & (PRJNA723345.obs["bioproject"] == "PRJNA723345")
    ],
)
```

```{python}
# split train and test sets first
X1_PRJNA722418, X2_PRJNA722418, X3_PRJNA722418, X4_PRJNA722418 = (
    PRJNA722418.obsm["X_pca_harmony"][
        PRJNA722418.obs["train"] & (PRJNA722418.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA722418.obsm["X_pca_harmony"][
        PRJNA722418.obs["test"] & (PRJNA722418.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA722418.obsm["X_pca_harmony"][
        PRJNA722418.obs["train"] & (PRJNA722418.obs["bioproject"] == "PRJNA722418")
    ],
    PRJNA722418.obsm["X_pca_harmony"][
        PRJNA722418.obs["test"] & (PRJNA722418.obs["bioproject"] == "PRJNA722418")
    ],
)
```

```{python}
# split train and test sets first
X1_PRJNA705596, X2_PRJNA705596, X3_PRJNA705596, X4_PRJNA705596 = (
    PRJNA705596.obsm["X_pca_harmony"][
        PRJNA705596.obs["train"] & (PRJNA705596.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA705596.obsm["X_pca_harmony"][
        PRJNA705596.obs["test"] & (PRJNA705596.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA705596.obsm["X_pca_harmony"][
        PRJNA705596.obs["train"] & (PRJNA705596.obs["bioproject"] == "PRJNA705596")
    ],
    PRJNA705596.obsm["X_pca_harmony"][
        PRJNA705596.obs["test"] & (PRJNA705596.obs["bioproject"] == "PRJNA705596")
    ],
)
```

```{python}
# split train and test sets first
X1_PRJNA679294, X2_PRJNA679294, X3_PRJNA679294, X4_PRJNA679294 = (
    PRJNA679294.obsm["X_pca_harmony"][
        PRJNA679294.obs["train"] & (PRJNA679294.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA679294.obsm["X_pca_harmony"][
        PRJNA679294.obs["test"] & (PRJNA679294.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA679294.obsm["X_pca_harmony"][
        PRJNA679294.obs["train"] & (PRJNA679294.obs["bioproject"] == "PRJNA679294")
    ],
    PRJNA679294.obsm["X_pca_harmony"][
        PRJNA679294.obs["test"] & (PRJNA679294.obs["bioproject"] == "PRJNA679294")
    ],
)
```

```{python}
# split train and test sets first
X1_PRJNA611624, X2_PRJNA611624, X3_PRJNA611624, X4_PRJNA611624 = (
    PRJNA611624.obsm["X_pca_harmony"][
        PRJNA611624.obs["train"] & (PRJNA611624.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA611624.obsm["X_pca_harmony"][
        PRJNA611624.obs["test"] & (PRJNA611624.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA611624.obsm["X_pca_harmony"][
        PRJNA611624.obs["train"] & (PRJNA611624.obs["bioproject"] == "PRJNA611624")
    ],
    PRJNA611624.obsm["X_pca_harmony"][
        PRJNA611624.obs["test"] & (PRJNA611624.obs["bioproject"] == "PRJNA611624")
    ],
)
```

```{python}
# split train and test sets first
X1_PRJNA604055, X2_PRJNA604055, X3_PRJNA604055, X4_PRJNA604055 = (
    PRJNA604055.obsm["X_pca_harmony"][
        PRJNA604055.obs["train"] & (PRJNA604055.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA604055.obsm["X_pca_harmony"][
        PRJNA604055.obs["test"] & (PRJNA604055.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA604055.obsm["X_pca_harmony"][
        PRJNA604055.obs["train"] & (PRJNA604055.obs["bioproject"] == "PRJNA604055")
    ],
    PRJNA604055.obsm["X_pca_harmony"][
        PRJNA604055.obs["test"] & (PRJNA604055.obs["bioproject"] == "PRJNA604055")
    ],
)
```

```{python}
# split train and test sets first
X1_PRJNA548532, X2_PRJNA548532, X3_PRJNA548532, X4_PRJNA548532 = (
    PRJNA548532.obsm["X_pca_harmony"][
        PRJNA548532.obs["train"] & (PRJNA548532.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA548532.obsm["X_pca_harmony"][
        PRJNA548532.obs["test"] & (PRJNA548532.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA548532.obsm["X_pca_harmony"][
        PRJNA548532.obs["train"] & (PRJNA548532.obs["bioproject"] == "PRJNA548532")
    ],
    PRJNA548532.obsm["X_pca_harmony"][
        PRJNA548532.obs["test"] & (PRJNA548532.obs["bioproject"] == "PRJNA548532")
    ],
)
```

```{python}
# split train and test sets first
X1_PRJNA515063, X2_PRJNA515063, X3_PRJNA515063, X4_PRJNA515063 = (
    PRJNA515063.obsm["X_pca_harmony"][
        PRJNA515063.obs["train"] & (PRJNA515063.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA515063.obsm["X_pca_harmony"][
        PRJNA515063.obs["test"] & (PRJNA515063.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA515063.obsm["X_pca_harmony"][
        PRJNA515063.obs["train"] & (PRJNA515063.obs["bioproject"] == "PRJNA515063")
    ],
    PRJNA515063.obsm["X_pca_harmony"][
        PRJNA515063.obs["test"] & (PRJNA515063.obs["bioproject"] == "PRJNA515063")
    ],
)
```

```{python}
# split train and test sets first
X1_PRJNA453138, X2_PRJNA453138, X3_PRJNA453138, X4_PRJNA453138 = (
    PRJNA453138.obsm["X_pca_harmony"][
        PRJNA453138.obs["train"] & (PRJNA453138.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA453138.obsm["X_pca_harmony"][
        PRJNA453138.obs["test"] & (PRJNA453138.obs["bioproject"] == "PRJNA779749")
    ],
    PRJNA453138.obsm["X_pca_harmony"][
        PRJNA453138.obs["train"] & (PRJNA453138.obs["bioproject"] == "PRJNA453138")
    ],
    PRJNA453138.obsm["X_pca_harmony"][
        PRJNA453138.obs["test"] & (PRJNA453138.obs["bioproject"] == "PRJNA453138")
    ],
)
```

```{python}
reducer_PRJNA847050 = UMAP(
    n_components=6,
    n_neighbors=ks,
    n_epochs=1000,
    metric="cosine",
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    angular_rp_forest=True,
    densmap=False,
    random_state=reseed,
    transform_seed=reseed,
    verbose=False,
)
reducer_PRJNA847050.fit(X3_PRJNA847050)
umap_PRJNA847050_prediction = reducer_PRJNA847050.transform(X1_PRJNA847050)

reducer_PRJNA815819 = UMAP(
    n_components=6,
    n_neighbors=ks,
    n_epochs=1000,
    metric="cosine",
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    angular_rp_forest=True,
    densmap=False,
    random_state=reseed,
    transform_seed=reseed,
    verbose=False,
)
reducer_PRJNA815819.fit(X3_PRJNA815819)
umap_PRJNA815819_prediction = reducer_PRJNA815819.transform(X1_PRJNA815819)

reducer_PRJNA798401 = UMAP(
    n_components=6,
    n_neighbors=ks,
    n_epochs=1000,
    metric="cosine",
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    angular_rp_forest=True,
    densmap=False,
    random_state=reseed,
    transform_seed=reseed,
    verbose=False,
)
reducer_PRJNA798401.fit(X3_PRJNA798401)
umap_PRJNA798401_prediction = reducer_PRJNA798401.transform(X1_PRJNA798401)

reducer_PRJNA723345 = UMAP(
    n_components=6,
    n_neighbors=ks,
    n_epochs=1000,
    metric="cosine",
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    angular_rp_forest=True,
    densmap=False,
    random_state=reseed,
    transform_seed=reseed,
    verbose=False,
)
reducer_PRJNA723345.fit(X3_PRJNA723345)
umap_PRJNA723345_prediction = reducer_PRJNA723345.transform(X1_PRJNA723345)

reducer_PRJNA722418 = UMAP(
    n_components=6,
    n_neighbors=ks,
    n_epochs=1000,
    metric="cosine",
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    angular_rp_forest=True,
    densmap=False,
    random_state=reseed,
    transform_seed=reseed,
    verbose=False,
)
reducer_PRJNA722418.fit(X3_PRJNA722418)
umap_PRJNA722418_prediction = reducer_PRJNA722418.transform(X1_PRJNA722418)

reducer_PRJNA705596 = UMAP(
    n_components=6,
    n_neighbors=ks,
    n_epochs=1000,
    metric="cosine",
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    angular_rp_forest=True,
    densmap=False,
    random_state=reseed,
    transform_seed=reseed,
    verbose=False,
)
reducer_PRJNA705596.fit(X3_PRJNA705596)
umap_PRJNA705596_prediction = reducer_PRJNA705596.transform(X1_PRJNA705596)

reducer_PRJNA679294 = UMAP(
    n_components=6,
    n_neighbors=ks,
    n_epochs=1000,
    metric="cosine",
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    angular_rp_forest=True,
    densmap=False,
    random_state=reseed,
    transform_seed=reseed,
    verbose=False,
)
reducer_PRJNA679294.fit(X3_PRJNA679294)
umap_PRJNA679294_prediction = reducer_PRJNA679294.transform(X1_PRJNA679294)

reducer_PRJNA611624 = UMAP(
    n_components=6,
    n_neighbors=ks,
    n_epochs=1000,
    metric="cosine",
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    angular_rp_forest=True,
    densmap=False,
    random_state=reseed,
    transform_seed=reseed,
    verbose=False,
)
reducer_PRJNA611624.fit(X3_PRJNA611624)
umap_PRJNA611624_prediction = reducer_PRJNA611624.transform(X1_PRJNA611624)

reducer_PRJNA604055 = UMAP(
    n_components=6,
    n_neighbors=ks,
    n_epochs=1000,
    metric="cosine",
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    angular_rp_forest=True,
    densmap=False,
    random_state=reseed,
    transform_seed=reseed,
    verbose=False,
)
reducer_PRJNA604055.fit(X3_PRJNA604055)
umap_PRJNA604055_prediction = reducer_PRJNA604055.transform(X1_PRJNA604055)

reducer_PRJNA548532 = UMAP(
    n_components=6,
    n_neighbors=ks,
    n_epochs=1000,
    metric="cosine",
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    angular_rp_forest=True,
    densmap=False,
    random_state=reseed,
    transform_seed=reseed,
    verbose=False,
)
reducer_PRJNA548532.fit(X3_PRJNA548532)
umap_PRJNA548532_prediction = reducer_PRJNA548532.transform(X1_PRJNA548532)

reducer_PRJNA515063 = UMAP(
    n_components=6,
    n_neighbors=ks,
    n_epochs=1000,
    metric="cosine",
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    angular_rp_forest=True,
    densmap=False,
    random_state=reseed,
    transform_seed=reseed,
    verbose=False,
)
reducer_PRJNA515063.fit(X3_PRJNA515063)
umap_PRJNA515063_prediction = reducer_PRJNA515063.transform(X1_PRJNA515063)

reducer_PRJNA453138 = UMAP(
    n_components=6,
    n_neighbors=ks,
    n_epochs=1000,
    metric="cosine",
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    angular_rp_forest=True,
    densmap=False,
    random_state=reseed,
    transform_seed=reseed,
    verbose=False,
)
reducer_PRJNA453138.fit(X3_PRJNA453138)
umap_PRJNA453138_prediction = reducer_PRJNA453138.transform(X1_PRJNA453138)
```

### Derive draft partitioning scheme (microclusters) for initiation

```{python}
umap_big = np.concatenate(
    (
        umap_PRJNA847050_prediction,
        umap_PRJNA815819_prediction,
        umap_PRJNA798401_prediction,
        umap_PRJNA723345_prediction,
        umap_PRJNA722418_prediction,
        umap_PRJNA705596_prediction,
        umap_PRJNA679294_prediction,
        umap_PRJNA611624_prediction,
        umap_PRJNA604055_prediction,
        umap_PRJNA548532_prediction,
        umap_PRJNA515063_prediction,
        umap_PRJNA453138_prediction,
    ),
    axis=1,
)
umap_big.shape
```

```{python}
X_train, X_test = (
    PRJNA779749_counts[PRJNA779749_counts.obs["train"]].X,
    PRJNA779749_counts[PRJNA779749_counts.obs["test"]].X,
)
X_train.shape
```

```{python}
PRJNA779749_init = PRJNA779749_counts[PRJNA779749_counts.obs["train"]]
```

```{python}
#######################################
##### derive set of paired graphs #####
#######################################
warnings.filterwarnings("ignore")
```

```{python}
PRJNA779749_init.obsm["X_umap_big"] = umap_big
```

```{python}
sc.pp.neighbors(
    PRJNA779749_init,
    n_neighbors=ks,
    use_rep="X_umap_big",
    metric=metric,
    knn=True,
    random_state=reseed,
)
```

```{python}
# derive knn graph
(
    knn_indices_init,
    knn_dists_init,
    knn_search_index_init,
) = nearest_neighbors(
    umap_big,
    n_neighbors=k,
    metric=metric,
    metric_kwds={},
    angular=False,
    random_state=random_state,
    low_memory=True,
    use_pynndescent=True,
    n_jobs=threads,
    verbose=True,
)

# derive mutual nn graph
(
    connected_mnn_init,
    mutual_nn_init,
    new_knn_indices_init,
    new_knn_dists_init,
) = mutual_nn_nearest(
    knn_indices_init,
    knn_dists_init,
    k,
    ks,
    connectivity=connectivity_model,
    verbose=True,
)

# build fuzzy_simplicial_set
G_train, sigmas_init, rhos_init = fuzzy_simplicial_set(
    X=umap_big,
    n_neighbors=ks,
    metric=metric,
    random_state=random_state,
    knn_indices=new_knn_indices_init,
    knn_dists=new_knn_dists_init,
)
```

```{python}
init_optimiser = Optimiser()
init_optimiser.set_rng_seed(reseed)
init_optimiser.max_comm_size = max_comm_size
```

```{python}
profile = init_optimiser.resolution_profile(
    ig.Graph.from_networkx(from_scipy_sparse_array(G_train)),
    CPMVertexPartition,
    number_iterations=-1,
    weights="weight",
    linear_bisection=False,
    resolution_range=(0, 2),
)
```

```{python}
init_part_PRJNA779749 = CPMVertexPartition(
    ig.Graph.from_networkx(from_scipy_sparse_array(G_train)),
    weights="weight",
    resolution_parameter=0.0112,
)
```

```{python}
diff = init_optimiser.optimise_partition(init_part_PRJNA779749, n_iterations=-1)
diff
```

```{python}
labels1 = init_part_PRJNA779749.membership
PRJNA779749_init.obs["subfunct_groups"] = labels1
print(Counter(labels1))
```

```{python}
PRJNA779749_init.obsp["connectivities"] = ig.Graph.from_networkx(
    from_scipy_sparse_array(G_train)
).get_adjacency_sparse()
```

```{python}
PRJNA779749_init.obsp["distances"] = get_sparse_matrix_from_indices_distances_umap(
    new_knn_indices_init, new_knn_dists_init, PRJNA779749_init.n_obs, ks
)
```

```{python}
PRJNA779749_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA779749_init.obs["subfunct_groups"].astype(str),
    categories=natsorted(
        map(str, np.unique(PRJNA779749_init.obs["subfunct_groups"].astype(str)))
    ),
)
```

```{python}
# sc.tl.diffmap(PRJNA847050_init, random_state=reseed)
# sc.pp.neighbors(PRJNA847050_init, n_neighbors=k, use_rep='X_diffmap')
sc.tl.paga(PRJNA779749_init, groups="subfunct_groups")
sc.pl.paga(
    PRJNA779749_init,
    threshold=paga_threshold,
    layout="fr",
    cmap="nipy_spectral",
    show=True,
    save=False,
    random_state=reseed,
)
```

```{python}
(
    PRJNA779749_init_train_embeddings,
    PRJNA779749_init_train_aux_data,
) = simplicial_set_embedding(
    data=umap_big,
    graph=G_train.tocoo(),
    n_components=n_components,
    initial_alpha=1.0,
    a=a,
    b=b,
    gamma=5.0,
    negative_sample_rate=negative_sample_rate,
    n_epochs=500,
    init=get_init_pos_from_paga(adata=PRJNA779749_init, random_state=reseed),
    random_state=check_random_state(reseed),
    metric=metric,
    metric_kwds={},
    densmap=False,
    densmap_kwds={},
    output_dens=False,
    output_metric=dist.named_distances_with_gradients["euclidean"],
    output_metric_kwds={},
    euclidean_output=True,
    parallel=False,
    verbose=True,
)

PRJNA779749_init.obsm["X_umap"] = PRJNA779749_init_train_embeddings
```

```{python}
sc.pl.umap(
    PRJNA779749_init,
    color=["subfunct_groups"],
    frameon=False,
    show=True,
    save="-PRJNA779749_init_umap.pdf",
)
```

### Project microclusters from whole train hypothalamus to subregional train sets

```{python}
# Fit linear separator using X_train
svm_PRJNA847050_init = SVC(kernel="linear", C=svm_fit_strength)
svm_PRJNA847050_init.fit(X1_PRJNA847050, labels1)
joblib.dump(
    svm_PRJNA847050_init,
    f"models/svm/PRJNA847050_init-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

# Generate labels for X3_PRJNA847050
predictions_X3_PRJNA847050 = svm_PRJNA847050_init.predict(X3_PRJNA847050)
```

```{python}
# Fit linear separator using X_train
svm_PRJNA815819_init = SVC(kernel="linear", C=svm_fit_strength)
svm_PRJNA815819_init.fit(X1_PRJNA815819, labels1)
joblib.dump(
    svm_PRJNA815819_init,
    f"models/svm/PRJNA815819_init-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

# Generate labels for X3_PRJNA815819
predictions_X3_PRJNA815819 = svm_PRJNA815819_init.predict(X3_PRJNA815819)
```

```{python}
# Fit linear separator using X_train
svm_PRJNA798401_init = SVC(kernel="linear", C=svm_fit_strength)
svm_PRJNA798401_init.fit(X1_PRJNA798401, labels1)
joblib.dump(
    svm_PRJNA798401_init,
    f"models/svm/PRJNA798401_init-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

# Generate labels for X3_PRJNA798401
predictions_X3_PRJNA798401 = svm_PRJNA798401_init.predict(X3_PRJNA798401)
```

```{python}
# Fit linear separator using X_train
svm_PRJNA723345_init = SVC(kernel="linear", C=svm_fit_strength)
svm_PRJNA723345_init.fit(X1_PRJNA723345, labels1)
joblib.dump(
    svm_PRJNA723345_init,
    f"models/svm/PRJNA723345_init-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

# Generate labels for X3_PRJNA723345
predictions_X3_PRJNA723345 = svm_PRJNA723345_init.predict(X3_PRJNA723345)
```

```{python}
# Fit linear separator using X_train
svm_PRJNA722418_init = SVC(kernel="linear", C=svm_fit_strength)
svm_PRJNA722418_init.fit(X1_PRJNA722418, labels1)
joblib.dump(
    svm_PRJNA722418_init,
    f"models/svm/PRJNA722418_init-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

# Generate labels for X3_PRJNA722418
predictions_X3_PRJNA722418 = svm_PRJNA722418_init.predict(X3_PRJNA722418)
```

```{python}
# Fit linear separator using X_train
svm_PRJNA705596_init = SVC(kernel="linear", C=svm_fit_strength)
svm_PRJNA705596_init.fit(X1_PRJNA705596, labels1)
joblib.dump(
    svm_PRJNA705596_init,
    f"models/svm/PRJNA705596_init-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

# Generate labels for X3_PRJNA705596
predictions_X3_PRJNA705596 = svm_PRJNA705596_init.predict(X3_PRJNA705596)
```

```{python}
# Fit linear separator using X_train
svm_PRJNA679294_init = SVC(kernel="linear", C=svm_fit_strength)
svm_PRJNA679294_init.fit(X1_PRJNA679294, labels1)
joblib.dump(
    svm_PRJNA679294_init,
    f"models/svm/PRJNA679294_init-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

# Generate labels for X3_PRJNA679294
predictions_X3_PRJNA679294 = svm_PRJNA679294_init.predict(X3_PRJNA679294)
```

```{python}
# Fit linear separator using X_train
svm_PRJNA611624_init = SVC(kernel="linear", C=svm_fit_strength)
svm_PRJNA611624_init.fit(X1_PRJNA611624, labels1)
joblib.dump(
    svm_PRJNA611624_init,
    f"models/svm/PRJNA611624_init-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

# Generate labels for X3_PRJNA611624
predictions_X3_PRJNA611624 = svm_PRJNA611624_init.predict(X3_PRJNA611624)
```

```{python}
# Fit linear separator using X_train
svm_PRJNA604055_init = SVC(kernel="linear", C=svm_fit_strength)
svm_PRJNA604055_init.fit(X1_PRJNA604055, labels1)
joblib.dump(
    svm_PRJNA604055_init,
    f"models/svm/PRJNA604055_init-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

# Generate labels for X3_PRJNA604055
predictions_X3_PRJNA604055 = svm_PRJNA604055_init.predict(X3_PRJNA604055)
```

```{python}
# Fit linear separator using X_train
svm_PRJNA548532_init = SVC(kernel="linear", C=svm_fit_strength)
svm_PRJNA548532_init.fit(X1_PRJNA548532, labels1)
joblib.dump(
    svm_PRJNA548532_init,
    f"models/svm/PRJNA548532_init-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

# Generate labels for X3_PRJNA548532
predictions_X3_PRJNA548532 = svm_PRJNA548532_init.predict(X3_PRJNA548532)
```

```{python}
# Fit linear separator using X_train
svm_PRJNA515063_init = SVC(kernel="linear", C=svm_fit_strength)
svm_PRJNA515063_init.fit(X1_PRJNA515063, labels1)
joblib.dump(
    svm_PRJNA515063_init,
    f"models/svm/PRJNA515063_init-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

# Generate labels for X3_PRJNA515063
predictions_X3_PRJNA515063 = svm_PRJNA515063_init.predict(X3_PRJNA515063)
```

```{python}
# Fit linear separator using X_train
svm_PRJNA453138_init = SVC(kernel="linear", C=svm_fit_strength)
svm_PRJNA453138_init.fit(X1_PRJNA453138, labels1)
joblib.dump(
    svm_PRJNA453138_init,
    f"models/svm/PRJNA453138_init-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

# Generate labels for X3_PRJNA453138
predictions_X3_PRJNA453138 = svm_PRJNA453138_init.predict(X3_PRJNA453138)
```

## Derive microclusters graphs

#### Lutomska ARC

```{python}
PRJNA847050_init = PRJNA847050[PRJNA847050.obs["train"]]
PRJNA847050_init.obs["subfunct_groups"] = 999
PRJNA847050_init.obs["subfunct_groups"][
    PRJNA847050_init.obs["train"]
    & (PRJNA847050_init.obs["bioproject"] == "PRJNA779749")
] = labels1
PRJNA847050_init.obs["subfunct_groups"][
    PRJNA847050_init.obs["train"]
    & (PRJNA847050_init.obs["bioproject"] == "PRJNA847050")
] = predictions_X3_PRJNA847050

PRJNA847050_train, PRJNA847050_test = (
    PRJNA847050.obsm["X_pca_harmony"][PRJNA847050.obs["train"]],
    PRJNA847050.obsm["X_pca_harmony"][PRJNA847050.obs["test"]],
)

PRJNA847050_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA847050_init.obs["subfunct_groups"].astype(str),
    categories=natsorted(
        map(str, np.unique(PRJNA847050_init.obs["subfunct_groups"].astype(str)))
    ),
)
```

```{python}
sc.pp.neighbors(
    PRJNA847050_init,
    n_neighbors=ks,
    use_rep="X_pca_harmony",
    metric=metric,
    knn=True,
    random_state=reseed,
)
```

```{python}
# derive knn graph
(
    knn_indices_PRJNA847050_init,
    knn_dists_PRJNA847050_init,
    knn_search_index_PRJNA847050_init,
) = nearest_neighbors(
    PRJNA847050_train,
    n_neighbors=k,
    metric=metric,
    metric_kwds={},
    angular=False,
    random_state=random_state,
    low_memory=True,
    use_pynndescent=True,
    n_jobs=threads,
    verbose=True,
)

# derive mutual nn graph
(
    connected_mnn_PRJNA847050_init,
    mutual_nn_PRJNA847050_init,
    new_knn_indices_PRJNA847050_init,
    new_knn_dists_PRJNA847050_init,
) = mutual_nn_nearest(
    knn_indices_PRJNA847050_init,
    knn_dists_PRJNA847050_init,
    k,
    ks,
    connectivity=connectivity_model,
    verbose=True,
)

# build fuzzy_simplicial_set
(
    G_PRJNA847050_init,
    sigmas_PRJNA847050_init,
    rhos_PRJNA847050_init,
) = fuzzy_simplicial_set(
    X=PRJNA847050_train,
    n_neighbors=ks,
    metric=metric,
    random_state=random_state,
    knn_indices=new_knn_indices_PRJNA847050_init,
    knn_dists=new_knn_dists_PRJNA847050_init,
)
```

```{python}
PRJNA847050_init.obsp["connectivities"] = ig.Graph.from_networkx(
    from_scipy_sparse_array(G_PRJNA847050_init)
).get_adjacency_sparse()
```

```{python}
PRJNA847050_init.obsp["distances"] = get_sparse_matrix_from_indices_distances_umap(
    new_knn_indices_PRJNA847050_init,
    new_knn_dists_PRJNA847050_init,
    PRJNA847050_init.n_obs,
    ks,
)
```

```{python}
sc.tl.paga(PRJNA847050_init, groups="subfunct_groups")
sc.pl.paga(
    PRJNA847050_init,
    threshold=paga_threshold,
    layout="fr",
    cmap="nipy_spectral",
    show=True,
    save=False,
    random_state=reseed,
)
```

```{python}
PRJNA847050_train_embeddings, PRJNA847050_train_aux_data = simplicial_set_embedding(
    data=PRJNA847050_train,
    graph=G_PRJNA847050_init,
    n_components=n_components,
    initial_alpha=1.0,
    a=a,
    b=b,
    gamma=5.0,
    negative_sample_rate=negative_sample_rate,
    n_epochs=500,
    init=get_init_pos_from_paga(
        adata=PRJNA847050_init, adjacency=G_PRJNA847050_init, random_state=reseed
    ),
    random_state=check_random_state(reseed),
    metric=metric,
    metric_kwds={},
    densmap=False,
    densmap_kwds={},
    output_dens=False,
    output_metric=dist.named_distances_with_gradients["euclidean"],
    output_metric_kwds={},
    euclidean_output=True,
    parallel=False,
    verbose=True,
)

PRJNA847050_init.obsm["X_umap"] = PRJNA847050_train_embeddings
```

```{python}
sc.pl.umap(
    PRJNA847050_init,
    color=["subfunct_groups"],
    frameon=False,
    show=True,
    save="-PRJNA847050_init_umap.pdf",
)
```

```{python}
paga_PRJNA847050_init = ig.Graph.from_networkx(
    from_scipy_sparse_array(PRJNA847050_init.uns["paga"]["connectivities"])
)
```

#### Pool MnPO

```{python}
PRJNA815819_init = PRJNA815819[PRJNA815819.obs["train"]]
PRJNA815819_init.obs["subfunct_groups"] = 999
PRJNA815819_init.obs["subfunct_groups"][
    PRJNA815819_init.obs["train"]
    & (PRJNA815819_init.obs["bioproject"] == "PRJNA779749")
] = labels1
PRJNA815819_init.obs["subfunct_groups"][
    PRJNA815819_init.obs["train"]
    & (PRJNA815819_init.obs["bioproject"] == "PRJNA815819")
] = predictions_X3_PRJNA815819

PRJNA815819_train, PRJNA815819_test = (
    PRJNA815819.obsm["X_pca_harmony"][PRJNA815819.obs["train"]],
    PRJNA815819.obsm["X_pca_harmony"][PRJNA815819.obs["test"]],
)

PRJNA815819_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA815819_init.obs["subfunct_groups"].astype(str),
    categories=natsorted(
        map(str, np.unique(PRJNA815819_init.obs["subfunct_groups"].astype(str)))
    ),
)
```

```{python}
sc.pp.neighbors(
    PRJNA815819_init,
    n_neighbors=ks,
    use_rep="X_pca_harmony",
    metric=metric,
    knn=True,
    random_state=reseed,
)
```

```{python}
# derive knn graph
(
    knn_indices_PRJNA815819_init,
    knn_dists_PRJNA815819_init,
    knn_search_index_PRJNA815819_init,
) = nearest_neighbors(
    PRJNA815819_train,
    n_neighbors=k,
    metric=metric,
    metric_kwds={},
    angular=False,
    random_state=random_state,
    low_memory=True,
    use_pynndescent=True,
    n_jobs=threads,
    verbose=True,
)

# derive mutual nn graph
(
    connected_mnn_PRJNA815819_init,
    mutual_nn_PRJNA815819_init,
    new_knn_indices_PRJNA815819_init,
    new_knn_dists_PRJNA815819_init,
) = mutual_nn_nearest(
    knn_indices_PRJNA815819_init,
    knn_dists_PRJNA815819_init,
    k,
    ks,
    connectivity=connectivity_model,
    verbose=True,
)

# build fuzzy_simplicial_set
(
    G_PRJNA815819_init,
    sigmas_PRJNA815819_init,
    rhos_PRJNA815819_init,
) = fuzzy_simplicial_set(
    X=PRJNA815819_train,
    n_neighbors=ks,
    metric=metric,
    random_state=random_state,
    knn_indices=new_knn_indices_PRJNA815819_init,
    knn_dists=new_knn_dists_PRJNA815819_init,
)
```

```{python}
PRJNA815819_init.obsp["connectivities"] = ig.Graph.from_networkx(
    from_scipy_sparse_array(G_PRJNA815819_init)
).get_adjacency_sparse()
```

```{python}
PRJNA815819_init.obsp["distances"] = get_sparse_matrix_from_indices_distances_umap(
    new_knn_indices_PRJNA815819_init,
    new_knn_dists_PRJNA815819_init,
    PRJNA815819_init.n_obs,
    ks,
)
```

```{python}
sc.tl.paga(PRJNA815819_init, groups="subfunct_groups")
sc.pl.paga(
    PRJNA815819_init,
    threshold=paga_threshold,
    layout="fr",
    cmap="nipy_spectral",
    show=True,
    save=False,
    random_state=reseed,
)
```

```{python}
PRJNA815819_train_embeddings, PRJNA815819_train_aux_data = simplicial_set_embedding(
    data=PRJNA815819_train,
    graph=G_PRJNA815819_init,
    n_components=n_components,
    initial_alpha=1.0,
    a=a,
    b=b,
    gamma=5.0,
    negative_sample_rate=negative_sample_rate,
    n_epochs=500,
    init=get_init_pos_from_paga(
        adata=PRJNA815819_init, adjacency=G_PRJNA815819_init, random_state=reseed
    ),
    random_state=check_random_state(reseed),
    metric=metric,
    metric_kwds={},
    densmap=False,
    densmap_kwds={},
    output_dens=False,
    output_metric=dist.named_distances_with_gradients["euclidean"],
    output_metric_kwds={},
    euclidean_output=True,
    parallel=False,
    verbose=True,
)

PRJNA815819_init.obsm["X_umap"] = PRJNA815819_train_embeddings
```

```{python}
sc.pl.umap(
    PRJNA815819_init,
    color=["subfunct_groups"],
    frameon=False,
    show=True,
    save="-PRJNA815819_init_umap.pdf",
)
```

```{python}
paga_PRJNA815819_init = ig.Graph.from_networkx(
    from_scipy_sparse_array(PRJNA815819_init.uns["paga"]["connectivities"])
)
```

#### Liu VMHvl

```{python}
PRJNA798401_init = PRJNA798401[PRJNA798401.obs["train"]]
PRJNA798401_init.obs["subfunct_groups"] = 999
PRJNA798401_init.obs["subfunct_groups"][
    PRJNA798401_init.obs["train"]
    & (PRJNA798401_init.obs["bioproject"] == "PRJNA779749")
] = labels1
PRJNA798401_init.obs["subfunct_groups"][
    PRJNA798401_init.obs["train"]
    & (PRJNA798401_init.obs["bioproject"] == "PRJNA798401")
] = predictions_X3_PRJNA798401

PRJNA798401_train, PRJNA798401_test = (
    PRJNA798401.obsm["X_pca_harmony"][PRJNA798401.obs["train"]],
    PRJNA798401.obsm["X_pca_harmony"][PRJNA798401.obs["test"]],
)

PRJNA798401_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA798401_init.obs["subfunct_groups"].astype(str),
    categories=natsorted(
        map(str, np.unique(PRJNA798401_init.obs["subfunct_groups"].astype(str)))
    ),
)
```

```{python}
sc.pp.neighbors(
    PRJNA798401_init,
    n_neighbors=ks,
    use_rep="X_pca_harmony",
    metric=metric,
    knn=True,
    random_state=reseed,
)
```

```{python}
# derive knn graph
(
    knn_indices_PRJNA798401_init,
    knn_dists_PRJNA798401_init,
    knn_search_index_PRJNA798401_init,
) = nearest_neighbors(
    PRJNA798401_train,
    n_neighbors=k,
    metric=metric,
    metric_kwds={},
    angular=False,
    random_state=random_state,
    low_memory=True,
    use_pynndescent=True,
    n_jobs=threads,
    verbose=True,
)

# derive mutual nn graph
(
    connected_mnn_PRJNA798401_init,
    mutual_nn_PRJNA798401_init,
    new_knn_indices_PRJNA798401_init,
    new_knn_dists_PRJNA798401_init,
) = mutual_nn_nearest(
    knn_indices_PRJNA798401_init,
    knn_dists_PRJNA798401_init,
    k,
    ks,
    connectivity=connectivity_model,
    verbose=True,
)

# build fuzzy_simplicial_set
(
    G_PRJNA798401_init,
    sigmas_PRJNA798401_init,
    rhos_PRJNA798401_init,
) = fuzzy_simplicial_set(
    X=PRJNA798401_train,
    n_neighbors=ks,
    metric=metric,
    random_state=random_state,
    knn_indices=new_knn_indices_PRJNA798401_init,
    knn_dists=new_knn_dists_PRJNA798401_init,
)
```

```{python}
PRJNA798401_init.obsp["connectivities"] = ig.Graph.from_networkx(
    from_scipy_sparse_array(G_PRJNA798401_init)
).get_adjacency_sparse()
```

```{python}
PRJNA798401_init.obsp["distances"] = get_sparse_matrix_from_indices_distances_umap(
    new_knn_indices_PRJNA798401_init,
    new_knn_dists_PRJNA798401_init,
    PRJNA798401_init.n_obs,
    ks,
)
```

```{python}
sc.tl.paga(PRJNA798401_init, groups="subfunct_groups")
sc.pl.paga(
    PRJNA798401_init,
    threshold=paga_threshold,
    layout="fr",
    cmap="nipy_spectral",
    show=True,
    save=False,
    random_state=reseed,
)
```

```{python}
PRJNA798401_train_embeddings, PRJNA798401_train_aux_data = simplicial_set_embedding(
    data=PRJNA798401_train,
    graph=G_PRJNA798401_init,
    n_components=n_components,
    initial_alpha=1.0,
    a=a,
    b=b,
    gamma=5.0,
    negative_sample_rate=negative_sample_rate,
    n_epochs=500,
    init=get_init_pos_from_paga(
        adata=PRJNA798401_init, adjacency=G_PRJNA798401_init, random_state=reseed
    ),
    random_state=check_random_state(reseed),
    metric=metric,
    metric_kwds={},
    densmap=False,
    densmap_kwds={},
    output_dens=False,
    output_metric=dist.named_distances_with_gradients["euclidean"],
    output_metric_kwds={},
    euclidean_output=True,
    parallel=False,
    verbose=True,
)

PRJNA798401_init.obsm["X_umap"] = PRJNA798401_train_embeddings
```

```{python}
sc.pl.umap(
    PRJNA798401_init,
    color=["subfunct_groups"],
    frameon=False,
    show=True,
    save="-PRJNA798401_init_umap.pdf",
)
```

```{python}
paga_PRJNA798401_init = ig.Graph.from_networkx(
    from_scipy_sparse_array(PRJNA798401_init.uns["paga"]["connectivities"])
)
```

#### Rupp MBH

```{python}
PRJNA723345_init = PRJNA723345[PRJNA723345.obs["train"]]
PRJNA723345_init.obs["subfunct_groups"] = 999
PRJNA723345_init.obs["subfunct_groups"][
    PRJNA723345_init.obs["train"]
    & (PRJNA723345_init.obs["bioproject"] == "PRJNA779749")
] = labels1
PRJNA723345_init.obs["subfunct_groups"][
    PRJNA723345_init.obs["train"]
    & (PRJNA723345_init.obs["bioproject"] == "PRJNA723345")
] = predictions_X3_PRJNA723345

PRJNA723345_train, PRJNA723345_test = (
    PRJNA723345.obsm["X_pca_harmony"][PRJNA723345.obs["train"]],
    PRJNA723345.obsm["X_pca_harmony"][PRJNA723345.obs["test"]],
)

PRJNA723345_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA723345_init.obs["subfunct_groups"].astype(str),
    categories=natsorted(
        map(str, np.unique(PRJNA723345_init.obs["subfunct_groups"].astype(str)))
    ),
)
```

```{python}
sc.pp.neighbors(
    PRJNA723345_init,
    n_neighbors=ks,
    use_rep="X_pca_harmony",
    metric=metric,
    knn=True,
    random_state=reseed,
)
```

```{python}
# derive knn graph
(
    knn_indices_PRJNA723345_init,
    knn_dists_PRJNA723345_init,
    knn_search_index_PRJNA723345_init,
) = nearest_neighbors(
    PRJNA723345_train,
    n_neighbors=k,
    metric=metric,
    metric_kwds={},
    angular=False,
    random_state=random_state,
    low_memory=True,
    use_pynndescent=True,
    n_jobs=threads,
    verbose=True,
)

# derive mutual nn graph
(
    connected_mnn_PRJNA723345_init,
    mutual_nn_PRJNA723345_init,
    new_knn_indices_PRJNA723345_init,
    new_knn_dists_PRJNA723345_init,
) = mutual_nn_nearest(
    knn_indices_PRJNA723345_init,
    knn_dists_PRJNA723345_init,
    k,
    ks,
    connectivity=connectivity_model,
    verbose=True,
)

# build fuzzy_simplicial_set
(
    G_PRJNA723345_init,
    sigmas_PRJNA723345_init,
    rhos_PRJNA723345_init,
) = fuzzy_simplicial_set(
    X=PRJNA723345_train,
    n_neighbors=ks,
    metric=metric,
    random_state=random_state,
    knn_indices=new_knn_indices_PRJNA723345_init,
    knn_dists=new_knn_dists_PRJNA723345_init,
)
```

```{python}
PRJNA723345_init.obsp["connectivities"] = ig.Graph.from_networkx(
    from_scipy_sparse_array(G_PRJNA723345_init)
).get_adjacency_sparse()
```

```{python}
PRJNA723345_init.obsp["distances"] = get_sparse_matrix_from_indices_distances_umap(
    new_knn_indices_PRJNA723345_init,
    new_knn_dists_PRJNA723345_init,
    PRJNA723345_init.n_obs,
    ks,
)
```

```{python}
sc.tl.paga(PRJNA723345_init, groups="subfunct_groups")
sc.pl.paga(
    PRJNA723345_init,
    threshold=paga_threshold,
    layout="fr",
    cmap="nipy_spectral",
    show=True,
    save=False,
    random_state=reseed,
)
```

```{python}
PRJNA723345_train_embeddings, PRJNA723345_train_aux_data = simplicial_set_embedding(
    data=PRJNA723345_train,
    graph=G_PRJNA723345_init,
    n_components=n_components,
    initial_alpha=1.0,
    a=a,
    b=b,
    gamma=5.0,
    negative_sample_rate=negative_sample_rate,
    n_epochs=500,
    init=get_init_pos_from_paga(
        adata=PRJNA723345_init, adjacency=G_PRJNA723345_init, random_state=reseed
    ),
    random_state=check_random_state(reseed),
    metric=metric,
    metric_kwds={},
    densmap=False,
    densmap_kwds={},
    output_dens=False,
    output_metric=dist.named_distances_with_gradients["euclidean"],
    output_metric_kwds={},
    euclidean_output=True,
    parallel=False,
    verbose=True,
)

PRJNA723345_init.obsm["X_umap"] = PRJNA723345_train_embeddings
```

```{python}
sc.pl.umap(
    PRJNA723345_init,
    color=["subfunct_groups"],
    frameon=False,
    show=True,
    save="-PRJNA723345_init_umap.pdf",
)
```

```{python}
paga_PRJNA723345_init = ig.Graph.from_networkx(
    from_scipy_sparse_array(PRJNA723345_init.uns["paga"]["connectivities"])
)
```

#### Affinati VMH

```{python}
PRJNA722418_init = PRJNA722418[PRJNA722418.obs["train"]]
PRJNA722418_init.obs["subfunct_groups"] = 999
PRJNA722418_init.obs["subfunct_groups"][
    PRJNA722418_init.obs["train"]
    & (PRJNA722418_init.obs["bioproject"] == "PRJNA779749")
] = labels1
PRJNA722418_init.obs["subfunct_groups"][
    PRJNA722418_init.obs["train"]
    & (PRJNA722418_init.obs["bioproject"] == "PRJNA722418")
] = predictions_X3_PRJNA722418

PRJNA722418_train, PRJNA722418_test = (
    PRJNA722418.obsm["X_pca_harmony"][PRJNA722418.obs["train"]],
    PRJNA722418.obsm["X_pca_harmony"][PRJNA722418.obs["test"]],
)

PRJNA722418_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA722418_init.obs["subfunct_groups"].astype(str),
    categories=natsorted(
        map(str, np.unique(PRJNA722418_init.obs["subfunct_groups"].astype(str)))
    ),
)
```

```{python}
sc.pp.neighbors(
    PRJNA722418_init,
    n_neighbors=ks,
    use_rep="X_pca_harmony",
    metric=metric,
    knn=True,
    random_state=reseed,
)
```

```{python}
# derive knn graph
(
    knn_indices_PRJNA722418_init,
    knn_dists_PRJNA722418_init,
    knn_search_index_PRJNA722418_init,
) = nearest_neighbors(
    PRJNA722418_train,
    n_neighbors=k,
    metric=metric,
    metric_kwds={},
    angular=False,
    random_state=random_state,
    low_memory=True,
    use_pynndescent=True,
    n_jobs=threads,
    verbose=True,
)

# derive mutual nn graph
(
    connected_mnn_PRJNA722418_init,
    mutual_nn_PRJNA722418_init,
    new_knn_indices_PRJNA722418_init,
    new_knn_dists_PRJNA722418_init,
) = mutual_nn_nearest(
    knn_indices_PRJNA722418_init,
    knn_dists_PRJNA722418_init,
    k,
    ks,
    connectivity=connectivity_model,
    verbose=True,
)

# build fuzzy_simplicial_set
(
    G_PRJNA722418_init,
    sigmas_PRJNA722418_init,
    rhos_PRJNA722418_init,
) = fuzzy_simplicial_set(
    X=PRJNA722418_train,
    n_neighbors=ks,
    metric=metric,
    random_state=random_state,
    knn_indices=new_knn_indices_PRJNA722418_init,
    knn_dists=new_knn_dists_PRJNA722418_init,
)
```

```{python}
PRJNA722418_init.obsp["connectivities"] = ig.Graph.from_networkx(
    from_scipy_sparse_array(G_PRJNA722418_init)
).get_adjacency_sparse()
```

```{python}
PRJNA722418_init.obsp["distances"] = get_sparse_matrix_from_indices_distances_umap(
    new_knn_indices_PRJNA722418_init,
    new_knn_dists_PRJNA722418_init,
    PRJNA722418_init.n_obs,
    ks,
)
```

```{python}
sc.tl.paga(PRJNA722418_init, groups="subfunct_groups")
sc.pl.paga(
    PRJNA722418_init,
    threshold=paga_threshold,
    layout="fr",
    cmap="nipy_spectral",
    show=True,
    save=False,
    random_state=reseed,
)
```

```{python}
PRJNA722418_train_embeddings, PRJNA722418_train_aux_data = simplicial_set_embedding(
    data=PRJNA722418_train,
    graph=G_PRJNA722418_init,
    n_components=n_components,
    initial_alpha=1.0,
    a=a,
    b=b,
    gamma=5.0,
    negative_sample_rate=negative_sample_rate,
    n_epochs=500,
    init=get_init_pos_from_paga(
        adata=PRJNA722418_init, adjacency=G_PRJNA722418_init, random_state=reseed
    ),
    random_state=check_random_state(reseed),
    metric=metric,
    metric_kwds={},
    densmap=False,
    densmap_kwds={},
    output_dens=False,
    output_metric=dist.named_distances_with_gradients["euclidean"],
    output_metric_kwds={},
    euclidean_output=True,
    parallel=False,
    verbose=True,
)

PRJNA722418_init.obsm["X_umap"] = PRJNA722418_train_embeddings
```

```{python}
sc.pl.umap(
    PRJNA722418_init,
    color=["subfunct_groups"],
    frameon=False,
    show=True,
    save="-PRJNA722418_init_umap.pdf",
)
```

```{python}
paga_PRJNA722418_init = ig.Graph.from_networkx(
    from_scipy_sparse_array(PRJNA722418_init.uns["paga"]["connectivities"])
)
```

#### Morris SCN

```{python}
PRJNA705596_init = PRJNA705596[PRJNA705596.obs["train"]]
PRJNA705596_init.obs["subfunct_groups"] = 999
PRJNA705596_init.obs["subfunct_groups"][
    PRJNA705596_init.obs["train"]
    & (PRJNA705596_init.obs["bioproject"] == "PRJNA779749")
] = labels1
PRJNA705596_init.obs["subfunct_groups"][
    PRJNA705596_init.obs["train"]
    & (PRJNA705596_init.obs["bioproject"] == "PRJNA705596")
] = predictions_X3_PRJNA705596

PRJNA705596_train, PRJNA705596_test = (
    PRJNA705596.obsm["X_pca_harmony"][PRJNA705596.obs["train"]],
    PRJNA705596.obsm["X_pca_harmony"][PRJNA705596.obs["test"]],
)

PRJNA705596_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA705596_init.obs["subfunct_groups"].astype(str),
    categories=natsorted(
        map(str, np.unique(PRJNA705596_init.obs["subfunct_groups"].astype(str)))
    ),
)
```

```{python}
sc.pp.neighbors(
    PRJNA705596_init,
    n_neighbors=ks,
    use_rep="X_pca_harmony",
    metric=metric,
    knn=True,
    random_state=reseed,
)
```

```{python}
# derive knn graph
(
    knn_indices_PRJNA705596_init,
    knn_dists_PRJNA705596_init,
    knn_search_index_PRJNA705596_init,
) = nearest_neighbors(
    PRJNA705596_train,
    n_neighbors=k,
    metric=metric,
    metric_kwds={},
    angular=False,
    random_state=random_state,
    low_memory=True,
    use_pynndescent=True,
    n_jobs=threads,
    verbose=True,
)

# derive mutual nn graph
(
    connected_mnn_PRJNA705596_init,
    mutual_nn_PRJNA705596_init,
    new_knn_indices_PRJNA705596_init,
    new_knn_dists_PRJNA705596_init,
) = mutual_nn_nearest(
    knn_indices_PRJNA705596_init,
    knn_dists_PRJNA705596_init,
    k,
    ks,
    connectivity=connectivity_model,
    verbose=True,
)

# build fuzzy_simplicial_set
(
    G_PRJNA705596_init,
    sigmas_PRJNA705596_init,
    rhos_PRJNA705596_init,
) = fuzzy_simplicial_set(
    X=PRJNA705596_train,
    n_neighbors=ks,
    metric=metric,
    random_state=random_state,
    knn_indices=new_knn_indices_PRJNA705596_init,
    knn_dists=new_knn_dists_PRJNA705596_init,
)
```

```{python}
PRJNA705596_init.obsp["connectivities"] = ig.Graph.from_networkx(
    from_scipy_sparse_array(G_PRJNA705596_init)
).get_adjacency_sparse()
```

```{python}
PRJNA705596_init.obsp["distances"] = get_sparse_matrix_from_indices_distances_umap(
    new_knn_indices_PRJNA705596_init,
    new_knn_dists_PRJNA705596_init,
    PRJNA705596_init.n_obs,
    ks,
)
```

```{python}
sc.tl.paga(PRJNA705596_init, groups="subfunct_groups")
sc.pl.paga(
    PRJNA705596_init,
    threshold=paga_threshold,
    layout="fr",
    cmap="nipy_spectral",
    show=True,
    save=False,
    random_state=reseed,
)
```

```{python}
PRJNA705596_train_embeddings, PRJNA705596_train_aux_data = simplicial_set_embedding(
    data=PRJNA705596_train,
    graph=G_PRJNA705596_init,
    n_components=n_components,
    initial_alpha=1.0,
    a=a,
    b=b,
    gamma=5.0,
    negative_sample_rate=negative_sample_rate,
    n_epochs=500,
    init=get_init_pos_from_paga(
        adata=PRJNA705596_init, adjacency=G_PRJNA705596_init, random_state=reseed
    ),
    random_state=check_random_state(reseed),
    metric=metric,
    metric_kwds={},
    densmap=False,
    densmap_kwds={},
    output_dens=False,
    output_metric=dist.named_distances_with_gradients["euclidean"],
    output_metric_kwds={},
    euclidean_output=True,
    parallel=False,
    verbose=True,
)

PRJNA705596_init.obsm["X_umap"] = PRJNA705596_train_embeddings
```

```{python}
sc.pl.umap(
    PRJNA705596_init,
    color=["subfunct_groups"],
    frameon=False,
    show=True,
    save="-PRJNA705596_init_umap.pdf",
)
```

```{python}
paga_PRJNA705596_init = ig.Graph.from_networkx(
    from_scipy_sparse_array(PRJNA705596_init.uns["paga"]["connectivities"])
)
```

#### Lopez PVN

```{python}
PRJNA679294_init = PRJNA679294[PRJNA679294.obs["train"]]
PRJNA679294_init.obs["subfunct_groups"] = 999
PRJNA679294_init.obs["subfunct_groups"][
    PRJNA679294_init.obs["train"]
    & (PRJNA679294_init.obs["bioproject"] == "PRJNA779749")
] = labels1
PRJNA679294_init.obs["subfunct_groups"][
    PRJNA679294_init.obs["train"]
    & (PRJNA679294_init.obs["bioproject"] == "PRJNA679294")
] = predictions_X3_PRJNA679294

PRJNA679294_train, PRJNA679294_test = (
    PRJNA679294.obsm["X_pca_harmony"][PRJNA679294.obs["train"]],
    PRJNA679294.obsm["X_pca_harmony"][PRJNA679294.obs["test"]],
)

PRJNA679294_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA679294_init.obs["subfunct_groups"].astype(str),
    categories=natsorted(
        map(str, np.unique(PRJNA679294_init.obs["subfunct_groups"].astype(str)))
    ),
)
```

```{python}
sc.pp.neighbors(
    PRJNA679294_init,
    n_neighbors=ks,
    use_rep="X_pca_harmony",
    metric=metric,
    knn=True,
    random_state=reseed,
)
```

```{python}
# derive knn graph
(
    knn_indices_PRJNA679294_init,
    knn_dists_PRJNA679294_init,
    knn_search_index_PRJNA679294_init,
) = nearest_neighbors(
    PRJNA679294_train,
    n_neighbors=k,
    metric=metric,
    metric_kwds={},
    angular=False,
    random_state=random_state,
    low_memory=True,
    use_pynndescent=True,
    n_jobs=threads,
    verbose=True,
)

# derive mutual nn graph
(
    connected_mnn_PRJNA679294_init,
    mutual_nn_PRJNA679294_init,
    new_knn_indices_PRJNA679294_init,
    new_knn_dists_PRJNA679294_init,
) = mutual_nn_nearest(
    knn_indices_PRJNA679294_init,
    knn_dists_PRJNA679294_init,
    k,
    ks,
    connectivity=connectivity_model,
    verbose=True,
)

# build fuzzy_simplicial_set
(
    G_PRJNA679294_init,
    sigmas_PRJNA679294_init,
    rhos_PRJNA679294_init,
) = fuzzy_simplicial_set(
    X=PRJNA679294_train,
    n_neighbors=ks,
    metric=metric,
    random_state=random_state,
    knn_indices=new_knn_indices_PRJNA679294_init,
    knn_dists=new_knn_dists_PRJNA679294_init,
)
```

```{python}
PRJNA679294_init.obsp["connectivities"] = ig.Graph.from_networkx(
    from_scipy_sparse_array(G_PRJNA679294_init)
).get_adjacency_sparse()
```

```{python}
PRJNA679294_init.obsp["distances"] = get_sparse_matrix_from_indices_distances_umap(
    new_knn_indices_PRJNA679294_init,
    new_knn_dists_PRJNA679294_init,
    PRJNA679294_init.n_obs,
    ks,
)
```

```{python}
sc.tl.paga(PRJNA679294_init, groups="subfunct_groups")
sc.pl.paga(
    PRJNA679294_init,
    threshold=paga_threshold,
    layout="fr",
    cmap="nipy_spectral",
    show=True,
    save=False,
    random_state=reseed,
)
```

```{python}
PRJNA679294_train_embeddings, PRJNA679294_train_aux_data = simplicial_set_embedding(
    data=PRJNA679294_train,
    graph=G_PRJNA679294_init,
    n_components=n_components,
    initial_alpha=1.0,
    a=a,
    b=b,
    gamma=5.0,
    negative_sample_rate=negative_sample_rate,
    n_epochs=500,
    init=get_init_pos_from_paga(
        adata=PRJNA679294_init, adjacency=G_PRJNA679294_init, random_state=reseed
    ),
    random_state=check_random_state(reseed),
    metric=metric,
    metric_kwds={},
    densmap=False,
    densmap_kwds={},
    output_dens=False,
    output_metric=dist.named_distances_with_gradients["euclidean"],
    output_metric_kwds={},
    euclidean_output=True,
    parallel=False,
    verbose=True,
)

PRJNA679294_init.obsm["X_umap"] = PRJNA679294_train_embeddings
```

```{python}
sc.pl.umap(
    PRJNA679294_init,
    color=["subfunct_groups"],
    frameon=False,
    show=True,
    save="-PRJNA679294_init_umap.pdf",
)
```

```{python}
paga_PRJNA679294_init = ig.Graph.from_networkx(
    from_scipy_sparse_array(PRJNA679294_init.uns["paga"]["connectivities"])
)
```

#### Mickelsen VPH

```{python}
PRJNA611624_init = PRJNA611624[PRJNA611624.obs["train"]]
PRJNA611624_init.obs["subfunct_groups"] = 999
PRJNA611624_init.obs["subfunct_groups"][
    PRJNA611624_init.obs["train"]
    & (PRJNA611624_init.obs["bioproject"] == "PRJNA779749")
] = labels1
PRJNA611624_init.obs["subfunct_groups"][
    PRJNA611624_init.obs["train"]
    & (PRJNA611624_init.obs["bioproject"] == "PRJNA611624")
] = predictions_X3_PRJNA611624

PRJNA611624_train, PRJNA611624_test = (
    PRJNA611624.obsm["X_pca_harmony"][PRJNA611624.obs["train"]],
    PRJNA611624.obsm["X_pca_harmony"][PRJNA611624.obs["test"]],
)

PRJNA611624_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA611624_init.obs["subfunct_groups"].astype(str),
    categories=natsorted(
        map(str, np.unique(PRJNA611624_init.obs["subfunct_groups"].astype(str)))
    ),
)
```

```{python}
sc.pp.neighbors(
    PRJNA611624_init,
    n_neighbors=ks,
    use_rep="X_pca_harmony",
    metric=metric,
    knn=True,
    random_state=reseed,
)
```

```{python}
# derive knn graph
(
    knn_indices_PRJNA611624_init,
    knn_dists_PRJNA611624_init,
    knn_search_index_PRJNA611624_init,
) = nearest_neighbors(
    PRJNA611624_train,
    n_neighbors=k,
    metric=metric,
    metric_kwds={},
    angular=False,
    random_state=random_state,
    low_memory=True,
    use_pynndescent=True,
    n_jobs=threads,
    verbose=True,
)

# derive mutual nn graph
(
    connected_mnn_PRJNA611624_init,
    mutual_nn_PRJNA611624_init,
    new_knn_indices_PRJNA611624_init,
    new_knn_dists_PRJNA611624_init,
) = mutual_nn_nearest(
    knn_indices_PRJNA611624_init,
    knn_dists_PRJNA611624_init,
    k,
    ks,
    connectivity=connectivity_model,
    verbose=True,
)

# build fuzzy_simplicial_set
(
    G_PRJNA611624_init,
    sigmas_PRJNA611624_init,
    rhos_PRJNA611624_init,
) = fuzzy_simplicial_set(
    X=PRJNA611624_train,
    n_neighbors=ks,
    metric=metric,
    random_state=random_state,
    knn_indices=new_knn_indices_PRJNA611624_init,
    knn_dists=new_knn_dists_PRJNA611624_init,
)
```

```{python}
PRJNA611624_init.obsp["connectivities"] = ig.Graph.from_networkx(
    from_scipy_sparse_array(G_PRJNA611624_init)
).get_adjacency_sparse()
```

```{python}
PRJNA611624_init.obsp["distances"] = get_sparse_matrix_from_indices_distances_umap(
    new_knn_indices_PRJNA611624_init,
    new_knn_dists_PRJNA611624_init,
    PRJNA611624_init.n_obs,
    ks,
)
```

```{python}
sc.tl.paga(PRJNA611624_init, groups="subfunct_groups")
sc.pl.paga(
    PRJNA611624_init,
    threshold=paga_threshold,
    layout="fr",
    cmap="nipy_spectral",
    show=True,
    save=False,
    random_state=reseed,
)
```

```{python}
PRJNA611624_train_embeddings, PRJNA611624_train_aux_data = simplicial_set_embedding(
    data=PRJNA611624_train,
    graph=G_PRJNA611624_init,
    n_components=n_components,
    initial_alpha=1.0,
    a=a,
    b=b,
    gamma=5.0,
    negative_sample_rate=negative_sample_rate,
    n_epochs=500,
    init=get_init_pos_from_paga(
        adata=PRJNA611624_init, adjacency=G_PRJNA611624_init, random_state=reseed
    ),
    random_state=check_random_state(reseed),
    metric=metric,
    metric_kwds={},
    densmap=False,
    densmap_kwds={},
    output_dens=False,
    output_metric=dist.named_distances_with_gradients["euclidean"],
    output_metric_kwds={},
    euclidean_output=True,
    parallel=False,
    verbose=True,
)

PRJNA611624_init.obsm["X_umap"] = PRJNA611624_train_embeddings
```

```{python}
sc.pl.umap(
    PRJNA611624_init,
    color=["subfunct_groups"],
    frameon=False,
    show=True,
    save="-PRJNA611624_init_umap.pdf",
)
```

```{python}
paga_PRJNA611624_init = ig.Graph.from_networkx(
    from_scipy_sparse_array(PRJNA611624_init.uns["paga"]["connectivities"])
)
```

#### Deng ARC

```{python}
PRJNA604055_init = PRJNA604055[PRJNA604055.obs["train"]]
PRJNA604055_init.obs["subfunct_groups"] = 999
PRJNA604055_init.obs["subfunct_groups"][
    PRJNA604055_init.obs["train"]
    & (PRJNA604055_init.obs["bioproject"] == "PRJNA779749")
] = labels1
PRJNA604055_init.obs["subfunct_groups"][
    PRJNA604055_init.obs["train"]
    & (PRJNA604055_init.obs["bioproject"] == "PRJNA604055")
] = predictions_X3_PRJNA604055

PRJNA604055_train, PRJNA604055_test = (
    PRJNA604055.obsm["X_pca_harmony"][PRJNA604055.obs["train"]],
    PRJNA604055.obsm["X_pca_harmony"][PRJNA604055.obs["test"]],
)

PRJNA604055_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA604055_init.obs["subfunct_groups"].astype(str),
    categories=natsorted(
        map(str, np.unique(PRJNA604055_init.obs["subfunct_groups"].astype(str)))
    ),
)
```

```{python}
sc.pp.neighbors(
    PRJNA604055_init,
    n_neighbors=ks,
    use_rep="X_pca_harmony",
    metric=metric,
    knn=True,
    random_state=reseed,
)
```

```{python}
# derive knn graph
(
    knn_indices_PRJNA604055_init,
    knn_dists_PRJNA604055_init,
    knn_search_index_PRJNA604055_init,
) = nearest_neighbors(
    PRJNA604055_train,
    n_neighbors=k,
    metric=metric,
    metric_kwds={},
    angular=False,
    random_state=random_state,
    low_memory=True,
    use_pynndescent=True,
    n_jobs=threads,
    verbose=True,
)

# derive mutual nn graph
(
    connected_mnn_PRJNA604055_init,
    mutual_nn_PRJNA604055_init,
    new_knn_indices_PRJNA604055_init,
    new_knn_dists_PRJNA604055_init,
) = mutual_nn_nearest(
    knn_indices_PRJNA604055_init,
    knn_dists_PRJNA604055_init,
    k,
    ks,
    connectivity=connectivity_model,
    verbose=True,
)

# build fuzzy_simplicial_set
(
    G_PRJNA604055_init,
    sigmas_PRJNA604055_init,
    rhos_PRJNA604055_init,
) = fuzzy_simplicial_set(
    X=PRJNA604055_train,
    n_neighbors=ks,
    metric=metric,
    random_state=random_state,
    knn_indices=new_knn_indices_PRJNA604055_init,
    knn_dists=new_knn_dists_PRJNA604055_init,
)
```

```{python}
PRJNA604055_init.obsp["connectivities"] = ig.Graph.from_networkx(
    from_scipy_sparse_array(G_PRJNA604055_init)
).get_adjacency_sparse()
```

```{python}
PRJNA604055_init.obsp["distances"] = get_sparse_matrix_from_indices_distances_umap(
    new_knn_indices_PRJNA604055_init,
    new_knn_dists_PRJNA604055_init,
    PRJNA604055_init.n_obs,
    ks,
)
```

```{python}
sc.tl.paga(PRJNA604055_init, groups="subfunct_groups")
sc.pl.paga(
    PRJNA604055_init,
    threshold=paga_threshold,
    layout="fr",
    cmap="nipy_spectral",
    show=True,
    save=False,
    random_state=reseed,
)
```

```{python}
PRJNA604055_train_embeddings, PRJNA604055_train_aux_data = simplicial_set_embedding(
    data=PRJNA604055_train,
    graph=G_PRJNA604055_init,
    n_components=n_components,
    initial_alpha=1.0,
    a=a,
    b=b,
    gamma=5.0,
    negative_sample_rate=negative_sample_rate,
    n_epochs=500,
    init=get_init_pos_from_paga(
        adata=PRJNA604055_init, adjacency=G_PRJNA604055_init, random_state=reseed
    ),
    random_state=check_random_state(reseed),
    metric=metric,
    metric_kwds={},
    densmap=False,
    densmap_kwds={},
    output_dens=False,
    output_metric=dist.named_distances_with_gradients["euclidean"],
    output_metric_kwds={},
    euclidean_output=True,
    parallel=False,
    verbose=True,
)

PRJNA604055_init.obsm["X_umap"] = PRJNA604055_train_embeddings
```

```{python}
sc.pl.umap(
    PRJNA604055_init,
    color=["subfunct_groups"],
    frameon=False,
    show=True,
    save="-PRJNA604055_init_umap.pdf",
)
```

```{python}
paga_PRJNA604055_init = ig.Graph.from_networkx(
    from_scipy_sparse_array(PRJNA604055_init.uns["paga"]["connectivities"])
)
```

#### Wen SCN

```{python}
PRJNA548532_init = PRJNA548532[PRJNA548532.obs["train"]]
PRJNA548532_init.obs["subfunct_groups"] = 999
PRJNA548532_init.obs["subfunct_groups"][
    PRJNA548532_init.obs["train"]
    & (PRJNA548532_init.obs["bioproject"] == "PRJNA779749")
] = labels1
PRJNA548532_init.obs["subfunct_groups"][
    PRJNA548532_init.obs["train"]
    & (PRJNA548532_init.obs["bioproject"] == "PRJNA548532")
] = predictions_X3_PRJNA548532

PRJNA548532_train, PRJNA548532_test = (
    PRJNA548532.obsm["X_pca_harmony"][PRJNA548532.obs["train"]],
    PRJNA548532.obsm["X_pca_harmony"][PRJNA548532.obs["test"]],
)

PRJNA548532_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA548532_init.obs["subfunct_groups"].astype(str),
    categories=natsorted(
        map(str, np.unique(PRJNA548532_init.obs["subfunct_groups"].astype(str)))
    ),
)
```

```{python}
sc.pp.neighbors(
    PRJNA548532_init,
    n_neighbors=ks,
    use_rep="X_pca_harmony",
    metric=metric,
    knn=True,
    random_state=reseed,
)
```

```{python}
# derive knn graph
(
    knn_indices_PRJNA548532_init,
    knn_dists_PRJNA548532_init,
    knn_search_index_PRJNA548532_init,
) = nearest_neighbors(
    PRJNA548532_train,
    n_neighbors=k,
    metric=metric,
    metric_kwds={},
    angular=False,
    random_state=random_state,
    low_memory=True,
    use_pynndescent=True,
    n_jobs=threads,
    verbose=True,
)

# derive mutual nn graph
(
    connected_mnn_PRJNA548532_init,
    mutual_nn_PRJNA548532_init,
    new_knn_indices_PRJNA548532_init,
    new_knn_dists_PRJNA548532_init,
) = mutual_nn_nearest(
    knn_indices_PRJNA548532_init,
    knn_dists_PRJNA548532_init,
    k,
    ks,
    connectivity=connectivity_model,
    verbose=True,
)

# build fuzzy_simplicial_set
(
    G_PRJNA548532_init,
    sigmas_PRJNA548532_init,
    rhos_PRJNA548532_init,
) = fuzzy_simplicial_set(
    X=PRJNA548532_train,
    n_neighbors=ks,
    metric=metric,
    random_state=random_state,
    knn_indices=new_knn_indices_PRJNA548532_init,
    knn_dists=new_knn_dists_PRJNA548532_init,
)
```

```{python}
PRJNA548532_init.obsp["connectivities"] = ig.Graph.from_networkx(
    from_scipy_sparse_array(G_PRJNA548532_init)
).get_adjacency_sparse()
```

```{python}
PRJNA548532_init.obsp["distances"] = get_sparse_matrix_from_indices_distances_umap(
    new_knn_indices_PRJNA548532_init,
    new_knn_dists_PRJNA548532_init,
    PRJNA548532_init.n_obs,
    ks,
)
```

```{python}
sc.tl.paga(PRJNA548532_init, groups="subfunct_groups")
sc.pl.paga(
    PRJNA548532_init,
    threshold=paga_threshold,
    layout="fr",
    cmap="nipy_spectral",
    show=True,
    save=False,
    random_state=reseed,
)
```

```{python}
PRJNA548532_train_embeddings, PRJNA548532_train_aux_data = simplicial_set_embedding(
    data=PRJNA548532_train,
    graph=G_PRJNA548532_init,
    n_components=n_components,
    initial_alpha=1.0,
    a=a,
    b=b,
    gamma=5.0,
    negative_sample_rate=negative_sample_rate,
    n_epochs=500,
    init=get_init_pos_from_paga(
        adata=PRJNA548532_init, adjacency=G_PRJNA548532_init, random_state=reseed
    ),
    random_state=check_random_state(reseed),
    metric=metric,
    metric_kwds={},
    densmap=False,
    densmap_kwds={},
    output_dens=False,
    output_metric=dist.named_distances_with_gradients["euclidean"],
    output_metric_kwds={},
    euclidean_output=True,
    parallel=False,
    verbose=True,
)

PRJNA548532_init.obsm["X_umap"] = PRJNA548532_train_embeddings
```

```{python}
sc.pl.umap(
    PRJNA548532_init,
    color=["subfunct_groups"],
    frameon=False,
    show=True,
    save="-PRJNA548532_init_umap.pdf",
)
```

```{python}
paga_PRJNA548532_init = ig.Graph.from_networkx(
    from_scipy_sparse_array(PRJNA548532_init.uns["paga"]["connectivities"])
)
```

#### Mickelsen LHA

```{python}
PRJNA515063_init = PRJNA515063[PRJNA515063.obs["train"]]
PRJNA515063_init.obs["subfunct_groups"] = 999
PRJNA515063_init.obs["subfunct_groups"][
    PRJNA515063_init.obs["train"]
    & (PRJNA515063_init.obs["bioproject"] == "PRJNA779749")
] = labels1
PRJNA515063_init.obs["subfunct_groups"][
    PRJNA515063_init.obs["train"]
    & (PRJNA515063_init.obs["bioproject"] == "PRJNA515063")
] = predictions_X3_PRJNA515063

PRJNA515063_train, PRJNA515063_test = (
    PRJNA515063.obsm["X_pca_harmony"][PRJNA515063.obs["train"]],
    PRJNA515063.obsm["X_pca_harmony"][PRJNA515063.obs["test"]],
)

PRJNA515063_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA515063_init.obs["subfunct_groups"].astype(str),
    categories=natsorted(
        map(str, np.unique(PRJNA515063_init.obs["subfunct_groups"].astype(str)))
    ),
)
```

```{python}
sc.pp.neighbors(
    PRJNA515063_init,
    n_neighbors=ks,
    use_rep="X_pca_harmony",
    metric=metric,
    knn=True,
    random_state=reseed,
)
```

```{python}
# derive knn graph
(
    knn_indices_PRJNA515063_init,
    knn_dists_PRJNA515063_init,
    knn_search_index_PRJNA515063_init,
) = nearest_neighbors(
    PRJNA515063_train,
    n_neighbors=k,
    metric=metric,
    metric_kwds={},
    angular=False,
    random_state=random_state,
    low_memory=True,
    use_pynndescent=True,
    n_jobs=threads,
    verbose=True,
)

# derive mutual nn graph
(
    connected_mnn_PRJNA515063_init,
    mutual_nn_PRJNA515063_init,
    new_knn_indices_PRJNA515063_init,
    new_knn_dists_PRJNA515063_init,
) = mutual_nn_nearest(
    knn_indices_PRJNA515063_init,
    knn_dists_PRJNA515063_init,
    k,
    ks,
    connectivity=connectivity_model,
    verbose=True,
)

# build fuzzy_simplicial_set
(
    G_PRJNA515063_init,
    sigmas_PRJNA515063_init,
    rhos_PRJNA515063_init,
) = fuzzy_simplicial_set(
    X=PRJNA515063_train,
    n_neighbors=ks,
    metric=metric,
    random_state=random_state,
    knn_indices=new_knn_indices_PRJNA515063_init,
    knn_dists=new_knn_dists_PRJNA515063_init,
)
```

```{python}
PRJNA515063_init.obsp["connectivities"] = ig.Graph.from_networkx(
    from_scipy_sparse_array(G_PRJNA515063_init)
).get_adjacency_sparse()
```

```{python}
PRJNA515063_init.obsp["distances"] = get_sparse_matrix_from_indices_distances_umap(
    new_knn_indices_PRJNA515063_init,
    new_knn_dists_PRJNA515063_init,
    PRJNA515063_init.n_obs,
    ks,
)
```

```{python}
sc.tl.paga(PRJNA515063_init, groups="subfunct_groups")
sc.pl.paga(
    PRJNA515063_init,
    threshold=paga_threshold,
    layout="fr",
    cmap="nipy_spectral",
    show=True,
    save=False,
    random_state=reseed,
)
```

```{python}
PRJNA515063_train_embeddings, PRJNA515063_train_aux_data = simplicial_set_embedding(
    data=PRJNA515063_train,
    graph=G_PRJNA515063_init,
    n_components=n_components,
    initial_alpha=1.0,
    a=a,
    b=b,
    gamma=5.0,
    negative_sample_rate=negative_sample_rate,
    n_epochs=500,
    init=get_init_pos_from_paga(
        adata=PRJNA515063_init, adjacency=G_PRJNA515063_init, random_state=reseed
    ),
    random_state=check_random_state(reseed),
    metric=metric,
    metric_kwds={},
    densmap=False,
    densmap_kwds={},
    output_dens=False,
    output_metric=dist.named_distances_with_gradients["euclidean"],
    output_metric_kwds={},
    euclidean_output=True,
    parallel=False,
    verbose=True,
)

PRJNA515063_init.obsm["X_umap"] = PRJNA515063_train_embeddings
```

```{python}
sc.pl.umap(
    PRJNA515063_init,
    color=["subfunct_groups"],
    frameon=False,
    show=True,
    save="-PRJNA515063_init_umap.pdf",
)
```

```{python}
paga_PRJNA515063_init = ig.Graph.from_networkx(
    from_scipy_sparse_array(PRJNA515063_init.uns["paga"]["connectivities"])
)
```

#### Moffitt POA

```{python}
PRJNA453138_init = PRJNA453138[PRJNA453138.obs["train"]]
PRJNA453138_init.obs["subfunct_groups"] = 999
PRJNA453138_init.obs["subfunct_groups"][
    PRJNA453138_init.obs["train"]
    & (PRJNA453138_init.obs["bioproject"] == "PRJNA779749")
] = labels1
PRJNA453138_init.obs["subfunct_groups"][
    PRJNA453138_init.obs["train"]
    & (PRJNA453138_init.obs["bioproject"] == "PRJNA453138")
] = predictions_X3_PRJNA453138

PRJNA453138_train, PRJNA453138_test = (
    PRJNA453138.obsm["X_pca_harmony"][PRJNA453138.obs["train"]],
    PRJNA453138.obsm["X_pca_harmony"][PRJNA453138.obs["test"]],
)

PRJNA453138_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA453138_init.obs["subfunct_groups"].astype(str),
    categories=natsorted(
        map(str, np.unique(PRJNA453138_init.obs["subfunct_groups"].astype(str)))
    ),
)
```

```{python}
sc.pp.neighbors(
    PRJNA453138_init,
    n_neighbors=ks,
    use_rep="X_pca_harmony",
    metric=metric,
    knn=True,
    random_state=reseed,
)
```

```{python}
# derive knn graph
(
    knn_indices_PRJNA453138_init,
    knn_dists_PRJNA453138_init,
    knn_search_index_PRJNA453138_init,
) = nearest_neighbors(
    PRJNA453138_train,
    n_neighbors=k,
    metric=metric,
    metric_kwds={},
    angular=False,
    random_state=random_state,
    low_memory=True,
    use_pynndescent=True,
    n_jobs=threads,
    verbose=True,
)

# derive mutual nn graph
(
    connected_mnn_PRJNA453138_init,
    mutual_nn_PRJNA453138_init,
    new_knn_indices_PRJNA453138_init,
    new_knn_dists_PRJNA453138_init,
) = mutual_nn_nearest(
    knn_indices_PRJNA453138_init,
    knn_dists_PRJNA453138_init,
    k,
    ks,
    connectivity=connectivity_model,
    verbose=True,
)

# build fuzzy_simplicial_set
(
    G_PRJNA453138_init,
    sigmas_PRJNA453138_init,
    rhos_PRJNA453138_init,
) = fuzzy_simplicial_set(
    X=PRJNA453138_train,
    n_neighbors=ks,
    metric=metric,
    random_state=random_state,
    knn_indices=new_knn_indices_PRJNA453138_init,
    knn_dists=new_knn_dists_PRJNA453138_init,
)
```

```{python}
PRJNA453138_init.obsp["connectivities"] = ig.Graph.from_networkx(
    from_scipy_sparse_array(G_PRJNA453138_init)
).get_adjacency_sparse()
```

```{python}
PRJNA453138_init.obsp["distances"] = get_sparse_matrix_from_indices_distances_umap(
    new_knn_indices_PRJNA453138_init,
    new_knn_dists_PRJNA453138_init,
    PRJNA453138_init.n_obs,
    ks,
)
```

```{python}
sc.tl.paga(PRJNA453138_init, groups="subfunct_groups")
sc.pl.paga(
    PRJNA453138_init,
    threshold=paga_threshold,
    layout="fr",
    cmap="nipy_spectral",
    show=True,
    save=False,
    random_state=reseed,
)
```

```{python}
PRJNA453138_train_embeddings, PRJNA453138_train_aux_data = simplicial_set_embedding(
    data=PRJNA453138_train,
    graph=G_PRJNA453138_init,
    n_components=n_components,
    initial_alpha=1.0,
    a=a,
    b=b,
    gamma=5.0,
    negative_sample_rate=negative_sample_rate,
    n_epochs=500,
    init=get_init_pos_from_paga(
        adata=PRJNA453138_init, adjacency=G_PRJNA453138_init, random_state=reseed
    ),
    random_state=check_random_state(reseed),
    metric=metric,
    metric_kwds={},
    densmap=False,
    densmap_kwds={},
    output_dens=False,
    output_metric=dist.named_distances_with_gradients["euclidean"],
    output_metric_kwds={},
    euclidean_output=True,
    parallel=False,
    verbose=True,
)

PRJNA453138_init.obsm["X_umap"] = PRJNA453138_train_embeddings
```

```{python}
sc.pl.umap(
    PRJNA453138_init,
    color=["subfunct_groups"],
    frameon=False,
    show=True,
    save="-PRJNA453138_init_umap.pdf",
)
```

```{python}
paga_PRJNA453138_init = ig.Graph.from_networkx(
    from_scipy_sparse_array(PRJNA453138_init.uns["paga"]["connectivities"])
)
```

### Transform to categorical type

```{python}
PRJNA847050_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA847050_init.obs["subfunct_groups"].astype(int),
    categories=natsorted(
        map(int, np.unique(PRJNA847050_init.obs["subfunct_groups"].astype(int)))
    ),
)
PRJNA815819_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA815819_init.obs["subfunct_groups"].astype(int),
    categories=natsorted(
        map(int, np.unique(PRJNA815819_init.obs["subfunct_groups"].astype(int)))
    ),
)
PRJNA798401_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA798401_init.obs["subfunct_groups"].astype(int),
    categories=natsorted(
        map(int, np.unique(PRJNA798401_init.obs["subfunct_groups"].astype(int)))
    ),
)
PRJNA723345_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA723345_init.obs["subfunct_groups"].astype(int),
    categories=natsorted(
        map(int, np.unique(PRJNA723345_init.obs["subfunct_groups"].astype(int)))
    ),
)
PRJNA722418_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA722418_init.obs["subfunct_groups"].astype(int),
    categories=natsorted(
        map(int, np.unique(PRJNA722418_init.obs["subfunct_groups"].astype(int)))
    ),
)
PRJNA705596_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA705596_init.obs["subfunct_groups"].astype(int),
    categories=natsorted(
        map(int, np.unique(PRJNA705596_init.obs["subfunct_groups"].astype(int)))
    ),
)
PRJNA679294_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA679294_init.obs["subfunct_groups"].astype(int),
    categories=natsorted(
        map(int, np.unique(PRJNA679294_init.obs["subfunct_groups"].astype(int)))
    ),
)
PRJNA611624_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA611624_init.obs["subfunct_groups"].astype(int),
    categories=natsorted(
        map(int, np.unique(PRJNA611624_init.obs["subfunct_groups"].astype(int)))
    ),
)
PRJNA604055_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA604055_init.obs["subfunct_groups"].astype(int),
    categories=natsorted(
        map(int, np.unique(PRJNA604055_init.obs["subfunct_groups"].astype(int)))
    ),
)
PRJNA548532_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA548532_init.obs["subfunct_groups"].astype(int),
    categories=natsorted(
        map(int, np.unique(PRJNA548532_init.obs["subfunct_groups"].astype(int)))
    ),
)
PRJNA515063_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA515063_init.obs["subfunct_groups"].astype(int),
    categories=natsorted(
        map(int, np.unique(PRJNA515063_init.obs["subfunct_groups"].astype(int)))
    ),
)
PRJNA453138_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA453138_init.obs["subfunct_groups"].astype(int),
    categories=natsorted(
        map(int, np.unique(PRJNA453138_init.obs["subfunct_groups"].astype(int)))
    ),
)
```

```{python}
PRJNA779749_init.obs["subfunct_groups"] = pd.Categorical(
    values=PRJNA779749_init.obs["subfunct_groups"].astype(int),
    categories=natsorted(
        map(int, np.unique(PRJNA779749_init.obs["subfunct_groups"].astype(int)))
    ),
)
```

## Merge initial subregions/nuclei specific objects
without whole hypothalamus and mediabasal hypothalamus

```{python}
PRJNA847050_etr = PRJNA847050_counts[PRJNA847050_counts.obs["train"]]
PRJNA815819_etr = PRJNA815819_counts[PRJNA815819_counts.obs["train"]]
PRJNA798401_etr = PRJNA798401_counts[PRJNA798401_counts.obs["train"]]
PRJNA723345_etr = PRJNA723345_counts[PRJNA723345_counts.obs["train"]]
PRJNA722418_etr = PRJNA722418_counts[PRJNA722418_counts.obs["train"]]
PRJNA705596_etr = PRJNA705596_counts[PRJNA705596_counts.obs["train"]]
PRJNA679294_etr = PRJNA679294_counts[PRJNA679294_counts.obs["train"]]
PRJNA611624_etr = PRJNA611624_counts[PRJNA611624_counts.obs["train"]]
PRJNA604055_etr = PRJNA604055_counts[PRJNA604055_counts.obs["train"]]
PRJNA548532_etr = PRJNA548532_counts[PRJNA548532_counts.obs["train"]]
PRJNA515063_etr = PRJNA515063_counts[PRJNA515063_counts.obs["train"]]
PRJNA453138_etr = PRJNA453138_counts[PRJNA453138_counts.obs["train"]]

PRJNA847050_etr.obs["subfunct_groups"] = PRJNA847050_init.obs["subfunct_groups"][
    PRJNA847050_init.obs["bioproject"] == "PRJNA847050"
]
PRJNA815819_etr.obs["subfunct_groups"] = PRJNA815819_init.obs["subfunct_groups"][
    PRJNA815819_init.obs["bioproject"] == "PRJNA815819"
]
PRJNA798401_etr.obs["subfunct_groups"] = PRJNA798401_init.obs["subfunct_groups"][
    PRJNA798401_init.obs["bioproject"] == "PRJNA798401"
]
PRJNA723345_etr.obs["subfunct_groups"] = PRJNA723345_init.obs["subfunct_groups"][
    PRJNA723345_init.obs["bioproject"] == "PRJNA723345"
]
PRJNA722418_etr.obs["subfunct_groups"] = PRJNA722418_init.obs["subfunct_groups"][
    PRJNA722418_init.obs["bioproject"] == "PRJNA722418"
]
PRJNA705596_etr.obs["subfunct_groups"] = PRJNA705596_init.obs["subfunct_groups"][
    PRJNA705596_init.obs["bioproject"] == "PRJNA705596"
]
PRJNA679294_etr.obs["subfunct_groups"] = PRJNA679294_init.obs["subfunct_groups"][
    PRJNA679294_init.obs["bioproject"] == "PRJNA679294"
]
PRJNA611624_etr.obs["subfunct_groups"] = PRJNA611624_init.obs["subfunct_groups"][
    PRJNA611624_init.obs["bioproject"] == "PRJNA611624"
]
PRJNA604055_etr.obs["subfunct_groups"] = PRJNA604055_init.obs["subfunct_groups"][
    PRJNA604055_init.obs["bioproject"] == "PRJNA604055"
]
PRJNA548532_etr.obs["subfunct_groups"] = PRJNA548532_init.obs["subfunct_groups"][
    PRJNA548532_init.obs["bioproject"] == "PRJNA548532"
]
PRJNA515063_etr.obs["subfunct_groups"] = PRJNA515063_init.obs["subfunct_groups"][
    PRJNA515063_init.obs["bioproject"] == "PRJNA515063"
]
PRJNA453138_etr.obs["subfunct_groups"] = PRJNA453138_init.obs["subfunct_groups"][
    PRJNA453138_init.obs["bioproject"] == "PRJNA453138"
]
```

```{python}
adata = concat(
    [
        PRJNA847050_etr,
        PRJNA815819_etr,
        PRJNA798401_etr,
        PRJNA722418_etr,
        PRJNA705596_etr,
        PRJNA679294_etr,
        PRJNA611624_etr,
        PRJNA604055_etr,
        PRJNA548532_etr,
        PRJNA515063_etr,
        PRJNA453138_etr,
    ],
    join="outer",
)
```

```{python}
adata = adata[
    :,
    ~adata.var_names.str.match(r"(^Hla-|^Ig[hjkl]|^Rna|^mt-|^Rp[sl]|^Hb[^(p)]|^Gm)"),
]
```

```{python}
adata = adata[:, ~adata.var_names.isin(hk_genes1)]
```

```{python}
adata.obs["subfunct_groups"] = pd.Categorical(
    values=adata.obs["subfunct_groups"].astype("U"),
    categories=natsorted(map(str, np.unique(adata.obs["subfunct_groups"].astype(str)))),
)
```

```{python}
sc.pp.filter_genes(adata, min_cells=3)
sc.pp.normalize_total(adata, target_sum=1e4)
sc.pp.log1p(adata)
sc.pp.regress_out(adata, ["nCount_RNA", "percent_mito_ribo"])


X = pd.DataFrame(
    adata.X, columns=adata.var_names, index=adata.obs_names
)  # Feature Matrix
y = adata.obs["region"]  # Target Variable
X.head()
```

# Feature selection

## Filter genes that are allow to discriminate between subregions/nuclei

### Use the optimal number of features to select the most discriminative ones

```{python}
max_iter = 10000
min_features_to_select = 1000  # Minimum number of features to consider
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=10, random_state=reseed)
f1_scorer = make_scorer(f1_score, average="weighted")
# n_features = rfecv.n_features_
n_features = 2000
N_FEATURES_OPTIONS = [
    n_features,
    round(n_features / 2),
    round(n_features / 4),
    round(n_features / 8),
]
C_OPTIONS = [1, 10, 100, 1000]
SELECTION_ITER = 1000
param_grid = [
    {
        "reduce_dim__k": N_FEATURES_OPTIONS,
        "classify__C": C_OPTIONS,
    },
]
```

```{python}
# Perform chi-squared-based feature selection
chi2_test = Pipeline(
    [
        ("scaling", MinMaxScaler()),
        # the reduce_dim stage is populated by the param_grid
        ("reduce_dim", SelectKBest(chi2)),
        ("classify", SVC(gamma="scale", max_iter=SELECTION_ITER)),
    ]
)

chi2_features = GridSearchCV(
    chi2_test, n_jobs=-1, param_grid=param_grid, scoring=f1_scorer, cv=cv
)
chi2_features.fit(X, y)

with open("/data/data/resolved_subregions_by_microclusters-replic-3/fs_chi2_features.tsv", "w") as f:
    for i in X.columns[chi2_features.best_estimator_[1].get_support(indices=True)]:
        f.write(str(i) + "\n")
    f.close()

print(chi2_features.best_estimator_[1].get_feature_names_out())
print(
    "{} features selected: ".format(
        len(chi2_features.best_estimator_[1].get_feature_names_out())
    )
)
```

```{python}
# Perform ANOVA F-test-based feature selection
anova = Pipeline(
    [
        ("scaling", MinMaxScaler()),
        # the reduce_dim stage is populated by the param_grid
        ("reduce_dim", SelectKBest(f_classif)),
        ("classify", SVC(gamma="scale", max_iter=SELECTION_ITER)),
    ]
)

anova_features = GridSearchCV(
    anova, n_jobs=-1, param_grid=param_grid, scoring=f1_scorer, cv=cv
)
anova_features.fit(X, y)

with open("/data/data/resolved_subregions_by_microclusters-replic-3/fs_anova_features.tsv", "w") as f:
    for i in X.columns[anova_features.best_estimator_[1].get_support(indices=True)]:
        f.write(str(i) + "\n")
    f.close()

print(anova_features.best_estimator_[1].get_feature_names_out())
print(
    "{} features selected: ".format(
        len(anova_features.best_estimator_[1].get_feature_names_out())
    )
)
```

```{python}
# Perform mutual information-based feature selection
mi = Pipeline(
    [
        ("scaling", MinMaxScaler()),
        # the reduce_dim stage is populated by the param_grid
        ("reduce_dim", SelectKBest(mutual_info_classif)),
        ("classify", SVC(gamma="scale", max_iter=SELECTION_ITER)),
    ]
)

mi_features = GridSearchCV(
    mi, n_jobs=-1, param_grid=param_grid, scoring=f1_scorer, cv=cv
)
mi_features.fit(X, y)

with open("/data/data/resolved_subregions_by_microclusters-replic-3/fs_mutual_information_features.tsv", "w") as f:
    for i in X.columns[mi_features.best_estimator_[1].get_support(indices=True)]:
        f.write(str(i) + "\n")
    f.close()

print(mi_features.best_estimator_[1].get_feature_names_out())
print(
    "{} features selected: ".format(
        len(mi_features.best_estimator_[1].get_feature_names_out())
    )
)
```

### Use the ensemble of methods to select the most discriminative features

```{python}
chi2_features_n = set(chi2_features.best_estimator_[1].get_support(indices=True))
f_features_n = set(anova_features.best_estimator_[1].get_support(indices=True))
mi_features_n = set(mi_features.best_estimator_[1].get_support(indices=True))

# Compute the intersection of the feature sets to obtain the common features
common_features = list(chi2_features_n.intersection(f_features_n, mi_features_n))
print("Commonly selected features ({}): ".format(len(common_features)))
print(X.columns[common_features].tolist())

# Compute the union of the feature sets to obtain the common features
union_features = list(chi2_features_n.union(f_features_n, mi_features_n))
print("All selected features ({}): ".format(len(union_features)))
print(X.columns[union_features].tolist())

# Filter X using the common features
X_com = X.iloc[:, np.array(common_features, dtype=int)]
X_uni = X.iloc[:, np.array(union_features, dtype=int)]
```

## Compare feature selection methods (sparse logistic regression) and use the Support Vector Machine classifier to predict subregions/nuclei

```{python}
# Compute the proportion of each category
prop = y.value_counts(normalize=True)

# Sort the categories by their proportion
cat = pd.Categorical(y, categories=prop.index.sort_values(), ordered=True)

# Get the integer codes of the categories
codes = cat.codes
```

```{python}
from xgboost import XGBClassifier

cv = StratifiedGroupKFold(n_splits=10, random_state=None)
# cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=10, random_state=reseed)
max_iter = 10000
n_features = len(union_features)
N_FEATURES_OPTIONS = [
    round(n_features / 3),
    round(n_features / 4),
    round(n_features / 8),
    round(n_features / 10),
    round(n_features / 20),
]

C_OPTIONS = [1, 10, 100, 200]

pipe = Pipeline(
    [
        ("scaling", RobustScaler()),
        # the reduce_dim stage is populated by the param_grid
        ("feature_selection", "passthrough"),
        ("classify", SVC(gamma="scale", max_iter=max_iter)),
    ]
)

param_grid = [
    {
        "feature_selection": [
            SelectFromModel(
                LogisticRegression(
                    solver="saga",
                    multi_class="ovr",
                    penalty="l1",
                    max_iter=max_iter,
                    random_state=reseed,
                    n_jobs=-1,
                ),
                threshold=-np.inf
            )
        ],
        "feature_selection__max_features": N_FEATURES_OPTIONS,
        # "feature_selection__estimator__penalty": ["l1", "l2"],
        # "feature_selection__estimator__C": C_OPTIONS,
        "classify__C": C_OPTIONS,
    },
]

grid = GridSearchCV(
    pipe, cv=cv, n_jobs=-1, param_grid=param_grid, scoring="matthews_corrcoef"
)
grid.fit(X_uni, codes, groups=adata.obs["subfunct_groups"])
```

```{python}
with open("/data/data/resolved_subregions_by_microclusters-replic-3/fs_logit_features.tsv", "w") as f:
    for i in X_uni.columns[np.array(grid.best_estimator_[1].get_support(indices=True), dtype=int)].tolist():
        f.write(str(i) + "\n")
    f.close()

print(X_uni.columns[np.array(grid.best_estimator_[1].get_support(indices=True), dtype=int)].tolist())
```

### Compare models' performance

```{python}
import pandas as pd

results_df = pd.DataFrame(grid.cv_results_)
results_df = results_df.sort_values(by=["rank_test_score"])
results_df = results_df.set_index(
    results_df["params"].apply(lambda x: "_".join(str(val) for val in x.values()))
).rename_axis("kernel")
results_df[["params", "rank_test_score", "mean_test_score", "std_test_score"]]
results_df[["params", "rank_test_score", "mean_test_score", "std_test_score"]].to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/replic3-cross-validation-best-subregional_supervised-logit-evaluation-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.tsv",
    sep="\t",
    header=True,
)
```

```{python}
results_df[["params", "rank_test_score", "mean_test_score", "std_test_score"]].head(10)
```

```{python}
# create df of model scores ordered by performance
model_scores = results_df.filter(regex=r"split\d*_test_score")
```

#### Statistical analysis of the models' performance with the right-tailed paired t-test with corrected standard deviation using Nadeau and Bengio's approach

```{python}
from scipy.stats import t


def corrected_std(differences, n_train, n_test):
    """Corrects standard deviation using Nadeau and Bengio's approach.

    Parameters
    ----------
    differences : ndarray of shape (n_samples,)
        Vector containing the differences in the score metrics of two models.
    n_train : int
        Number of samples in the training set.
    n_test : int
        Number of samples in the testing set.

    Returns
    -------
    corrected_std : float
        Variance-corrected standard deviation of the set of differences.
    """
    # kr = k times r, r times repeated k-fold crossvalidation,
    # kr equals the number of times the model was evaluated
    kr = len(differences)
    corrected_var = np.var(differences, ddof=1) * (1 / kr + n_test / n_train)
    corrected_std = np.sqrt(corrected_var)
    return corrected_std


def compute_corrected_ttest(differences, df, n_train, n_test):
    """Computes right-tailed paired t-test with corrected variance.

    Parameters
    ----------
    differences : array-like of shape (n_samples,)
        Vector containing the differences in the score metrics of two models.
    df : int
        Degrees of freedom.
    n_train : int
        Number of samples in the training set.
    n_test : int
        Number of samples in the testing set.

    Returns
    -------
    t_stat : float
        Variance-corrected t-statistic.
    p_val : float
        Variance-corrected p-value.
    """
    mean = np.mean(differences)
    std = corrected_std(differences, n_train, n_test)
    t_stat = mean / std
    p_val = t.sf(np.abs(t_stat), df)  # right-tailed t-test
    return t_stat, p_val
```

```{python}
model_1_scores = model_scores.iloc[0].values  # scores of the best model
model_2_scores = model_scores.iloc[1].values  # scores of the second-best model

differences = model_1_scores - model_2_scores

n = differences.shape[0]  # number of test sets
df = n - 1
n_train = len(list(cv.split(X, y))[0][0])
n_test = len(list(cv.split(X, y))[0][1])

rope_interval = [-0.01, 0.01]
```

```{python}
from itertools import combinations
from math import factorial

n_comparisons = factorial(len(model_scores)) / (
    factorial(2) * factorial(len(model_scores) - 2)
)
pairwise_t_test = []

for model_i, model_k in combinations(range(len(model_scores)), 2):
    model_i_scores = model_scores.iloc[model_i].values
    model_k_scores = model_scores.iloc[model_k].values
    differences = model_i_scores - model_k_scores
    t_stat, p_val = compute_corrected_ttest(differences, df, n_train, n_test)
    p_val *= n_comparisons  # implement Bonferroni correction
    # Bonferroni can output p-values higher than 1
    p_val = 1 if p_val > 1 else p_val
    pairwise_t_test.append(
        [model_scores.index[model_i], model_scores.index[model_k], t_stat, p_val]
    )

pairwise_comp_df = pd.DataFrame(
    pairwise_t_test, columns=["model_1", "model_2", "t_stat", "p_val"]
).round(3)
pairwise_comp_df
```

#### Statistical analysis of the models' performance with Bayesian methods

```{python}
pairwise_bayesian = []

for model_i, model_k in combinations(range(len(model_scores)), 2):
    model_i_scores = model_scores.iloc[model_i].values
    model_k_scores = model_scores.iloc[model_k].values
    differences = model_i_scores - model_k_scores
    t_post = t(
        df, loc=np.mean(differences), scale=corrected_std(differences, n_train, n_test)
    )
    worse_prob = t_post.cdf(rope_interval[0])
    better_prob = 1 - t_post.cdf(rope_interval[1])
    rope_prob = t_post.cdf(rope_interval[1]) - t_post.cdf(rope_interval[0])

    pairwise_bayesian.append([worse_prob, better_prob, rope_prob])

pairwise_bayesian_df = pd.DataFrame(
    pairwise_bayesian, columns=["worse_prob", "better_prob", "rope_prob"]
).round(3)

pairwise_comp_df = pairwise_comp_df.join(pairwise_bayesian_df)
pairwise_comp_df.to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/replic3-testing-best-subregional_supervised-logit-evaluation-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.tsv",
    sep="\t",
    header=True,
)
pairwise_comp_df
```

```{python}
subregional_model = grid.best_estimator_
subregional_model
```

## Compare feature selection methods (XGBoost) and use the Support Vector Machine classifier to predict subregions/nuclei

```{python}
pipe2 = Pipeline(
    [
        ("scaling", RobustScaler()),
        # the reduce_dim stage is populated by the param_grid
        ("feature_selection", "passthrough"),
        ("classify", SVC(gamma="scale", max_iter=max_iter)),
    ]
)

param_grid2 = [
    {
        "feature_selection": [
            SelectFromModel(
                XGBClassifier(tree_method="gpu_hist"),
                threshold=-np.inf
            )
        ],
        "feature_selection__max_features": N_FEATURES_OPTIONS,
        "feature_selection__estimator__max_depth": [3, 5, 7],
        "feature_selection__estimator__learning_rate": [0.1, 0.3, 0.5],
        "feature_selection__estimator__n_estimators": [100, 250, 500],
        "classify__C": C_OPTIONS,
    },
]

grid = GridSearchCV(
    pipe2, cv=cv, n_jobs=1, param_grid=param_grid2, scoring="matthews_corrcoef"
)
grid.fit(X_uni, codes, groups=adata.obs["subfunct_groups"])
```

```{python}
print(X_uni.columns[np.array(grid.best_estimator_[1].get_support(indices=True), dtype=int)].tolist())
```

### Compare models' performance

```{python}
import pandas as pd

results_df = pd.DataFrame(grid.cv_results_)
results_df = results_df.sort_values(by=["rank_test_score"])
results_df = results_df.set_index(
    results_df["params"].apply(lambda x: "_".join(str(val) for val in x.values()))
).rename_axis("kernel")
results_df[["params", "rank_test_score", "mean_test_score", "std_test_score"]]
results_df[["params", "rank_test_score", "mean_test_score", "std_test_score"]].to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/replic3-cross-validation-best-subregional_supervised-xgboost-evaluation-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.tsv",
    sep="\t",
    header=True,
)
```

```{python}
results_df[["params", "rank_test_score", "mean_test_score", "std_test_score"]].head(10)
```

```{python}
# create df of model scores ordered by performance
model_scores = results_df.filter(regex=r"split\d*_test_score")
```

#### Statistical analysis of the models' performance with the right-tailed paired t-test with corrected standard deviation using Nadeau and Bengio's approach

```{python}
from scipy.stats import t


def corrected_std(differences, n_train, n_test):
    """Corrects standard deviation using Nadeau and Bengio's approach.

    Parameters
    ----------
    differences : ndarray of shape (n_samples,)
        Vector containing the differences in the score metrics of two models.
    n_train : int
        Number of samples in the training set.
    n_test : int
        Number of samples in the testing set.

    Returns
    -------
    corrected_std : float
        Variance-corrected standard deviation of the set of differences.
    """
    # kr = k times r, r times repeated k-fold crossvalidation,
    # kr equals the number of times the model was evaluated
    kr = len(differences)
    corrected_var = np.var(differences, ddof=1) * (1 / kr + n_test / n_train)
    corrected_std = np.sqrt(corrected_var)
    return corrected_std


def compute_corrected_ttest(differences, df, n_train, n_test):
    """Computes right-tailed paired t-test with corrected variance.

    Parameters
    ----------
    differences : array-like of shape (n_samples,)
        Vector containing the differences in the score metrics of two models.
    df : int
        Degrees of freedom.
    n_train : int
        Number of samples in the training set.
    n_test : int
        Number of samples in the testing set.

    Returns
    -------
    t_stat : float
        Variance-corrected t-statistic.
    p_val : float
        Variance-corrected p-value.
    """
    mean = np.mean(differences)
    std = corrected_std(differences, n_train, n_test)
    t_stat = mean / std
    p_val = t.sf(np.abs(t_stat), df)  # right-tailed t-test
    return t_stat, p_val
```

```{python}
model_1_scores = model_scores.iloc[0].values  # scores of the best model
model_2_scores = model_scores.iloc[1].values  # scores of the second-best model

differences = model_1_scores - model_2_scores

n = differences.shape[0]  # number of test sets
df = n - 1
n_train = len(list(cv.split(X, y))[0][0])
n_test = len(list(cv.split(X, y))[0][1])

rope_interval = [-0.01, 0.01]
```

```{python}
from itertools import combinations
from math import factorial

n_comparisons = factorial(len(model_scores)) / (
    factorial(2) * factorial(len(model_scores) - 2)
)
pairwise_t_test = []

for model_i, model_k in combinations(range(len(model_scores)), 2):
    model_i_scores = model_scores.iloc[model_i].values
    model_k_scores = model_scores.iloc[model_k].values
    differences = model_i_scores - model_k_scores
    t_stat, p_val = compute_corrected_ttest(differences, df, n_train, n_test)
    p_val *= n_comparisons  # implement Bonferroni correction
    # Bonferroni can output p-values higher than 1
    p_val = 1 if p_val > 1 else p_val
    pairwise_t_test.append(
        [model_scores.index[model_i], model_scores.index[model_k], t_stat, p_val]
    )

pairwise_comp_df = pd.DataFrame(
    pairwise_t_test, columns=["model_1", "model_2", "t_stat", "p_val"]
).round(3)
pairwise_comp_df
```

#### Statistical analysis of the models' performance with Bayesian methods

```{python}
pairwise_bayesian = []

for model_i, model_k in combinations(range(len(model_scores)), 2):
    model_i_scores = model_scores.iloc[model_i].values
    model_k_scores = model_scores.iloc[model_k].values
    differences = model_i_scores - model_k_scores
    t_post = t(
        df, loc=np.mean(differences), scale=corrected_std(differences, n_train, n_test)
    )
    worse_prob = t_post.cdf(rope_interval[0])
    better_prob = 1 - t_post.cdf(rope_interval[1])
    rope_prob = t_post.cdf(rope_interval[1]) - t_post.cdf(rope_interval[0])

    pairwise_bayesian.append([worse_prob, better_prob, rope_prob])

pairwise_bayesian_df = pd.DataFrame(
    pairwise_bayesian, columns=["worse_prob", "better_prob", "rope_prob"]
).round(3)

pairwise_comp_df = pairwise_comp_df.join(pairwise_bayesian_df)
pairwise_comp_df.to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/replic3-testing-best-subregional_supervised-xgboost-evaluation-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.tsv",
    sep="\t",
    header=True,
)
pairwise_comp_df
```

```{python}
subregional_model2 = grid.best_estimator_
subregional_model2
```

## Fit final selected model

```{python}
subregional_model = Pipeline(
    [
        ("scaling", RobustScaler()),
        # the reduce_dim stage is populated by the param_grid
        ("feature_selection", SelectFromModel(
                LogisticRegression(
                    solver="saga",
                    multi_class="ovr",
                    penalty="l1",
                    max_iter=max_iter,
                    random_state=reseed,
                    n_jobs=-1,),
                max_features=1406,
                threshold=-np.inf
            )),
        ("classify", SVC(C=10, gamma="scale", max_iter=max_iter)),
    ]
)

subregional_model.fit(X_uni, codes)

joblib.dump(
    subregional_model,
    f"models/svm/rep3-best-logit-subregional_astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

with open("/data/data/resolved_subregions_by_microclusters-replic-3/fs_logit_features.tsv", "w") as f:
    for i in X_uni.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist():
        f.write(str(i) + "\n")
    f.close()

print(X_uni.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist())
```

```{python}
subregional_model2 = Pipeline(
    [
        ("scaling", RobustScaler()),
        # the reduce_dim stage is populated by the param_grid
        ("feature_selection", SelectFromModel(
                XGBClassifier(tree_method="gpu_hist", n_estimators=100, max_depth=3, learning_rate=0.3, n_jobs=-1, random_state=42),
                max_features=211,
                threshold=-np.inf
            )),
        ("classify", SVC(C=200, gamma="scale", max_iter=max_iter)),
    ]
)

subregional_model2.fit(X_uni, codes)

joblib.dump(
    subregional_model2,
    f"models/svm/rep3-best-xgboost-subregional_astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

with open("/data/data/resolved_subregions_by_microclusters-replic-3/fs_xgboost_features.tsv", "w") as f:
    for i in X_uni.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist():
        f.write(str(i) + "\n")
    f.close()

print(X_uni.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist())
```

## Evaluate model on test parts of the datasets

```{python}
PRJNA847050_etest = PRJNA847050_counts[PRJNA847050_counts.obs["test"]]
PRJNA815819_etest = PRJNA815819_counts[PRJNA815819_counts.obs["test"]]
PRJNA798401_etest = PRJNA798401_counts[PRJNA798401_counts.obs["test"]]
PRJNA723345_etest = PRJNA723345_counts[PRJNA723345_counts.obs["test"]]
PRJNA722418_etest = PRJNA722418_counts[PRJNA722418_counts.obs["test"]]
PRJNA705596_etest = PRJNA705596_counts[PRJNA705596_counts.obs["test"]]
PRJNA679294_etest = PRJNA679294_counts[PRJNA679294_counts.obs["test"]]
PRJNA611624_etest = PRJNA611624_counts[PRJNA611624_counts.obs["test"]]
PRJNA604055_etest = PRJNA604055_counts[PRJNA604055_counts.obs["test"]]
PRJNA548532_etest = PRJNA548532_counts[PRJNA548532_counts.obs["test"]]
PRJNA515063_etest = PRJNA515063_counts[PRJNA515063_counts.obs["test"]]
PRJNA453138_etest = PRJNA453138_counts[PRJNA453138_counts.obs["test"]]

adata_eval = concat(
    [
        PRJNA847050_etest,
        PRJNA815819_etest,
        PRJNA798401_etest,
        PRJNA722418_etest,
        PRJNA705596_etest,
        PRJNA679294_etest,
        PRJNA611624_etest,
        PRJNA604055_etest,
        PRJNA548532_etest,
        PRJNA515063_etest,
        PRJNA453138_etest,
    ],
    join="outer",
)

sc.pp.normalize_total(adata_eval, target_sum=1e4)
sc.pp.log1p(adata_eval)
sc.pp.regress_out(adata_eval, ["nCount_RNA", "percent_mito_ribo"])

y_eval = adata_eval.obs["region"]
df_eval = pd.DataFrame(
    adata_eval.X, columns=adata_eval.var_names, index=adata_eval.obs_names
)
```

```{python}
df_eval = df_eval.loc[
    :, uni_fs
]

df_eval.head()
```

```{python}
# Compute the proportion of each category
prop_eval = y_eval.value_counts(normalize=True)

# Sort the categories by their proportion
cat_eval = pd.Categorical(y_eval, categories=prop_eval.index.sort_values(), ordered=True)

# Get the integer codes of the categories
codes_eval = cat_eval.codes

adata_eval.obs["codes_eval"] = adata_eval.obs["region"]
adata_eval.obs["codes_eval"] = pd.Categorical(codes_eval, ordered=True)
```

## Logistic regression based feature selection

```{python}

predictions_logit_eval = subregional_model.predict(df_eval)

print("Matthews correlation coefficient: {}".format(matthews_corrcoef(codes_eval, predictions_logit_eval)))
print("F-measure: {}".format(f1_score(codes_eval, predictions_logit_eval, average="weighted")))
```

```{python}

adata_eval.obs["predictions_logit_eval"] = adata_eval.obs["region"]
adata_eval.obs["predictions_logit_eval"] = predictions_logit_eval
adata_eval.obs["predictions_logit_eval"] = pd.Categorical(
    values=adata_eval.obs["predictions_logit_eval"].astype(str),
    categories=natsorted(
        map(str, np.unique(adata_eval.obs["predictions_logit_eval"].astype(str)))
    ),
)

reducer_eval = UMAP(
    n_neighbors=ks,
    n_epochs=1000,
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    densmap=True,
    n_components=2,
    random_state=reseed,
    verbose=False,
)
reducer_eval.fit(
    adata_eval.obsm["X_pca"], adata_eval.obs["predictions_logit_eval"].astype(str)
)
adata_eval.obsm["X_umap_logit"] = reducer_eval.transform(adata_eval.obsm["X_pca"])
```

```{python}
save_PRJNA779749 = f"-replic2-best-subregional_supervised-logit-evaluation-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pdf"

sc.pl.embedding(
    adata_eval,
    basis="X_pacmap",
    color=["predictions_logit_eval", "codes_eval", "region"],
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save=save_PRJNA779749,
)
```

```{python}
sc.pl.embedding(
    adata_eval,
    basis="X_umap_logit",
    color=["predictions_logit_eval"],
    title=f"UMAP: supervised predictions, PRJNA779749 \n(amb.FPR={cb_fpr}, k={k}, MSP={connectivity_model}, \nmetric={metric}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save="-predict_subregion" + save_PRJNA779749,
)
```

```{python}
sc.pl.embedding(
    adata_eval,
    basis="X_umap_logit",
    color=["region"],
    title=f"UMAP: supervised subregion, PRJNA779749 \n(amb.FPR={cb_fpr}, k={k}, MSP={connectivity_model}, \nmetric={metric}, n_genes_excluded={signature})",
    add_outline=True,
    legend_loc="on data",
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save="-region" + save_PRJNA779749,
)
```

```{python}
sc.pl.embedding(
    adata_eval,
    basis="X_umap_logit",
    color=["codes_eval"],
    title=f"UMAP: supervised subregion-codes, PRJNA779749 \n(amb.FPR={cb_fpr}, k={k}, MSP={connectivity_model}, \nmetric={metric}, n_genes_excluded={signature})",
    add_outline=True,
    legend_loc="on data",
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save="-region" + save_PRJNA779749,
)
```

## XGBoost based feature selection

```{python}
predictions_xgboost_eval = subregional_model2.predict(df_eval)
print("Matthews correlation coefficient: {}".format(matthews_corrcoef(codes_eval, predictions_xgboost_eval)))
print("F-measure: {}".format(f1_score(codes_eval, predictions_xgboost_eval, average="weighted")))
```

```{python}

adata_eval.obs["predictions_xgboost_eval"] = adata_eval.obs["region"]
adata_eval.obs["predictions_xgboost_eval"] = predictions_xgboost_eval
adata_eval.obs["predictions_xgboost_eval"] = pd.Categorical(
    values=adata_eval.obs["predictions_xgboost_eval"].astype(str),
    categories=natsorted(
        map(str, np.unique(adata_eval.obs["predictions_xgboost_eval"].astype(str)))
    ),
)

reducer_eval2 = UMAP(
    n_neighbors=ks,
    n_epochs=1000,
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    densmap=True,
    n_components=2,
    random_state=reseed,
    verbose=False,
)
reducer_eval2.fit(
    adata_eval.obsm["X_pca"], adata_eval.obs["predictions_xgboost_eval"].astype(str)
)
adata_eval.obsm["X_umap"] = reducer_eval2.transform(adata_eval.obsm["X_pca"])
```

```{python}
save_PRJNA779749 = f"-replic2-best-subregional_supervised-xgboost-evaluation-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pdf"

sc.pl.embedding(
    adata_eval,
    basis="X_pacmap",
    color=["predictions_xgboost_eval", "codes_eval", "region"],
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save=save_PRJNA779749,
)
```

```{python}
sc.pl.umap(
    adata_eval,
    color=["predictions_xgboost_eval"],
    title=f"UMAP: supervised predictions, PRJNA779749 \n(amb.FPR={cb_fpr}, k={k}, MSP={connectivity_model}, \nmetric={metric}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save="-predict_subregion" + save_PRJNA779749,
)
```

```{python}
sc.pl.umap(
    adata_eval,
    color=["region"],
    title=f"UMAP: supervised subregion, PRJNA779749 \n(amb.FPR={cb_fpr}, k={k}, MSP={connectivity_model}, \nmetric={metric}, n_genes_excluded={signature})",
    add_outline=True,
    legend_loc="on data",
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save="-region" + save_PRJNA779749,
)
```

```{python}
sc.pl.umap(
    adata_eval,
    color=["codes_eval"],
    title=f"UMAP: supervised subregion-codes, PRJNA779749 \n(amb.FPR={cb_fpr}, k={k}, MSP={connectivity_model}, \nmetric={metric}, n_genes_excluded={signature})",
    add_outline=True,
    legend_loc="on data",
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save="-region" + save_PRJNA779749,
)
```

```{python}
adata_eval.write(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/replic2-best-subregional_supervised-evaluation-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.h5ad"
)
pd.DataFrame(adata_eval.obsm["X_umap_logit"], index=adata_eval.obs_names).to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/replic2-best-subregional_supervised-xgboost-evaluation-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}-umap-logit.tsv",
    sep="\t",
    header=True,
)
pd.DataFrame(adata_eval.obsm["X_pacmap"], index=adata_eval.obs_names).to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/replic2-best-subregional_supervised-xgboost-evaluation-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}-pacmap-subfunct.tsv",
    sep="\t",
    header=True,
)
pd.DataFrame(adata_eval.obsm["X_umap"], index=adata_eval.obs_names).to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/replic2-best-subregional_supervised-evaluation-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}-umap-xgboost.tsv",
    sep="\t",
    header=True,
)
```

## Plot genes on the evaluation test set

```{python}
nprdf = pd.DataFrame(adata_eval.raw.X.todense(), columns=adata_eval.var_names, index=adata_eval.obs_names).loc[:, np.array([g for g in npr if g in adata_eval.var_names])]
nprdf.describe()
```

```{python}
nprdf.quantile(q=[0.5, 0.9, 0.985, 1.0], axis=0)
```

```{python}
nprcols = [col for col in nprdf.columns if nprdf[col].quantile(0.985) > 1]
nprcols3 = [col for col in nprdf.columns if col not in nprcols and nprdf[col].max() == 1]
nprcols2 = [col for col in nprdf.columns if col not in nprcols and col not in nprcols3]
print(nprcols)
print(nprcols2)
print(nprcols3)
```

```{python}
sc.pl.umap(
    adata_eval,
    color=nprcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-npr" + save_PRJNA779749,
)
```

```{python}
sc.pl.umap(
    adata_eval,
    color=nprcols2,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-npr2" + save_PRJNA779749,
)
```

```{python}
sc.pl.umap(
    adata_eval,
    color=nprcols3,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
    na_color="#9A9FB080",
    ncols=8,
    save="-npr3" + save_PRJNA779749,
)
```

```{python}
nmrdf = pd.DataFrame(adata_eval.raw.X.todense(), columns=adata_eval.var_names, index=adata_eval.obs_names).loc[:, np.array([g for g in nmr if g in adata_eval.var_names])]
nmrdf.describe()
```

```{python}
nmrcols = [col for col in nmrdf.columns if nmrdf[col].quantile(0.985) > 1]
nmrcols3 = [col for col in nmrdf.columns if col not in nmrcols and nmrdf[col].max() == 1]
nmrcols2 = [col for col in nmrdf.columns if col not in nmrcols and col not in nmrcols3]
print(nmrcols)
print(nmrcols2)
print(nmrcols3)
```

```{python}
sc.pl.umap(
    adata_eval,
    color=nmrcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr" + save_PRJNA779749,
)
```

```{python}
sc.pl.umap(
    adata_eval,
    color=nmrcols2,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr2" + save_PRJNA779749,
)
```

```{python}
sc.pl.umap(
    adata_eval,
    color=nmrcols3,
    frameon=False,
    show=True,
    size=40,
    cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr3" + save_PRJNA779749,
)
```

```{python}
adddf = pd.DataFrame(adata_eval.raw.X.todense(), columns=adata_eval.var_names, index=adata_eval.obs_names).loc[:, np.array([g for g in genes_embed if g in adata_eval.var_names])]
adddf.describe()
```

```{python}
agcols = [col for col in adddf.columns if adddf[col].quantile(0.985) > 1]
agcols3 = [col for col in adddf.columns if col not in agcols and adddf[col].max() == 1]
agcols2 = [col for col in adddf.columns if col not in agcols and col not in agcols3]
print(agcols)
print(agcols2)
print(agcols3)
```

```{python}
sc.pl.umap(
    adata_eval,
    color=agcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen" + save_PRJNA779749,
)
```

```{python}
sc.pl.umap(
    adata_eval,
    color=agcols2,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen2" + save_PRJNA779749,
)
```

```{python}
sc.pl.umap(
    adata_eval,
    color=agcols3,
    frameon=False,
    show=True,
    size=40,
    cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen3" + save_PRJNA779749,
)
```


```{python}
tfdf = pd.DataFrame(adata_eval.raw.X.todense(), columns=adata_eval.var_names, index=adata_eval.obs_names).loc[:, np.array([g for g in tf_genes if g in adata_eval.var_names])]
tfdf.describe()
```

```{python}
tfcols = [col for col in tfdf.columns if tfdf[col].quantile(0.9) > 3]
tfcols3 = [col for col in tfdf.columns if col not in tfcols and tfdf[col].max() == 1]
tfcols2 = [col for col in tfdf.columns if col not in tfcols and tfdf[col].max() > 1]

print(tfcols)
print(tfcols2)
print(tfcols3)
```

```{python}
for gene in tfcols:
    sc.pl.umap(
        adata_eval,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        vmin=0.0,
        vmax="p90.0",
        na_color="#9A9FB080",
        save="-tf1-" + gene + save_PRJNA779749,
)
```

```{python}
for gene in tfcols2:
    sc.pl.umap(
        adata_eval,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        vmin=0.0,
        na_color="#9A9FB080",
        save="-tf2" + gene + save_PRJNA779749,
)
```

```{python}
for gene in tfcols3:
    sc.pl.umap(
        adata_eval,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
        vmin=0.0,
        na_color="#9A9FB080",
        save="-tf3" + gene + save_PRJNA779749,
)
```


## Additional validation of whole hypothalamus predictions

```{python}
PRJNA847050_etr = PRJNA847050_counts[PRJNA847050_counts.obs["train"]]
PRJNA815819_etr = PRJNA815819_counts[PRJNA815819_counts.obs["train"]]
PRJNA798401_etr = PRJNA798401_counts[PRJNA798401_counts.obs["train"]]
PRJNA723345_etr = PRJNA723345_counts[PRJNA723345_counts.obs["train"]]
PRJNA722418_etr = PRJNA722418_counts[PRJNA722418_counts.obs["train"]]
PRJNA705596_etr = PRJNA705596_counts[PRJNA705596_counts.obs["train"]]
PRJNA679294_etr = PRJNA679294_counts[PRJNA679294_counts.obs["train"]]
PRJNA611624_etr = PRJNA611624_counts[PRJNA611624_counts.obs["train"]]
PRJNA604055_etr = PRJNA604055_counts[PRJNA604055_counts.obs["train"]]
PRJNA548532_etr = PRJNA548532_counts[PRJNA548532_counts.obs["train"]]
PRJNA515063_etr = PRJNA515063_counts[PRJNA515063_counts.obs["train"]]
PRJNA453138_etr = PRJNA453138_counts[PRJNA453138_counts.obs["train"]]

traindata = concat(
    [
        PRJNA847050_etr,
        PRJNA815819_etr,
        PRJNA798401_etr,
        PRJNA722418_etr,
        PRJNA705596_etr,
        PRJNA679294_etr,
        PRJNA611624_etr,
        PRJNA604055_etr,
        PRJNA548532_etr,
        PRJNA515063_etr,
        PRJNA453138_etr,
    ],
    join="outer",
)

traindata = traindata[
    :,
    ~traindata.var_names.str.match(r"(^Hla-|^Ig[hjkl]|^Rna|^mt-|^Rp[sl]|^Hb[^(p)]|^Gm)"),
]
traindata = traindata[:, ~traindata.var_names.isin(hk_genes1)]

sc.pp.filter_genes(traindata, min_cells=3)
sc.pp.normalize_total(traindata, target_sum=1e4)
sc.pp.log1p(traindata)
sc.pp.regress_out(traindata, ["nCount_RNA", "percent_mito_ribo"])


X = pd.DataFrame(
    traindata.X, columns=traindata.var_names, index=traindata.obs_names
)

X_uni = X.loc[:, uni_fs]
X_uni
```

```{python}
y = traindata.obs["region"]

# Compute the proportion of each category
prop = y.value_counts(normalize=True)

# Sort the categories by their proportion
cat = pd.Categorical(y, categories=prop.index.sort_values(), ordered=True)

# Get the integer codes of the categories
codes = cat.codes
```

### Hajdarovic et al. 2021

```{python}
PRJNA779749_counts = sc.read_h5ad(
    f"data/PRJNA779749/data/PRJNA779749-astrocytes_dataset-{cb_fpr}-scenic_plus.h5ad"
)

PRJNA779749_regulons = sc.read_h5ad(
    f"data/PRJNA779749/data/PRJNA779749-astrocytes_dataset-{cb_fpr}-regulons.h5ad"
)
```

```{python}
adata_eval2 = PRJNA779749_counts.copy()
# sc.pp.filter_genes(adata_eval2, min_cells=5) # filter genes should be matched with training set
sc.pp.normalize_total(adata_eval2, target_sum=1e4)
sc.pp.log1p(adata_eval2)
sc.pp.regress_out(adata_eval2, ["nCount_RNA", "percent_mito_ribo"])
```

```{python}
df_eval2 = pd.DataFrame(
    adata_eval2.X, columns=adata_eval2.var_names, index=adata_eval2.obs_names
)
```

```{python}

df_eval2 = df_eval2.loc[
    :, [g for g in uni_fs if g in adata_eval2.var_names]
]
df_eval2.head()
```

```{python}
X_uni_to_PRJNA779749 = X_uni.loc[:, [g for g in uni_fs if g in adata_eval2.var_names]]
subregional_model.fit(X_uni_to_PRJNA779749, codes)

joblib.dump(
    subregional_model,
    f"models/svm/best-logit-subregional_PRJNA779749_astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

with open("/data/data/resolved_subregions_by_microclusters-replic-3/fs_PRJNA779749_logit_features.tsv", "w") as f:
    for i in X_uni_to_PRJNA779749.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist():
        f.write(str(i) + "\n")
    f.close()

print(X_uni_to_PRJNA779749.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist())
```

```{python}
subregional_model2.fit(X_uni_to_PRJNA779749, codes)

joblib.dump(
    subregional_model2,
    f"models/svm/best-xgboost-subregional_PRJNA779749_astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

with open("/data/data/resolved_subregions_by_microclusters-replic-3/fs_PRJNA779749_xgboost_features.tsv", "w") as f:
    for i in X_uni_to_PRJNA779749.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist():
        f.write(str(i) + "\n")
    f.close()

print(X_uni_to_PRJNA779749.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist())
```

#### Logit

```{python}

# Generate labels for whole hypothalamus reference dataset
predictions_logit_PRJNA779749 = subregional_model.predict(df_eval2)
adata_eval2.obs["predict_logit_subregion"] = adata_eval2.obs["condit"]
adata_eval2.obs["predict_logit_subregion"] = predictions_logit_PRJNA779749
adata_eval2.obs["predict_logit_subregion"] = pd.Categorical(
    values=adata_eval2.obs["predict_logit_subregion"].astype(str),
    categories=natsorted(
        map(str, np.unique(adata_eval2.obs["predict_logit_subregion"].astype(str)))
    ),
)

PRJNA779749_regulons.obs["predict_logit_subregion"] = adata_eval2.obs["predict_logit_subregion"]
```

```{python}
adata_eval2.obsm["X_umap_subfunct"] = adata_eval2.obsm["X_umap"]

reducer_PRJNA779749 = UMAP(
    n_neighbors=ks,
    n_epochs=1000,
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    densmap=True,
    n_components=2,
    random_state=reseed,
    verbose=False,
)
# reducer_PRJNA779749.fit(
#     adata_eval2.obsm["X_aucell"], adata_eval2.obs["predict_logit_subregion"].astype(str)
# )

reducer_PRJNA779749.fit(
    adata_eval2.to_df().loc[:, X_uni_to_PRJNA779749.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist()], adata_eval2.obs["predict_logit_subregion"].astype(str)
)
```

```{python}
# adata_eval2.obsm["X_umap_logit"] = reducer_PRJNA779749.transform(adata_eval2.obsm["X_aucell"])
adata_eval2.obsm["X_umap_logit"] = reducer_PRJNA779749.transform(adata_eval2.to_df().loc[:, X_uni_to_PRJNA779749.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist()])
PRJNA779749_regulons.obsm["X_umap_logit"] = adata_eval2.obsm["X_umap_logit"]
```

```{python}
adata_eval2.write(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_logit-subregional_PRJNA779749-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.h5ad"
)
adata_eval2.write_loom(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_logit-subregional_PRJNA779749-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.loom"
)
pd.DataFrame(adata_eval2.obsm["X_umap_logit"], index=adata_eval2.obs_names).to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_logit-subregional_PRJNA779749-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}-umap-logit.tsv",
    sep="\t",
    header=True,
)
pd.DataFrame(adata_eval2.obsm["X_umap_subfunct"], index=adata_eval2.obs_names).to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/PRJNA779749-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}-umap-subfunct.tsv",
    sep="\t",
    header=True,
)
```

```{python}
save_PRJNA779749 = f"-best_logit-subregional_supervised-PRJNA779749-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pdf"

sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=["predict_logit_subregion", "k_tree"],
    title=f"UMAP supervised subfunction: PRJNA779749 (amb.FPR={cb_fpr}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save=save_PRJNA779749)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=["predict_logit_subregion", "k_tree"],
    title=f"UMAP supervised density logit prediction: PRJNA779749 (amb.FPR={cb_fpr}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save="-predict_logit_subregion" + save_PRJNA779749,
)
```

#### XGBoost

```{python}
# Generate labels for whole hypothalamus reference dataset
predictions_xgboost_PRJNA779749 = subregional_model2.predict(df_eval2)
adata_eval2.obs["predict_xgboost_subregion"] = adata_eval2.obs["condit"]
adata_eval2.obs["predict_xgboost_subregion"] = predictions_xgboost_PRJNA779749
adata_eval2.obs["predict_xgboost_subregion"] = pd.Categorical(
    values=adata_eval2.obs["predict_xgboost_subregion"].astype(str),
    categories=natsorted(
        map(str, np.unique(adata_eval2.obs["predict_xgboost_subregion"].astype(str)))
    ),
)

PRJNA779749_regulons.obs["predict_xgboost_subregion"] = adata_eval2.obs["predict_xgboost_subregion"]
```

```{python}
reducer_PRJNA779749 = UMAP(
    n_neighbors=ks,
    n_epochs=1000,
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    densmap=True,
    n_components=2,
    random_state=reseed,
    verbose=False,
)
# reducer_PRJNA779749.fit(
#     adata_eval2.obsm["X_aucell"],
#     adata_eval2.obs["predict_xgboost_subregion"].astype(str)
# )

reducer_PRJNA779749.fit(
    adata_eval2.to_df().loc[:, X_uni_to_PRJNA779749.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist()], adata_eval2.obs["predict_xgboost_subregion"].astype(str)
)
```

```{python}
# adata_eval2.obsm["X_umap"] = reducer_PRJNA779749.transform(adata_eval2.obsm["X_aucell"])
adata_eval2.obsm["X_umap"] = reducer_PRJNA779749.transform(adata_eval2.to_df().loc[:, X_uni_to_PRJNA779749.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist()])
PRJNA779749_regulons.obsm["X_umap_xgboost"] = adata_eval2.obsm["X_umap"]
```

```{python}
adata_eval2.write(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_xgboost-subregional_PRJNA779749-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.h5ad"
)
adata_eval2.write_loom(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_xgboost-subregional_PRJNA779749-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.loom"
)
pd.DataFrame(adata_eval2.obsm["X_umap"], index=adata_eval2.obs_names).to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_xgboost-subregional_PRJNA779749-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}-umap-xgboost.tsv",
    sep="\t",
    header=True,
)
```

```{python}
save_PRJNA779749 = f"-best_xgboost-subregional_supervised-PRJNA779749-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pdf"

sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=["predict_xgboost_subregion", "k_tree"],
    title=f"UMAP supervised subfunction: PRJNA779749 (amb.FPR={cb_fpr}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save=save_PRJNA779749,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=["predict_xgboost_subregion"],
    title=f"UMAP: supervised density XGBoost, PRJNA779749 \n(amb.FPR={cb_fpr}, k={k}, MSP={connectivity_model}, \nmetric={metric}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save="-predict_xgboost_subregion" + save_PRJNA779749,
)
```

```{python}
npepdf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in npep if g in adata_eval2.var_names])]
npepdf.describe()
npepcols = [col for col in npepdf.columns if npepdf[col].quantile(0.985) > 1]

for gene in npepcols:
    sc.pl.umap(
        adata_eval2,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        vmin=0.0,
        vmax="p98.5",
        na_color="#9A9FB080",
        save="-npep-" + gene + save_PRJNA779749,
)
```

```{python}
nprdf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in npr if g in adata_eval2.var_names])]
nprdf.describe()
```

```{python}
nprdf.quantile(q=[0.5, 0.9, 0.985, 1.0], axis=0)
```

```{python}
nprcols = [col for col in nprdf.columns if nprdf[col].quantile(0.985) > 1]
nprcols3 = [col for col in nprdf.columns if col not in nprcols and nprdf[col].max() == 1]
nprcols2 = [col for col in nprdf.columns if col not in nprcols and col not in nprcols3]
print(nprcols)
print(nprcols2)
print(nprcols3)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nprcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-npr" + save_PRJNA779749,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nprcols2,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-npr2" + save_PRJNA779749,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nprcols3,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
    na_color="#9A9FB080",
    ncols=8,
    save="-npr3" + save_PRJNA779749,
)
```

```{python}
nmrdf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in nmr if g in adata_eval2.var_names])]
nmrdf.describe()
```

```{python}
nmrcols = [col for col in nmrdf.columns if nmrdf[col].quantile(0.985) > 1]
nmrcols3 = [col for col in nmrdf.columns if col not in nmrcols and nmrdf[col].max() == 1]
nmrcols2 = [col for col in nmrdf.columns if col not in nmrcols and col not in nmrcols3]
print(nmrcols)
print(nmrcols2)
print(nmrcols3)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nmrcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr" + save_PRJNA779749,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nmrcols2,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr2" + save_PRJNA779749,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nmrcols3,
    frameon=False,
    show=True,
    size=40,
    cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr3" + save_PRJNA779749,
)
```

```{python}
adddf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in genes_embed if g in adata_eval2.var_names])]
adddf.describe()
```

```{python}
agcols = [col for col in adddf.columns if adddf[col].quantile(0.985) > 1]
agcols3 = [col for col in adddf.columns if col not in agcols and adddf[col].max() == 1]
agcols2 = [col for col in adddf.columns if col not in agcols and col not in agcols3]
print(agcols)
print(agcols2)
print(agcols3)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=agcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen" + save_PRJNA779749,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=agcols2,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen2" + save_PRJNA779749,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=agcols3,
    frameon=False,
    show=True,
    size=40,
    cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen3" + save_PRJNA779749,
)
```

```{python}
tfdf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in tf_genes if g in adata_eval2.var_names])]
tfdf.describe()
```

```{python}
tfdf.quantile(q=[0.5, 0.9, 0.985, 1.0], axis=0)
```

```{python}
tfcols = [col for col in tfdf.columns if tfdf[col].quantile(0.9) > 3]
tfcols3 = [col for col in tfdf.columns if col not in tfcols and tfdf[col].max() == 1]
tfcols2 = [col for col in tfdf.columns if col not in tfcols and tfdf[col].max() > 1]

print(tfcols)
print(tfcols2)
print(tfcols3)
```

```{python}
for gene in tfcols:
    sc.pl.umap(
        adata_eval2,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        vmin=0.0,
        vmax="p90.0",
        na_color="#9A9FB080",
        save="-tf1-" + gene + save_PRJNA779749,
)
```

```{python}
for gene in tfcols2:
    sc.pl.umap(
        adata_eval2,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        vmin=0.0,
        na_color="#9A9FB080",
        save="-tf2" + gene + save_PRJNA779749,
)
```

```{python}
for gene in tfcols3:
    sc.pl.umap(
        adata_eval2,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
        vmin=0.0,
        na_color="#9A9FB080",
        save="-tf3" + gene + save_PRJNA779749,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=nprcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-npr" + save_PRJNA779749,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=nmrcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr" + save_PRJNA779749,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=agcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen" + save_PRJNA779749,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=tfcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    save="-tf" + save_PRJNA779749,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=nprcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-npr" + save_PRJNA779749,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=nmrcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr" + save_PRJNA779749,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=agcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen" + save_PRJNA779749,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=tfcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    save="-tf" + save_PRJNA779749,
)
```


### Romanov et al. 2020

```{python}
PRJNA548917_counts = sc.read_h5ad(
    f"data/PRJNA548917/data/PRJNA548917-astrocytes_dataset-{cb_fpr}-scenic_plus.h5ad"
)

PRJNA548917_regulons = sc.read_h5ad(
    f"data/PRJNA548917/data/PRJNA548917-astrocytes_dataset-{cb_fpr}-regulons.h5ad"
)
```

```{python}
adata_eval2 = PRJNA548917_counts.copy()
# sc.pp.filter_genes(adata_eval2, min_cells=5) # filter genes should be matched with training set
sc.pp.normalize_total(adata_eval2, target_sum=1e4)
sc.pp.log1p(adata_eval2)
sc.pp.regress_out(adata_eval2, ["nCount_RNA", "percent_mito_ribo"])
```

```{python}
df_eval2 = pd.DataFrame(
    adata_eval2.X, columns=adata_eval2.var_names, index=adata_eval2.obs_names
)
```

```{python}

df_eval2 = df_eval2.loc[
    :, [g for g in uni_fs if g in adata_eval2.var_names]
]
df_eval2.head()
```

```{python}
X_uni_to_PRJNA548917 = X_uni.loc[:, [g for g in uni_fs if g in adata_eval2.var_names]]
subregional_model.fit(X_uni_to_PRJNA548917, codes)

joblib.dump(
    subregional_model,
    f"models/svm/best-logit-subregional_PRJNA548917_astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

with open("/data/data/resolved_subregions_by_microclusters-replic-3/fs_PRJNA548917_logit_features.tsv", "w") as f:
    for i in X_uni_to_PRJNA548917.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist():
        f.write(str(i) + "\n")
    f.close()

print(X_uni_to_PRJNA548917.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist())
```

```{python}
subregional_model2.fit(X_uni_to_PRJNA548917, codes)

joblib.dump(
    subregional_model2,
    f"models/svm/best-xgboost-subregional_PRJNA548917_astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

with open("/data/data/resolved_subregions_by_microclusters-replic-3/fs_PRJNA548917_xgboost_features.tsv", "w") as f:
    for i in X_uni_to_PRJNA548917.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist():
        f.write(str(i) + "\n")
    f.close()

print(X_uni_to_PRJNA548917.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist())
```

#### Logit

```{python}

# Generate labels for whole hypothalamus reference dataset
predictions_logit_PRJNA548917 = subregional_model.predict(df_eval2)
adata_eval2.obs["predict_logit_subregion"] = adata_eval2.obs["condit"]
adata_eval2.obs["predict_logit_subregion"] = predictions_logit_PRJNA548917
adata_eval2.obs["predict_logit_subregion"] = pd.Categorical(
    values=adata_eval2.obs["predict_logit_subregion"].astype(str),
    categories=natsorted(
        map(str, np.unique(adata_eval2.obs["predict_logit_subregion"].astype(str)))
    ),
)

PRJNA548917_regulons.obs["predict_logit_subregion"] = adata_eval2.obs["predict_logit_subregion"]
```

```{python}
adata_eval2.obsm["X_umap_subfunct"] = adata_eval2.obsm["X_umap"]

reducer_PRJNA548917 = UMAP(
    n_neighbors=ks,
    n_epochs=1000,
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    densmap=True,
    n_components=2,
    random_state=reseed,
    verbose=False,
)
# reducer_PRJNA548917.fit(
#     adata_eval2.obsm["X_aucell"], adata_eval2.obs["predict_logit_subregion"].astype(str)
# )
reducer_PRJNA548917.fit(
    adata_eval2.to_df().loc[:, X_uni_to_PRJNA548917.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist()], adata_eval2.obs["predict_logit_subregion"].astype(str)
)
```

```{python}
# adata_eval2.obsm["X_umap_logit"] = reducer_PRJNA548917.transform(adata_eval2.obsm["X_aucell"])
adata_eval2.obsm["X_umap_logit"] = reducer_PRJNA548917.transform(adata_eval2.to_df().loc[:, X_uni_to_PRJNA548917.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist()])
PRJNA548917_regulons.obsm["X_umap_logit"] = adata_eval2.obsm["X_umap_logit"]
```

```{python}
adata_eval2.write(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_logit-subregional_PRJNA548917-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.h5ad"
)
adata_eval2.write_loom(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_logit-subregional_PRJNA548917-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.loom"
)
pd.DataFrame(adata_eval2.obsm["X_umap_logit"], index=adata_eval2.obs_names).to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_logit-subregional_PRJNA548917-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}-umap-logit.tsv",
    sep="\t",
    header=True,
)
pd.DataFrame(adata_eval2.obsm["X_umap_subfunct"], index=adata_eval2.obs_names).to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/PRJNA548917-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}-umap-subfunct.tsv",
    sep="\t",
    header=True,
)
```

```{python}
save_PRJNA548917 = f"-best_logit-subregional_supervised-PRJNA548917-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pdf"

sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=["predict_logit_subregion", "k_tree"],
    title=f"UMAP supervised subfunction: PRJNA548917 (amb.FPR={cb_fpr}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save=save_PRJNA548917)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=["predict_logit_subregion", "k_tree"],
    title=f"UMAP supervised density logit prediction: PRJNA548917 (amb.FPR={cb_fpr}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save="-predict_logit_subregion" + save_PRJNA548917,
)
```

#### XGBoost

```{python}
# Generate labels for whole hypothalamus reference dataset
predictions_xgboost_PRJNA548917 = subregional_model2.predict(df_eval2)
adata_eval2.obs["predict_xgboost_subregion"] = adata_eval2.obs["condit"]
adata_eval2.obs["predict_xgboost_subregion"] = predictions_xgboost_PRJNA548917
adata_eval2.obs["predict_xgboost_subregion"] = pd.Categorical(
    values=adata_eval2.obs["predict_xgboost_subregion"].astype(str),
    categories=natsorted(
        map(str, np.unique(adata_eval2.obs["predict_xgboost_subregion"].astype(str)))
    ),
)

PRJNA548917_regulons.obs["predict_xgboost_subregion"] = adata_eval2.obs["predict_xgboost_subregion"]
```

```{python}
reducer_PRJNA548917 = UMAP(
    n_neighbors=ks,
    n_epochs=1000,
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    densmap=True,
    n_components=2,
    random_state=reseed,
    verbose=False,
)
# reducer_PRJNA548917.fit(
#     adata_eval2.obsm["X_aucell"],
#     adata_eval2.obs["predict_xgboost_subregion"].astype(str)
# )

reducer_PRJNA548917.fit(
    adata_eval2.to_df().loc[:, X_uni_to_PRJNA548917.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist()], adata_eval2.obs["predict_xgboost_subregion"].astype(str)
)
```

```{python}
# adata_eval2.obsm["X_umap"] = reducer_PRJNA548917.transform(adata_eval2.obsm["X_aucell"])
adata_eval2.obsm["X_umap"] = reducer_PRJNA548917.transform(adata_eval2.to_df().loc[:, X_uni_to_PRJNA548917.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist()])
PRJNA548917_regulons.obsm["X_umap_xgboost"] = adata_eval2.obsm["X_umap"]
```

```{python}
adata_eval2.write(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_xgboost-subregional_PRJNA548917-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.h5ad"
)
adata_eval2.write_loom(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_xgboost-subregional_PRJNA548917-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.loom"
)
pd.DataFrame(adata_eval2.obsm["X_umap"], index=adata_eval2.obs_names).to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_xgboost-subregional_PRJNA548917-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}-umap-xgboost.tsv",
    sep="\t",
    header=True,
)
```

```{python}
save_PRJNA548917 = f"-best_xgboost-subregional_supervised-PRJNA548917-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pdf"

sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=["predict_xgboost_subregion", "k_tree"],
    title=f"UMAP supervised subfunction: PRJNA548917 (amb.FPR={cb_fpr}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save=save_PRJNA548917,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=["predict_xgboost_subregion"],
    title=f"UMAP: supervised density XGBoost, PRJNA548917 \n(amb.FPR={cb_fpr}, k={k}, MSP={connectivity_model}, \nmetric={metric}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save="-predict_xgboost_subregion" + save_PRJNA548917,
)
```

```{python}
npepdf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in npep if g in adata_eval2.var_names])]
npepdf.describe()
npepcols = [col for col in npepdf.columns if npepdf[col].quantile(0.985) > 1]

for gene in npepcols:
    sc.pl.umap(
        adata_eval2,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        vmin=0.0,
        vmax="p98.5",
        na_color="#9A9FB080",
        save="-npep-" + gene + save_PRJNA548917,
)
```

```{python}
nprdf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in npr if g in adata_eval2.var_names])]
nprdf.describe()
```

```{python}
nprdf.quantile(q=[0.5, 0.9, 0.985, 1.0], axis=0)
```

```{python}
nprcols = [col for col in nprdf.columns if nprdf[col].quantile(0.985) > 1]
nprcols3 = [col for col in nprdf.columns if col not in nprcols and nprdf[col].max() == 1]
nprcols2 = [col for col in nprdf.columns if col not in nprcols and col not in nprcols3]
print(nprcols)
print(nprcols2)
print(nprcols3)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nprcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-npr" + save_PRJNA548917,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nprcols2,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-npr2" + save_PRJNA548917,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nprcols3,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
    na_color="#9A9FB080",
    ncols=8,
    save="-npr3" + save_PRJNA548917,
)
```

```{python}
nmrdf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in nmr if g in adata_eval2.var_names])]
nmrdf.describe()
```

```{python}
nmrcols = [col for col in nmrdf.columns if nmrdf[col].quantile(0.985) > 1]
nmrcols3 = [col for col in nmrdf.columns if col not in nmrcols and nmrdf[col].max() == 1]
nmrcols2 = [col for col in nmrdf.columns if col not in nmrcols and col not in nmrcols3]
print(nmrcols)
print(nmrcols2)
print(nmrcols3)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nmrcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr" + save_PRJNA548917,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nmrcols2,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr2" + save_PRJNA548917,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nmrcols3,
    frameon=False,
    show=True,
    size=40,
    cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr3" + save_PRJNA548917,
)
```

```{python}
adddf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in genes_embed if g in adata_eval2.var_names])]
adddf.describe()
```

```{python}
agcols = [col for col in adddf.columns if adddf[col].quantile(0.985) > 1]
agcols3 = [col for col in adddf.columns if col not in agcols and adddf[col].max() == 1]
agcols2 = [col for col in adddf.columns if col not in agcols and col not in agcols3]
print(agcols)
print(agcols2)
print(agcols3)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=agcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen" + save_PRJNA548917,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=agcols2,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen2" + save_PRJNA548917,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=agcols3,
    frameon=False,
    show=True,
    size=40,
    cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen3" + save_PRJNA548917,
)
```

```{python}
tfdf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in tf_genes if g in adata_eval2.var_names])]
tfdf.describe()
```

```{python}
tfdf.quantile(q=[0.5, 0.9, 0.985, 1.0], axis=0)
```

```{python}
tfcols = [col for col in tfdf.columns if tfdf[col].quantile(0.9) > 3]
tfcols3 = [col for col in tfdf.columns if col not in tfcols and tfdf[col].max() == 1]
tfcols2 = [col for col in tfdf.columns if col not in tfcols and tfdf[col].max() > 1]

print(tfcols)
print(tfcols2)
print(tfcols3)
```

```{python}
for gene in tfcols:
    sc.pl.umap(
        adata_eval2,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        vmin=0.0,
        vmax="p90.0",
        na_color="#9A9FB080",
        save="-tf1-" + gene + save_PRJNA548917,
)
```

```{python}
for gene in tfcols2:
    sc.pl.umap(
        adata_eval2,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        vmin=0.0,
        na_color="#9A9FB080",
        save="-tf2" + gene + save_PRJNA548917,
)
```

```{python}
for gene in tfcols3:
    sc.pl.umap(
        adata_eval2,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
        vmin=0.0,
        na_color="#9A9FB080",
        save="-tf3" + gene + save_PRJNA548917,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=nprcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-npr" + save_PRJNA548917,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=nmrcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr" + save_PRJNA548917,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=agcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen" + save_PRJNA548917,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=tfcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    save="-tf" + save_PRJNA548917,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=nprcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-npr" + save_PRJNA548917,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=nmrcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr" + save_PRJNA548917,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=agcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen" + save_PRJNA548917,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=tfcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    save="-tf" + save_PRJNA548917,
)
```

### Kim et al 2020

```{python}
PRJNA547712_counts = sc.read_h5ad(
    f"data/PRJNA547712/data/PRJNA547712-astrocytes_dataset-{cb_fpr}-scenic_plus.h5ad"
)

PRJNA547712_regulons = sc.read_h5ad(
    f"data/PRJNA547712/data/PRJNA547712-astrocytes_dataset-{cb_fpr}-regulons.h5ad"
)
```

```{python}
adata_eval2 = PRJNA547712_counts.copy()
# sc.pp.filter_genes(adata_eval2, min_cells=5) # filter genes should be matched with training set
sc.pp.normalize_total(adata_eval2, target_sum=1e4)
sc.pp.log1p(adata_eval2)
sc.pp.regress_out(adata_eval2, ["nCount_RNA", "percent_mito_ribo"])
```

```{python}
df_eval2 = pd.DataFrame(
    adata_eval2.X, columns=adata_eval2.var_names, index=adata_eval2.obs_names
)
```

```{python}

df_eval2 = df_eval2.loc[
    :, [g for g in uni_fs if g in adata_eval2.var_names]
]
df_eval2.head()
```

```{python}
X_uni_to_PRJNA547712 = X_uni.loc[:, [g for g in uni_fs if g in adata_eval2.var_names]]
subregional_model.fit(X_uni_to_PRJNA547712, codes)

joblib.dump(
    subregional_model,
    f"models/svm/best-logit-subregional_PRJNA547712_astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

with open("/data/data/resolved_subregions_by_microclusters-replic-3/fs_PRJNA547712_logit_features.tsv", "w") as f:
    for i in X_uni_to_PRJNA547712.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist():
        f.write(str(i) + "\n")
    f.close()

print(X_uni_to_PRJNA547712.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist())
```

```{python}
subregional_model2.fit(X_uni_to_PRJNA547712, codes)

joblib.dump(
    subregional_model2,
    f"models/svm/best-xgboost-subregional_PRJNA547712_astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

with open("/data/data/resolved_subregions_by_microclusters-replic-3/fs_PRJNA547712_xgboost_features.tsv", "w") as f:
    for i in X_uni_to_PRJNA547712.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist():
        f.write(str(i) + "\n")
    f.close()

print(X_uni_to_PRJNA547712.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist())
```

#### Logit

```{python}

# Generate labels for whole hypothalamus reference dataset
predictions_logit_PRJNA547712 = subregional_model.predict(df_eval2)
adata_eval2.obs["predict_logit_subregion"] = adata_eval2.obs["condit"]
adata_eval2.obs["predict_logit_subregion"] = predictions_logit_PRJNA547712
adata_eval2.obs["predict_logit_subregion"] = pd.Categorical(
    values=adata_eval2.obs["predict_logit_subregion"].astype(str),
    categories=natsorted(
        map(str, np.unique(adata_eval2.obs["predict_logit_subregion"].astype(str)))
    ),
)

PRJNA547712_regulons.obs["predict_logit_subregion"] = adata_eval2.obs["predict_logit_subregion"]
```

```{python}
adata_eval2.obsm["X_umap_subfunct"] = adata_eval2.obsm["X_umap"]

reducer_PRJNA547712 = UMAP(
    n_neighbors=ks,
    n_epochs=1000,
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    densmap=True,
    n_components=2,
    random_state=reseed,
    verbose=False,
)
# reducer_PRJNA547712.fit(
#     adata_eval2.obsm["X_aucell"], adata_eval2.obs["predict_logit_subregion"].astype(str)
# )

reducer_PRJNA547712.fit(
    adata_eval2.to_df().loc[:, X_uni_to_PRJNA547712.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist()], adata_eval2.obs["predict_logit_subregion"].astype(str)
)
```

```{python}
# adata_eval2.obsm["X_umap_logit"] = reducer_PRJNA547712.transform(adata_eval2.obsm["X_aucell"])
adata_eval2.obsm["X_umap_logit"] = reducer_PRJNA547712.transform(adata_eval2.to_df().loc[:, X_uni_to_PRJNA547712.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist()])
PRJNA547712_regulons.obsm["X_umap_logit"] = adata_eval2.obsm["X_umap_logit"]
```

```{python}
adata_eval2.write(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_logit-subregional_PRJNA547712-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.h5ad"
)
adata_eval2.write_loom(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_logit-subregional_PRJNA547712-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.loom"
)
pd.DataFrame(adata_eval2.obsm["X_umap_logit"], index=adata_eval2.obs_names).to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_logit-subregional_PRJNA547712-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}-umap-logit.tsv",
    sep="\t",
    header=True,
)
pd.DataFrame(adata_eval2.obsm["X_umap_subfunct"], index=adata_eval2.obs_names).to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/PRJNA547712-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}-umap-subfunct.tsv",
    sep="\t",
    header=True,
)
```

```{python}
save_PRJNA547712 = f"-best_logit-subregional_supervised-PRJNA547712-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pdf"

sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=["predict_logit_subregion", "k_tree"],
    title=f"UMAP supervised subfunction: PRJNA547712 (amb.FPR={cb_fpr}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save=save_PRJNA547712)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=["predict_logit_subregion", "k_tree"],
    title=f"UMAP supervised density logit prediction: PRJNA547712 (amb.FPR={cb_fpr}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save="-predict_logit_subregion" + save_PRJNA547712,
)
```

#### XGBoost

```{python}
# Generate labels for whole hypothalamus reference dataset
predictions_xgboost_PRJNA547712 = subregional_model2.predict(df_eval2)
adata_eval2.obs["predict_xgboost_subregion"] = adata_eval2.obs["condit"]
adata_eval2.obs["predict_xgboost_subregion"] = predictions_xgboost_PRJNA547712
adata_eval2.obs["predict_xgboost_subregion"] = pd.Categorical(
    values=adata_eval2.obs["predict_xgboost_subregion"].astype(str),
    categories=natsorted(
        map(str, np.unique(adata_eval2.obs["predict_xgboost_subregion"].astype(str)))
    ),
)

PRJNA547712_regulons.obs["predict_xgboost_subregion"] = adata_eval2.obs["predict_xgboost_subregion"]
```

```{python}
reducer_PRJNA547712 = UMAP(
    n_neighbors=ks,
    n_epochs=1000,
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    densmap=True,
    n_components=2,
    random_state=reseed,
    verbose=False,
)
# reducer_PRJNA547712.fit(
#     adata_eval2.obsm["X_aucell"],
#     adata_eval2.obs["predict_xgboost_subregion"].astype(str)
# )

reducer_PRJNA547712.fit(
    adata_eval2.to_df().loc[:, X_uni_to_PRJNA547712.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist()], adata_eval2.obs["predict_xgboost_subregion"].astype(str)
)
```

```{python}
# adata_eval2.obsm["X_umap"] = reducer_PRJNA547712.transform(adata_eval2.obsm["X_aucell"])
adata_eval2.obsm["X_umap"] = reducer_PRJNA547712.transform(adata_eval2.to_df().loc[:, X_uni_to_PRJNA547712.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist()])
PRJNA547712_regulons.obsm["X_umap_xgboost"] = adata_eval2.obsm["X_umap"]
```

```{python}
adata_eval2.write(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_xgboost-subregional_PRJNA547712-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.h5ad"
)
adata_eval2.write_loom(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_xgboost-subregional_PRJNA547712-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.loom"
)
pd.DataFrame(adata_eval2.obsm["X_umap"], index=adata_eval2.obs_names).to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_xgboost-subregional_PRJNA547712-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}-umap-xgboost.tsv",
    sep="\t",
    header=True,
)
```

```{python}
save_PRJNA547712 = f"-best_xgboost-subregional_supervised-PRJNA547712-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pdf"

sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=["predict_xgboost_subregion", "k_tree"],
    title=f"UMAP supervised subfunction: PRJNA547712 (amb.FPR={cb_fpr}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save=save_PRJNA547712,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=["predict_xgboost_subregion"],
    title=f"UMAP: supervised density XGBoost, PRJNA547712 \n(amb.FPR={cb_fpr}, k={k}, MSP={connectivity_model}, \nmetric={metric}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save="-predict_xgboost_subregion" + save_PRJNA547712,
)
```

```{python}
npepdf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in npep if g in adata_eval2.var_names])]
npepdf.describe()
npepcols = [col for col in npepdf.columns if npepdf[col].quantile(0.985) > 1]

for gene in npepcols:
    sc.pl.umap(
        adata_eval2,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        vmin=0.0,
        vmax="p98.5",
        na_color="#9A9FB080",
        save="-npep-" + gene + save_PRJNA547712,
)
```

```{python}
nprdf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in npr if g in adata_eval2.var_names])]
nprdf.describe()
```

```{python}
nprdf.quantile(q=[0.5, 0.9, 0.985, 1.0], axis=0)
```

```{python}
nprcols = [col for col in nprdf.columns if nprdf[col].quantile(0.985) > 1]
nprcols3 = [col for col in nprdf.columns if col not in nprcols and nprdf[col].max() == 1]
nprcols2 = [col for col in nprdf.columns if col not in nprcols and col not in nprcols3]
print(nprcols)
print(nprcols2)
print(nprcols3)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nprcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-npr" + save_PRJNA547712,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nprcols2,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-npr2" + save_PRJNA547712,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nprcols3,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
    na_color="#9A9FB080",
    ncols=8,
    save="-npr3" + save_PRJNA547712,
)
```

```{python}
nmrdf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in nmr if g in adata_eval2.var_names])]
nmrdf.describe()
```

```{python}
nmrcols = [col for col in nmrdf.columns if nmrdf[col].quantile(0.985) > 1]
nmrcols3 = [col for col in nmrdf.columns if col not in nmrcols and nmrdf[col].max() == 1]
nmrcols2 = [col for col in nmrdf.columns if col not in nmrcols and col not in nmrcols3]
print(nmrcols)
print(nmrcols2)
print(nmrcols3)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nmrcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr" + save_PRJNA547712,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nmrcols2,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr2" + save_PRJNA547712,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nmrcols3,
    frameon=False,
    show=True,
    size=40,
    cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr3" + save_PRJNA547712,
)
```

```{python}
adddf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in genes_embed if g in adata_eval2.var_names])]
adddf.describe()
```

```{python}
agcols = [col for col in adddf.columns if adddf[col].quantile(0.985) > 1]
agcols3 = [col for col in adddf.columns if col not in agcols and adddf[col].max() == 1]
agcols2 = [col for col in adddf.columns if col not in agcols and col not in agcols3]
print(agcols)
print(agcols2)
print(agcols3)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=agcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen" + save_PRJNA547712,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=agcols2,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen2" + save_PRJNA547712,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=agcols3,
    frameon=False,
    show=True,
    size=40,
    cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen3" + save_PRJNA547712,
)
```

```{python}
tfdf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in tf_genes if g in adata_eval2.var_names])]
tfdf.describe()
```

```{python}
tfdf.quantile(q=[0.5, 0.9, 0.985, 1.0], axis=0)
```

```{python}
tfcols = [col for col in tfdf.columns if tfdf[col].quantile(0.9) > 3]
tfcols3 = [col for col in tfdf.columns if col not in tfcols and tfdf[col].max() == 1]
tfcols2 = [col for col in tfdf.columns if col not in tfcols and tfdf[col].max() > 1]

print(tfcols)
print(tfcols2)
print(tfcols3)
```

```{python}
for gene in tfcols:
    sc.pl.umap(
        adata_eval2,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        vmin=0.0,
        vmax="p90.0",
        na_color="#9A9FB080",
        save="-tf1-" + gene + save_PRJNA547712,
)
```

```{python}
for gene in tfcols2:
    sc.pl.umap(
        adata_eval2,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        vmin=0.0,
        na_color="#9A9FB080",
        save="-tf2" + gene + save_PRJNA547712,
)
```

```{python}
for gene in tfcols3:
    sc.pl.umap(
        adata_eval2,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
        vmin=0.0,
        na_color="#9A9FB080",
        save="-tf3" + gene + save_PRJNA547712,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=nprcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-npr" + save_PRJNA547712,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=nmrcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr" + save_PRJNA547712,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=agcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen" + save_PRJNA547712,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=tfcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    save="-tf" + save_PRJNA547712,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=nprcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-npr" + save_PRJNA547712,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=nmrcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr" + save_PRJNA547712,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=agcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen" + save_PRJNA547712,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=tfcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    save="-tf" + save_PRJNA547712,
)
```

### Zeisel et al. 2018

```{python}
PRJNA438862_counts = sc.read_h5ad(
    f"data/PRJNA438862/data/PRJNA438862-astrocytes_dataset-{cb_fpr}-scenic_plus.h5ad"
)

PRJNA438862_regulons = sc.read_h5ad(
    f"data/PRJNA438862/data/PRJNA438862-astrocytes_dataset-{cb_fpr}-regulons.h5ad"
)
```

```{python}
adata_eval2 = PRJNA438862_counts.copy()
# sc.pp.filter_genes(adata_eval2, min_cells=5) # filter genes should be matched with training set
sc.pp.normalize_total(adata_eval2, target_sum=1e4)
sc.pp.log1p(adata_eval2)
sc.pp.regress_out(adata_eval2, ["nCount_RNA", "percent_mito_ribo"])
```

```{python}
df_eval2 = pd.DataFrame(
    adata_eval2.X, columns=adata_eval2.var_names, index=adata_eval2.obs_names
)
```

```{python}

df_eval2 = df_eval2.loc[
    :, [g for g in uni_fs if g in adata_eval2.var_names]
]
df_eval2.head()
```

```{python}
X_uni_to_PRJNA438862 = X_uni.loc[:, [g for g in uni_fs if g in adata_eval2.var_names]]
subregional_model.fit(X_uni_to_PRJNA438862, codes)

joblib.dump(
    subregional_model,
    f"models/svm/best-logit-subregional_PRJNA438862_astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

with open("/data/data/resolved_subregions_by_microclusters-replic-3/fs_PRJNA438862_logit_features.tsv", "w") as f:
    for i in X_uni_to_PRJNA438862.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist():
        f.write(str(i) + "\n")
    f.close()

print(X_uni_to_PRJNA438862.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist())
```

```{python}
subregional_model2.fit(X_uni_to_PRJNA438862, codes)

joblib.dump(
    subregional_model2,
    f"models/svm/best-xgboost-subregional_PRJNA438862_astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pickle",
)

with open("/data/data/resolved_subregions_by_microclusters-replic-3/fs_PRJNA438862_xgboost_features.tsv", "w") as f:
    for i in X_uni_to_PRJNA438862.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist():
        f.write(str(i) + "\n")
    f.close()

print(X_uni_to_PRJNA438862.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist())
```

#### Logit

```{python}

# Generate labels for whole hypothalamus reference dataset
predictions_logit_PRJNA438862 = subregional_model.predict(df_eval2)
adata_eval2.obs["predict_logit_subregion"] = adata_eval2.obs["condit"]
adata_eval2.obs["predict_logit_subregion"] = predictions_logit_PRJNA438862
adata_eval2.obs["predict_logit_subregion"] = pd.Categorical(
    values=adata_eval2.obs["predict_logit_subregion"].astype(str),
    categories=natsorted(
        map(str, np.unique(adata_eval2.obs["predict_logit_subregion"].astype(str)))
    ),
)

PRJNA438862_regulons.obs["predict_logit_subregion"] = adata_eval2.obs["predict_logit_subregion"]
```

```{python}
adata_eval2.obsm["X_umap_subfunct"] = adata_eval2.obsm["X_umap"]

reducer_PRJNA438862 = UMAP(
    n_neighbors=ks,
    n_epochs=1000,
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    densmap=True,
    n_components=2,
    random_state=reseed,
    verbose=False,
)
# reducer_PRJNA438862.fit(
#     adata_eval2.obsm["X_aucell"], adata_eval2.obs["predict_logit_subregion"].astype(str)
# )

reducer_PRJNA438862.fit(
    adata_eval2.to_df().loc[:, X_uni_to_PRJNA438862.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist()], adata_eval2.obs["predict_logit_subregion"].astype(str)
)
```

```{python}
# adata_eval2.obsm["X_umap_logit"] = reducer_PRJNA438862.transform(adata_eval2.obsm["X_aucell"])
adata_eval2.obsm["X_umap_logit"] = reducer_PRJNA438862.transform(adata_eval2.to_df().loc[:, X_uni_to_PRJNA438862.columns[np.array(subregional_model[1].get_support(indices=True), dtype=int)].tolist()])
PRJNA438862_regulons.obsm["X_umap_logit"] = adata_eval2.obsm["X_umap_logit"]
```

```{python}
adata_eval2.write(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_logit-subregional_PRJNA438862-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.h5ad"
)
adata_eval2.write_loom(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_logit-subregional_PRJNA438862-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.loom"
)
pd.DataFrame(adata_eval2.obsm["X_umap_logit"], index=adata_eval2.obs_names).to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_logit-subregional_PRJNA438862-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}-umap-logit.tsv",
    sep="\t",
    header=True,
)
pd.DataFrame(adata_eval2.obsm["X_umap_subfunct"], index=adata_eval2.obs_names).to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/PRJNA438862-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}-umap-subfunct.tsv",
    sep="\t",
    header=True,
)
```

```{python}
save_PRJNA438862 = f"-best_logit-subregional_supervised-PRJNA438862-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pdf"

sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=["predict_logit_subregion", "k_tree"],
    title=f"UMAP supervised subfunction: PRJNA438862 (amb.FPR={cb_fpr}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save=save_PRJNA438862)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=["predict_logit_subregion", "k_tree"],
    title=f"UMAP supervised density logit prediction: PRJNA438862 (amb.FPR={cb_fpr}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save="-predict_logit_subregion" + save_PRJNA438862,
)
```

#### XGBoost

```{python}
# Generate labels for whole hypothalamus reference dataset
predictions_xgboost_PRJNA438862 = subregional_model2.predict(df_eval2)
adata_eval2.obs["predict_xgboost_subregion"] = adata_eval2.obs["condit"]
adata_eval2.obs["predict_xgboost_subregion"] = predictions_xgboost_PRJNA438862
adata_eval2.obs["predict_xgboost_subregion"] = pd.Categorical(
    values=adata_eval2.obs["predict_xgboost_subregion"].astype(str),
    categories=natsorted(
        map(str, np.unique(adata_eval2.obs["predict_xgboost_subregion"].astype(str)))
    ),
)

PRJNA438862_regulons.obs["predict_xgboost_subregion"] = adata_eval2.obs["predict_xgboost_subregion"]
```

```{python}
reducer_PRJNA438862 = UMAP(
    n_neighbors=ks,
    n_epochs=1000,
    init="spectral",
    learning_rate=0.1,
    min_dist=min_dist,
    spread=spread,
    repulsion_strength=2.0,
    negative_sample_rate=negative_sample_rate,
    densmap=True,
    n_components=2,
    random_state=reseed,
    verbose=False,
)
# reducer_PRJNA438862.fit(
#     adata_eval2.obsm["X_aucell"],
#     adata_eval2.obs["predict_xgboost_subregion"].astype(str)
# )

reducer_PRJNA438862.fit(
    adata_eval2.to_df().loc[:, X_uni_to_PRJNA438862.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist()], adata_eval2.obs["predict_xgboost_subregion"].astype(str)
)
```

```{python}
# adata_eval2.obsm["X_umap"] = reducer_PRJNA438862.transform(adata_eval2.obsm["X_aucell"])
adata_eval2.obsm["X_umap"] = reducer_PRJNA438862.transform(adata_eval2.to_df().loc[:, X_uni_to_PRJNA438862.columns[np.array(subregional_model2[1].get_support(indices=True), dtype=int)].tolist()])
PRJNA438862_regulons.obsm["X_umap_xgboost"] = adata_eval2.obsm["X_umap"]
```

```{python}
adata_eval2.write(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_xgboost-subregional_PRJNA438862-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.h5ad"
)
adata_eval2.write_loom(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_xgboost-subregional_PRJNA438862-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.loom"
)
pd.DataFrame(adata_eval2.obsm["X_umap"], index=adata_eval2.obs_names).to_csv(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/best_xgboost-subregional_PRJNA438862-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}-umap-xgboost.tsv",
    sep="\t",
    header=True,
)
```

```{python}
save_PRJNA438862 = f"-best_xgboost-subregional_supervised-PRJNA438862-astrocytes_datasets-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.pdf"

sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=["predict_xgboost_subregion", "k_tree"],
    title=f"UMAP supervised subfunction: PRJNA438862 (amb.FPR={cb_fpr}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save=save_PRJNA438862,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=["predict_xgboost_subregion"],
    title=f"UMAP: supervised density XGBoost, PRJNA438862 \n(amb.FPR={cb_fpr}, k={k}, MSP={connectivity_model}, \nmetric={metric}, n_genes_excluded={signature})",
    add_outline=True,
    legend_fontsize=12,
    legend_fontoutline=2,
    frameon=False,
    palette="nipy_spectral",
    show=True,
    save="-predict_xgboost_subregion" + save_PRJNA438862,
)
```

```{python}
npepdf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in npep if g in adata_eval2.var_names])]
npepdf.describe()
npepcols = [col for col in npepdf.columns if npepdf[col].quantile(0.985) > 1]

for gene in npepcols:
    sc.pl.umap(
        adata_eval2,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        vmin=0.0,
        vmax="p98.5",
        na_color="#9A9FB080",
        save="-npep-" + gene + save_PRJNA438862,
)
```

```{python}
nprdf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in npr if g in adata_eval2.var_names])]
nprdf.describe()
```

```{python}
nprdf.quantile(q=[0.5, 0.9, 0.985, 1.0], axis=0)
```

```{python}
nprcols = [col for col in nprdf.columns if nprdf[col].quantile(0.985) > 1]
nprcols3 = [col for col in nprdf.columns if col not in nprcols and nprdf[col].max() == 1]
nprcols2 = [col for col in nprdf.columns if col not in nprcols and col not in nprcols3]
print(nprcols)
print(nprcols2)
print(nprcols3)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nprcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-npr" + save_PRJNA438862,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nprcols2,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-npr2" + save_PRJNA438862,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nprcols3,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
    na_color="#9A9FB080",
    ncols=8,
    save="-npr3" + save_PRJNA438862,
)
```

```{python}
nmrdf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in nmr if g in adata_eval2.var_names])]
nmrdf.describe()
```

```{python}
nmrcols = [col for col in nmrdf.columns if nmrdf[col].quantile(0.985) > 1]
nmrcols3 = [col for col in nmrdf.columns if col not in nmrcols and nmrdf[col].max() == 1]
nmrcols2 = [col for col in nmrdf.columns if col not in nmrcols and col not in nmrcols3]
print(nmrcols)
print(nmrcols2)
print(nmrcols3)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nmrcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr" + save_PRJNA438862,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nmrcols2,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr2" + save_PRJNA438862,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=nmrcols3,
    frameon=False,
    show=True,
    size=40,
    cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr3" + save_PRJNA438862,
)
```

```{python}
adddf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in genes_embed if g in adata_eval2.var_names])]
adddf.describe()
```

```{python}
agcols = [col for col in adddf.columns if adddf[col].quantile(0.985) > 1]
agcols3 = [col for col in adddf.columns if col not in agcols and adddf[col].max() == 1]
agcols2 = [col for col in adddf.columns if col not in agcols and col not in agcols3]
print(agcols)
print(agcols2)
print(agcols3)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=agcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen" + save_PRJNA438862,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=agcols2,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen2" + save_PRJNA438862,
)
```

```{python}
sc.pl.umap(
    adata_eval2,
    color=agcols3,
    frameon=False,
    show=True,
    size=40,
    cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
    vmin=0.0,
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen3" + save_PRJNA438862,
)
```

```{python}
tfdf = pd.DataFrame(adata_eval2.raw.X.todense(), columns=adata_eval2.var_names, index=adata_eval2.obs_names).loc[:, np.array([g for g in tf_genes if g in adata_eval2.var_names])]
tfdf.describe()
```

```{python}
tfdf.quantile(q=[0.5, 0.9, 0.985, 1.0], axis=0)
```

```{python}
tfcols = [col for col in tfdf.columns if tfdf[col].quantile(0.9) > 3]
tfcols3 = [col for col in tfdf.columns if col not in tfcols and tfdf[col].max() == 1]
tfcols2 = [col for col in tfdf.columns if col not in tfcols and tfdf[col].max() > 1]

print(tfcols)
print(tfcols2)
print(tfcols3)
```

```{python}
for gene in tfcols:
    sc.pl.umap(
        adata_eval2,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        vmin=0.0,
        vmax="p90.0",
        na_color="#9A9FB080",
        save="-tf1-" + gene + save_PRJNA438862,
)
```

```{python}
for gene in tfcols2:
    sc.pl.umap(
        adata_eval2,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        vmin=0.0,
        na_color="#9A9FB080",
        save="-tf2" + gene + save_PRJNA438862,
)
```

```{python}
for gene in tfcols3:
    sc.pl.umap(
        adata_eval2,
        color=gene,
        frameon=False,
        show=False,
        size=40,
        cmap=matplotlib.colors.LinearSegmentedColormap.from_list("YlBk", ["yellow", "black"], N=2),
        vmin=0.0,
        na_color="#9A9FB080",
        save="-tf3" + gene + save_PRJNA438862,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=nprcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-npr" + save_PRJNA438862,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=nmrcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr" + save_PRJNA438862,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=agcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen" + save_PRJNA438862,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_logit",
    color=tfcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    save="-tf" + save_PRJNA438862,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=nprcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-npr" + save_PRJNA438862,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=nmrcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-nmr" + save_PRJNA438862,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=agcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    ncols=8,
    save="-adgen" + save_PRJNA438862,
)
```

```{python}
sc.pl.embedding(
    adata_eval2,
    basis="X_umap_subfunct",
    color=tfcols,
    frameon=False,
    show=True,
    size=40,
    vmin=0.0,
    vmax="p98.5",
    na_color="#9A9FB080",
    save="-tf" + save_PRJNA438862,
)
```

# Save Differential Expression Results

```{python}
PRJNA779749_regulons.write(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/PRJNA779749_regulons-DER-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.h5ad"
)

PRJNA548917_regulons.write(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/PRJNA548917_regulons-DER-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.h5ad"
)

PRJNA547712_regulons.write(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/PRJNA547712_regulons-DER-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.h5ad"
)

PRJNA438862_regulons.write(
    f"/data/data/resolved_subregions_by_microclusters-replic-3/PRJNA438862_regulons-DER-astrocytes_dataset-msp_{connectivity_model}-metric_{metric}-k_{k}-sign_{signature}-amb_{cb_fpr}.h5ad"
)
```

# Session info:

```{python}
print(watermark())
print(watermark(iversions=True, globals_=globals()))
```
